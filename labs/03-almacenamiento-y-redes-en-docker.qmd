---
title: "Laboratorio 3: Almacenamiento y Redes - Backend + Almacenamiento"
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt
format:
  html:
    toc: true
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
lightbox: true

---

<style>
.practical-exercise {
  background-color: #f0f8ff;
  border-left: 4px solid #4a86e8;
  padding: 15px;
  margin: 20px 0;
}

.challenge {
  background-color: #fff2cc;
  border-left: 4px solid #ffd966;
  padding: 15px;
  margin: 20px 0;
}

.important-note {
  background-color: #ffe599;
  border-left: 4px solid #f1c232;
  padding: 15px;
  margin: 20px 0;
}

.success {
  background-color: #d9ead3;
  border-left: 4px solid #6aa84f;
  padding: 15px;
  margin: 20px 0;
}

.warning {
  background-color: #fce5cd;
  border-left: 4px solid #e69138;
  padding: 15px;
  margin: 20px 0;
}

.network-diagram {
  background-color: #e8f5e8;
  padding: 20px;
  border-radius: 8px;
  margin: 20px 0;
}
</style>

## Objetivos del Laboratorio

Al completar este laboratorio, los participantes podr√°n:

- Crear y gestionar vol√∫menes Docker para persistencia de datos
- Configurar redes personalizadas para comunicaci√≥n entre contenedores
- Conectar una aplicaci√≥n FastAPI con una base de datos PostgreSQL
- Implementar patrones de almacenamiento y red en escenarios reales
- Solucionar problemas comunes de conectividad y persistencia

## Prerrequisitos

- Docker instalado y funcionando
- Conocimientos b√°sicos de Docker (contenedores, im√°genes, comandos b√°sicos)
- Editor de texto preferido
- Terminal/Command line

## Arquitectura del Sistema

```{mermaid}
graph TB
    A[üåê Usuario] --> B[Puerto 8000:8000]
    B --> C[Contenedor FastAPI]
    C --> D[Red personalizada: app-network]
    D --> E[Contenedor PostgreSQL]
    
    F[Volume: postgres-data] --> E
    G[Bind Mount: c√≥digo] --> C
    
    C --> H[Resoluci√≥n DNS: postgres]
    H --> E
    
    style D fill:#c8e6c9
    style F fill:#e1f5fe
    style G fill:#fff3e0
```

## 1. Configuraci√≥n de Almacenamiento Persistente

### Creaci√≥n y Gesti√≥n de Vol√∫menes

<div class="practical-exercise"> **Objetivo:** Aprender a crear y gestionar vol√∫menes Docker para persistencia de datos. </div>

```powershell
# 1. Crear un volumen para la base de datos PostgreSQL, con etiquetas para mejor organizaci√≥n
docker volume create --label project=taller-docker --label service=postgres postgres-data

# 2. Verificar que el volumen fue creado
docker volume ls

# 3. Inspeccionar el volumen para obtener detalles
docker volume inspect postgres-data
```

**Desaf√≠o:** - ¬øQu√© comando usar√≠as para ver solo los vol√∫menes que no est√°n siendo utilizados? - ¬øC√≥mo podr√≠as crear un volumen con un driver espec√≠fico? - ¬øQu√© informaci√≥n proporciona el comando `docker volume inspect`?

### Uso de Bind Mounts para Desarrollo

**Objetivo:** Configurar bind mounts para desarrollo √°gil de aplicaciones.

```powershell
docker run --mount type=bind,src={carpeta donde est√© el c√≥digo de la app FastAPI},dst=/app mi-fastapi-app:latest
```

## 2. Configuraci√≥n de Redes Personalizadas

### Creaci√≥n y Gesti√≥n de Redes

**Objetivo:** Aprender a crear y configurar redes personalizadas para aislar servicios.

```powershell
# 1. Crear una red bridge personalizada
docker network create app-network

# 2. Verificar la red creada
docker network ls

# 3. Inspeccionar la red para ver detalles de configuraci√≥n
docker network inspect app-network

# 4. Crear una red con configuraci√≥n espec√≠fica
docker network create \
  --driver bridge \
  --subnet=172.20.0.0/16 \
  --gateway=172.20.0.1 \
  app-network-custom

# 5. Comparar las dos redes
docker network inspect app-network-custom
```

## 3. Implementaci√≥n de PostgreSQL con Persistencia

### Despliegue de Base de Datos con Volumen

**Objetivo:** Configurar PostgreSQL con almacenamiento persistente usando vol√∫menes.


```powershell
# 1. Desplegar PostgreSQL con volumen persistente
docker run -d `
  --name postgres-db `
  --network app-network `
  -e POSTGRES_DB=taller_db `
  -e POSTGRES_USER=api_user `
  -e POSTGRES_PASSWORD=secure_password123 `
  -v postgres-data:/var/lib/postgresql/data `
  -p 5432:5432 `
  postgres:latest

# 2. Verificar que el contenedor est√° corriendo
docker ps --filter "name=postgres-db"

# 3. Verificar la conexi√≥n del volumen
docker inspect postgres-db | grep -A 10 "Mounts"

# 4. Probar la conexi√≥n a la base de datos
docker exec postgres-db pg_isready -U api_user -d taller_db

# 5. Ver logs para confirmar inicializaci√≥n
docker logs postgres-db --tail 10
```

**Nota de Seguridad:** En producci√≥n, usa variables de entorno seguras o Docker Secrets para las contrase√±as.

### Verificaci√≥n de Persistencia

```powershell
# 1. Crear una tabla de prueba en la base de datos
docker exec -i postgres-db psql -U api_user -d taller_db << EOF
CREATE TABLE IF NOT EXISTS usuarios (
    id SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO usuarios (nombre, email) VALUES 
('Juan P√©rez', 'juan@example.com'),
('Mar√≠a Garc√≠a', 'maria@example.com');

SELECT * FROM usuarios;
EOF

# 2. Detener el contenedor
docker stop postgres-db

# 3. Verificar que est√° detenido
docker ps -a --filter "name=postgres-db"

# 4. Reiniciar el contenedor
docker start postgres-db

# 5. Verificar que los datos persisten
docker exec -i postgres-db psql -U api_user -d taller_db -c "SELECT * FROM usuarios;"
```

**‚úÖ √âxito:** Los datos deber√≠an mantenerse despu√©s del reinicio, demostrando la persistencia del volumen.

## 4. Desarrollo de la Aplicaci√≥n FastAPI

### Creaci√≥n de la Aplicaci√≥n FastAPI

**Objetivo:** Desarrollar una aplicaci√≥n FastAPI que se conecte a PostgreSQL.

Archivo *main.py* en carpeta "app":

```python
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Optional
import asyncpg
import os
import datetime
from contextlib import asynccontextmanager

# Configuraci√≥n de la base de datos
DATABASE_URL = f"postgresql://{os.getenv('DB_USER', 'api_user')}:{os.getenv('DB_PASSWORD', 'secure_password123')}@{os.getenv('DB_HOST', 'postgres-db')}:{os.getenv('DB_PORT', '5432')}/{os.getenv('DB_NAME', 'taller_db')}"

# Modelos Pydantic
class UsuarioCreate(BaseModel):
    nombre: str
    email: str


class UsuarioResponse(BaseModel):
    id: int
    nombre: str
    email: str
    fecha_creacion: datetime.datetime

# Conexi√≥n a la base de datos
async def get_db_connection():
    conn = await asyncpg.connect(DATABASE_URL)
    try:
        yield conn
    finally:
        await conn.close()

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Inicializaci√≥n: crear tabla si no existe
    conn = await asyncpg.connect(DATABASE_URL)
    try:
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS usuarios (
                id SERIAL PRIMARY KEY,
                nombre VARCHAR(100) NOT NULL,
                email VARCHAR(100) UNIQUE NOT NULL,
                fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        print("‚úÖ Tabla 'usuarios' verificada/creada")
    finally:
        await conn.close()
    yield
    # Cleanup (opcional)

app = FastAPI(
    title="API Taller Docker",
    description="API de ejemplo para el taller de Docker",
    version="1.0.0",
    lifespan=lifespan
)

@app.get("/")
async def root():
    return {"message": "¬°Bienvenido a la API del Taller Docker!", "status": "active"}

@app.get("/health")
async def health_check(conn=Depends(get_db_connection)):
    try:
        # Verificar conexi√≥n a la base de datos
        result = await conn.fetchval("SELECT 1")
        return {
            "status": "healthy",
            "database": "connected" if result == 1 else "disconnected"
        }
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Database error: {str(e)}")

@app.post("/usuarios/", response_model=UsuarioResponse)
async def crear_usuario(usuario: UsuarioCreate, conn=Depends(get_db_connection)):
    try:
        query = "INSERT INTO usuarios (nombre, email) VALUES ($1, $2) RETURNING id, nombre, email, fecha_creacion"
        result = await conn.fetchrow(query, usuario.nombre, usuario.email)
        return dict(result)
    except asyncpg.UniqueViolationError:
        raise HTTPException(status_code=400, detail="El email ya existe")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error del servidor: {str(e)}")

@app.get("/usuarios/", response_model=List[UsuarioResponse])
async def listar_usuarios(conn=Depends(get_db_connection)):
    try:
        results = await conn.fetch("SELECT id, nombre, email, fecha_creacion FROM usuarios ORDER BY id")
        return [dict(row) for row in results]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error del servidor: {str(e)}")

@app.get("/usuarios/{usuario_id}", response_model=UsuarioResponse)
async def obtener_usuario(usuario_id: int, conn=Depends(get_db_connection)):
    result = await conn.fetchrow(
        "SELECT id, nombre, email, fecha_creacion FROM usuarios WHERE id = $1", 
        usuario_id
    )
    if not result:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    return dict(result)
```

### Creaci√≥n del Contenedor Docker

El Dockerfile ser√° el archivo del anterior laboratorio, llamado `Dockerfile.ultraoptimized`.

Contenidos del archivo `requirements.txt`:
```
fastapi[standard]==0.117.1
uvicorn==0.37.0
pydantic==2.11.9
asyncpg==0.30.0
```

```powershell
docker build -t mi-fastapi-app -f Dockerfile.ultraoptimized .

docker run -d `
  --name fastapi-app `
  --network app-network `
  -e DB_HOST=postgres-db `
  -e DB_USER=api_user `
  -e DB_PASSWORD=secure_password123 `
  -e DB_NAME=taller_db `
  -e DB_PORT=5432 `
  -p 8000:8000 `
  -v $(pwd):/app `
  mi-fastapi-app

docker network inspect app-network | grep -A 5 "Containers"

docker logs fastapi-app --tail 15
```

## 5. Verificaci√≥n de Conectividad y Persistencia

### Pruebas de Comunicaci√≥n y Funcionalidad

**Objetivo:** Verificar que la aplicaci√≥n puede comunicarse con la base de datos y funciona correctamente.

```powershell
# 1. Probar el endpoint de health check
curl http://localhost:8000/health

# 2. Probar el endpoint ra√≠z
curl http://localhost:8000/

# 3. Crear un usuario mediante la API
curl -X POST "http://localhost:8000/usuarios/" `
  -H "Content-Type: application/json" `
  -d '{"nombre": "Carlos L√≥pez", "email": "carlos@example.com"}'

# 4. Listar todos los usuarios
curl http://localhost:8000/usuarios/

# 5. Obtener un usuario espec√≠fico
curl http://localhost:8000/usuarios/1
```

- ¬øQu√© ocurre si intentas crear un usuario con un email que ya existe?
- ¬øC√≥mo verificar√≠as la conectividad de red entre los contenedores?

### Diagn√≥stico de Problemas de Conectividad

```powershell
# 1. Simular un problema de red desconectando un contenedor
docker network disconnect app-network fastapi-app

# 2. Verificar que la aplicaci√≥n falla
curl http://localhost:8000/health || echo "‚úÖ Esperado: La aplicaci√≥n falla sin conexi√≥n a la red"

# 3. Reconectar el contenedor a la red
docker network connect app-network fastapi-app

# 4. Verificar que se restablece la conexi√≥n
sleep 5 && curl http://localhost:8000/health

# 5. Probar resoluci√≥n DNS dentro de la red
docker exec fastapi-app ping -c 3 postgres-db

# 6. Verificar conectividad a nivel de puerto
docker exec fastapi-app nc -zv postgres-db 5432
```

### Problemas de Persistencia de Datos

```powershell

# 1. Crear datos importantes
curl -X POST "http://localhost:8000/usuarios/" `
  -H "Content-Type: application/json" `
  -d '{"nombre": "Ana Silva", "email": "ana@example.com"}'

# 2. Listar usuarios para confirmar
curl http://localhost:8000/usuarios/

# 3. Detener y eliminar el contenedor de PostgreSQL (SIMULACI√ìN DE ERROR)
docker stop postgres-db
docker rm postgres-db

# 4. Verificar que el volumen sigue existiendo
docker volume ls | grep postgres-data

# 5. Recrear el contenedor de PostgreSQL con el mismo volumen
docker run -d `
  --name postgres-db `
  --network app-network `
  -e POSTGRES_DB=taller_db `
  -e POSTGRES_USER=api_user `
  -e POSTGRES_PASSWORD=secure_password123 `
  -v postgres-data:/var/lib/postgresql/data `
  -p 5432:5432 `
  postgres:15-alpine

# 6. Verificar que los datos se mantienen
sleep 10 && curl http://localhost:8000/usuarios/
```

## Autoevaluaci√≥n y Validaci√≥n

### Preguntas de Reflexi√≥n

- ¬øPor qu√© es importante usar vol√∫menes para bases de datos en Docker?

- ¬øQu√© ventajas tiene usar una red personalizada en lugar de la red bridge por defecto?

- ¬øC√≥mo resuelve Docker la comunicaci√≥n entre contenedores en la misma red?

- ¬øQu√© ocurrir√≠a si no us√°ramos vol√∫menes y el contenedor de PostgreSQL se eliminara?

- ¬øPor qu√© los bind mounts son √∫tiles en desarrollo pero no recomendados en producci√≥n?
---
title: Enrutamiento avanzado y cargas de trabajo
subtitle: Ingress y Jobs
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
---

# Orquestaci√≥n Local con Docker Compose

## Gestionando tr√°fico HTTP y diferentes cargas de trabajo

---

## El problema: Exponiendo m√∫ltiples servicios web

**Escenario tradicional:**

```bash
# ¬°Demasiados puertos!
Service A: LoadBalancer ‚Üí puerto 30000
Service B: LoadBalancer ‚Üí puerto 30001  
Service C: LoadBalancer ‚Üí puerto 30002
```

**Problemas:**
- Puertos aleatorios dif√≠ciles de recordar
- M√∫ltiples direcciones IP/LB
- No hay enrutamiento por dominio o path
- Costoso en cloud (cada LB cuesta $)


```{mermaid}
graph TB
    A[Usuario] --> B[app1.com:30000]
    A --> C[app2.com:30001]
    A --> D[app3.com:30002]
    
    B --> E[Service A]
    C --> F[Service B]
    D --> G[Service C]
    
    style B fill:#ffebee
    style C fill:#ffebee
    style D fill:#ffebee
```



**¬øNo ser√≠a mejor tener `miapp.com/api` y `miapp.com/web`?**

---

## La soluci√≥n: Ingress - El "router inteligente" de Kubernetes



**¬øQu√© es Ingress?**

- API object que gestiona acceso externo a servicios
- Act√∫a como un "reverse proxy" en el cluster
- Enruta tr√°fico basado en reglas (host/path)

**Beneficios:**

- Un √∫nico punto de entrada
- Enrutamiento por nombre de dominio
- Terminaci√≥n SSL/TLS centralizada
- Costo reducido (solo un LoadBalancer)


```{mermaid}
graph TB
    A[üåê Internet] --> B[Ingress]
    B --> C[/api ‚Üí Service A]
    B --> D[/web ‚Üí Service B]
    B --> E[/admin ‚Üí Service C]
    
    style B fill:#c8e6c9
```



---

## Arquitectura Ingress: Dos componentes clave

```{mermaid}
graph TB
    A[Usuario] --> B[LoadBalancer]
    B --> C[Ingress Controller]
    C --> D[Ingress Resource]
    D --> E[Service A]
    D --> F[Service B]
    D --> G[Service C]
    
    style C fill:#e1f5fe
    style D fill:#fff3e0
```

**1. Ingress Controller:** El "software" que hace el enrutamiento (Nginx, Traefik, etc.)  
**2. Ingress Resource:** La "configuraci√≥n" con las reglas de enrutamiento

---

## Ingress Controller: El cerebro del enrutamiento



**¬øQu√© es?**
- Pod(s) que ejecutan el proxy/reverse proxy
- Monitorea los recursos Ingress en el cluster
- Aplica las reglas de enrutamiento configuradas

**Implementaciones populares:**

- **Nginx Ingress Controller:** El m√°s popular
- **Traefik:** Moderno, con configuraci√≥n autom√°tica
- **HAProxy:** Alto rendimiento
- **Istio:** Service mesh con capacidades Ingress

**Funcionamiento:**

- Escucha en un puerto (80/443)
- Aplica reglas de los recursos Ingress
- Balancea carga entre Pods


```{mermaid}
graph TB
    A[Controller] --> B[Monitor Ingress]
    B --> C[Configurar Proxy]
    C --> D[Enrutar Tr√°fico]
    
    style A fill:#f3e5f5
```


---

## Ingress Resource: Las reglas de enrutamiento


**¬øQu√© es?**

- Recurso YAML que define reglas de enrutamiento
- Especifica qu√© servicio atiende cada ruta
- Configura hosts virtuales y paths

**Reglas comunes:**

- **Host-based:** `api.midominio.com` ‚Üí Service A
- **Path-based:** `midominio.com/api` ‚Üí Service A
- **Mixed:** `midominio.com/api` y `midominio.com/web`

**Ventaja:** Configuraci√≥n declarativa como todo en K8s


```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: miapp.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
```


---

## Ejemplo completo: Ingress Resource

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: mi-dominio.com
    http:
      paths:
      - path: /uno
        pathType: Prefix
        backend:
          service:
            name: app-uno-service
            port:
              number: 80
      - path: /dos
        pathType: Prefix
        backend:
          service:
            name: app-dos-service
            port:
              number: 80
```

---

## Comparaci√≥n: Service vs Ingress

```{mermaid}
graph TB
    A[Acceso Externo] --> B[Service LoadBalancer]
    A --> C[Ingress]
    
    B --> D[1 Service = 1 LB]
    D --> E[Coste alto]
    D --> F[Puertos aleatorios]
    
    C --> G[1 Ingress = M√∫ltiples servicios]
    G --> H[Coste bajo]
    G --> I[Enrutamiento inteligente]
    
    style B fill:#ffebee
    style C fill:#c8e6c9
```

---

## Flujo de tr√°fico con Ingress

```{mermaid}
graph LR
    A[Usuario] --> B[dominio.com/uno]
    B --> C[DNS ‚Üí LoadBalancer IP]
    C --> D[Ingress Controller]
    D --> E[Consulta reglas Ingress]
    E --> F[dominio.com/uno ‚Üí app-uno-service]
    F --> G[app-uno Pods]
    
    style D fill:#e1f5fe
    style E fill:#fff3e0
```

---

## M√°s all√° de los servicios web: Jobs y CronJobs


**Problema:** ¬øY las tareas que no son servicios continuos?

**Ejemplos:**

- Procesar archivos por lotes
- Generar reportes nocturnos
- Limpiar datos temporales
- Backup de bases de datos

**Deployment no sirve para esto:**

- Deployment mantiene Pods siempre ejecut√°ndose
- Necesitamos Pods que se ejecuten y terminen


```{mermaid}
graph TB
    A[Tareas batch] --> B[‚ùå Deployment]
    A --> C[‚úÖ Jobs]
    
    style B fill:#ffcdd2
    style C fill:#c8e6c9
```
:::
:::

---

## Jobs: Tareas que se ejecutan una vez



**¬øQu√© es un Job?**

- Crea uno o m√°s Pods
- Ejecuta una tarea hasta completarse exitosamente
- Los Pods no se reinician al terminar

**Casos de uso:**

- Procesamiento de datos por lotes
- Migraci√≥n de base de datos
- Ejecuci√≥n de scripts de mantenimiento
- Trabajos de c√°lculo intensivo

**Caracter√≠sticas clave:**

- `completions`: Cu√°ntas veces ejecutar la tarea
- `parallelism`: Cu√°ntos Pods ejecutar simult√°neamente
- `backoffLimit`: Reintentos ante fallos


```{mermaid}
graph TB
    A[Job Created] --> B[Pod Created]
    B --> C[Task Running]
    C --> D[Task Completed]
    D --> E[Pod Terminated]
    
    style D fill:#c8e6c9
```


---

## Anatom√≠a de un Job

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: procesar-archivos
spec:
  completions: 3
  parallelism: 2
  backoffLimit: 4
  template:
    spec:
      containers:
      - name: processor
        image: my-processor:latest
        command: ["python", "procesar.py"]
      restartPolicy: Never
```

**Comportamiento:**

- Ejecutar√° hasta 3 tareas exitosas
- 2 Pods en paralelo m√°ximo
- Hasta 4 reintentos por tarea fallida

---

## CronJobs: Tareas programadas


**¬øQu√© es un CronJob?**

- Como un Job, pero ejecutado en un schedule
- Usa sintaxis cron est√°ndar
- Crea Jobs seg√∫n la programaci√≥n

**Casos de uso:**

- Backups nocturnos
- Reportes diarios/semanales
- Limpieza de datos temporales
- Sincronizaci√≥n peri√≥dica

**Ejemplo cron:**

- `0 * * * *` = cada hora
- `0 2 * * *` = cada d√≠a a las 2 AM
- `*/5 * * * *` = cada 5 minutos


```{mermaid}
graph TB
    A[CronJob] --> B[Schedule]
    B --> C[Create Job]
    C --> D[Job Runs]
    D --> E[Cleanup]
    
    style B fill:#fff3e0
```



---

## Ejemplo de CronJob

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: backup-nightly
spec:
  schedule: "0 2 * * *"  # 2 AM daily
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: postgres:13
            command:
            - /bin/sh
            - -c
            - pg_dump -h $DB_HOST -U $DB_USER $DB_NAME > /backup/backup.sql
          restartPolicy: OnFailure
```

**Caracter√≠sticas importantes:**

- `startingDeadlineSeconds`: Tiempo m√°ximo para iniciar
- `concurrencyPolicy`: Permitir ejecuciones concurrentes
- `successfulJobsHistoryLimit`: Cu√°ntos jobs exitosos conservar

---

## Comparaci√≥n: Deployment vs Job vs CronJob

```{mermaid}
graph TB
    A[Tipo] --> B[Deployment]
    A --> C[Job]
    A --> D[CronJob]
    
    B --> E[Servicios largos]
    C --> F[Tareas √∫nicas]
    D --> G[Tareas programadas]
    
    B --> H[Mantiene N Pods running]
    C --> I[Ejecuta hasta completar]
    D --> J[Crea Jobs seg√∫n schedule]
    
    style B fill:#e1f5fe
    style C fill:#fff3e0
    style D fill:#f3e5f5
```

---

## Flujo completo: Arquitectura con m√∫ltiples controladores

```{mermaid}
graph TB
    A[Usuario Web] --> B[Ingress]
    B --> C[Deployment - App Web]
    
    D[Schedule] --> E[CronJob]
    E --> F[Job - Backup]
    F --> G[Database StatefulSet]
    
    H[Admin] --> I[Job Manual - Migraci√≥n]
    
    style B fill:#c8e6c9
    style C fill:#e1f5fe
    style E fill:#f3e5f5
    style G fill:#fff3e0
```

---

## Patrones comunes de uso



**Aplicaci√≥n web t√≠pica:**

```{mermaid}
graph TB
    A[Ingress] --> B[Deployment - Frontend]
    A --> C[Deployment - Backend]
    C --> D[StatefulSet - Database]
    
    E[CronJob] --> F[Job - Cleanup]
    F --> D
```


**Procesamiento de datos:**

```{mermaid}
graph TB
    A[CronJob - Hourly] --> B[Job - Process Data]
    C[CronJob - Daily] --> D[Job - Generate Reports]
    
    B --> E[Deployment - API]
    D --> F[Storage]
```



---

## Buenas pr√°cticas con Ingress

**Seguridad:**

- Usa HTTPS con certificados TLS
- Limita tr√°fico con network policies
- Considera WAF (Web Application Firewall)

**Configuraci√≥n:**

- Annotations espec√≠ficas del controller
- Timeouts apropiados para tu aplicaci√≥n
- Health checks configurados

**Monitoreo:**

- Logs de acceso del Ingress Controller
- M√©tricas de latencia y errores
- Alertas para reglas no satisfechas

---

## Buenas pr√°cticas con Jobs/CronJobs

**Robustez:**

- Configura `backoffLimit` apropiado
- Usa `activeDeadlineSeconds` para timeout
- Maneja graceful shutdown en los contenedores

**Recursos:**

- Requests/limits de CPU/memoria
- Considera `ttlSecondsAfterFinished` para cleanup
- Storage temporal si es necesario

**Monitoreo:**

- Alertas para Jobs fallidos
- Logs centralizados de ejecuciones
- M√©tricas de duraci√≥n y √©xito

---

## Resumen: Cu√°ndo usar cada recurso

| Escenario | Recurso recomendado |
|-----------|---------------------|
| **Servicio web continuo** | Deployment + Service |
| **Acceso HTTP inteligente** | Ingress |
| **Base de datos/con estado** | StatefulSet |
| **Tarea √∫nica** | Job |
| **Tarea programada** | CronJob |

---

## Arquitectura completa de ejemplo

```{mermaid}
graph TB
    A[üåê Internet] --> B[Ingress]
    
    B --> C[Deployment - Frontend]
    B --> D[Deployment - API]
    B --> E[Deployment - Admin]
    
    D --> F[StatefulSet - PostgreSQL]
    D --> G[Deployment - Redis]
    
    H[CronJob - Backup] --> I[Job - Backup DB]
    I --> F
    
    J[CronJob - Cleanup] --> K[Job - Clean Cache]
    K --> G
    
    style B fill:#c8e6c9
    style F fill:#fff3e0
    style I fill:#f3e5f5
```

---

## ¬°Dominando el tr√°fico y las tareas!

**Hoy has aprendido:**

- Ingress para enrutamiento HTTP inteligente
- Jobs para tareas √∫nicas y batch
- CronJobs para tareas programadas
- Cu√°ndo usar cada tipo de controlador

**Pr√≥ximo:**

Laboratorio pr√°ctico configurando Ingress para m√∫ltiples aplicaciones y automatizando tareas con CronJobs.
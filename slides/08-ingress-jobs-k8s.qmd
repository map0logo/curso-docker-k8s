---
title: Enrutamiento avanzado y cargas de trabajo
subtitle: Ingress y Jobs
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
---

# Orquestaci√≥n Local con Docker Compose

## Gestionando tr√°fico HTTP y diferentes cargas de trabajo

---

## El problema: Exponiendo m√∫ltiples servicios web

**Escenario tradicional:**

```bash
# ¬°Demasiados puertos!
Service A: LoadBalancer ‚Üí puerto 30000
Service B: LoadBalancer ‚Üí puerto 30001  
Service C: LoadBalancer ‚Üí puerto 30002
```

**Problemas:**

- Puertos aleatorios dif√≠ciles de recordar
- M√∫ltiples direcciones IP/LB
- No hay enrutamiento por dominio o path
- Costoso en cloud (cada LB cuesta $)

Por ejemplo, imagina esto:

- Tienes **5 aplicaciones web** en tu cl√∫ster.  
- Cada una necesita estar accesible desde internet.  
- Si usas `LoadBalancer`‚Ä¶  
  ‚Üí ¬°5 IPs p√∫blicas!  
  ‚Üí ¬°5 balanceadores de carga!  
  ‚Üí ¬°5 facturas de la nube! üí∏

> üò© **Y ni siquiera puedes usar el mismo dominio para todas**.


```{mermaid}
graph TB
    A[Usuario] --> B[app1.com:30000]
    A --> C[app2.com:30001]
    A --> D[app3.com:30002]
    
    B --> E[Service A]
    C --> F[Service B]
    D --> G[Service C]
    
    style B fill:#ffebee
    style C fill:#ffebee
    style D fill:#ffebee
```


**¬øNo ser√≠a mejor tener `miapp.com/api` y `miapp.com/web`?**

---

## La soluci√≥n: Ingress - El "router inteligente" de Kubernetes



**¬øQu√© es Ingress?**

- API object que gestiona acceso externo a servicios
- Act√∫a como un "reverse proxy" en el cluster
- Enruta tr√°fico basado en reglas (host/path)


**Ingress** es un objeto de Kubernetes que **gestiona el acceso externo a los servicios**, especialmente para **tr√°fico HTTP/HTTPS**.

- Permite **enrutamiento por host** (`app1.miempresa.com`)  
- Permite **enrutamiento por ruta** (`miempresa.com/app1`)  
- Soporta **TLS/SSL** (HTTPS)  
- Todo con **un solo IP p√∫blica**

> **Piensa en Ingress como el ‚Äúportero de un edificio de oficinas‚Äù**:  
> Recibe a todos los visitantes y los dirige al piso correcto.


**Beneficios:**

- Un √∫nico punto de entrada
- Enrutamiento por nombre de dominio
- Terminaci√≥n SSL/TLS centralizada
- Costo reducido (solo un LoadBalancer)


```{mermaid}
graph TB
    A[üåê Internet] --> B[Ingress]
    B --> C[/api ‚Üí Service A]
    B --> D[/web ‚Üí Service B]
    B --> E[/admin ‚Üí Service C]
    
    style B fill:#c8e6c9
```



---

## ¬øPor qu√© Ingress > LoadBalancer?

| Caracter√≠stica        | Service `LoadBalancer` | Ingress |
|----------------------|------------------------|--------|
| **IP p√∫blicas**      | 1 por servicio         | **1 para todos** |
| **Enrutamiento HTTP**| No                     | **S√≠ (por host/ruta)** |
| **TLS**              | Manual (por servicio)  | **Centralizado** |
| **Costo en la nube** | Alto                   | **Bajo** |
| **Escalabilidad**    | Pobre                  | **Excelente** |

> üí∞ **Ejemplo real**:  
> 10 apps ‚Üí 10 LoadBalancers = $300/mes  
> 10 apps ‚Üí 1 Ingress = $30/mes

---

## Arquitectura Ingress: Dos componentes clave

```{mermaid}
graph TB
    A[Usuario] --> B[LoadBalancer]
    B --> C[Ingress Controller]
    C --> D[Ingress Resource]
    D --> E[Service A]
    D --> F[Service B]
    D --> G[Service C]
    
    style C fill:#e1f5fe
    style D fill:#fff3e0
```

**1. Ingress Controller:** 

- El "software" que hace el enrutamiento (Nginx, Traefik, HAProxy etc.)
- Escucha en un puerto (80/443) y **eval√∫a las reglas de Ingress**
- **No viene por defecto** ‚Üí ¬°debes instalarlo!

**2. Ingress Resource:** 

La "configuraci√≥n" con las reglas de enrutamiento. Es un **objeto YAML** que defines indic√°ndole al Controller **c√≥mo enrutar el tr√°fico**

---

```{mermaid}
graph LR
  Internet -->|HTTP/HTTPS| IngressController["Ingress Controller\n(ej: NGINX Pod)"]
  IngressController -->|/app1| Service1["Service: app-uno"]
  IngressController -->|/app2| Service2["Service: app-dos"]
  Service1 --> Pods1["Pods app-uno"]
  Service2 --> Pods2["Pods app-dos"]
```

> üîë **Sin Controller, el recurso Ingress no hace nada** ‚Üí ¬°es solo una hoja de instrucciones!

---


## Ingress Controller: El cerebro del enrutamiento


**¬øQu√© es?**

- Pod(s) que ejecutan el proxy/reverse proxy
- Monitorea los recursos Ingress en el cluster
- Aplica las reglas de enrutamiento configuradas

**Implementaciones populares:**

- **Nginx Ingress Controller:** El m√°s popular
- **Traefik:** Moderno, con configuraci√≥n autom√°tica
- **HAProxy:** Alto rendimiento
- **Istio:** Service mesh con capacidades Ingress

**Funcionamiento:**

- Escucha en un puerto (80/443)
- Aplica reglas de los recursos Ingress
- Balancea carga entre Pods


```{mermaid}
graph TB
    A[Controller] --> B[Monitor Ingress]
    B --> C[Configurar Proxy]
    C --> D[Enrutar Tr√°fico]
    
    style A fill:#f3e5f5
```


---

## Ingress Resource: Las reglas de enrutamiento


**¬øQu√© es?**

- Recurso YAML que define reglas de enrutamiento
- Especifica qu√© servicio atiende cada ruta
- Configura hosts virtuales y paths

**Reglas comunes:**

- **Host-based:** `api.midominio.com` ‚Üí Service A
- **Path-based:** `midominio.com/api` ‚Üí Service A
- **Mixed:** `midominio.com/api` y `midominio.com/web`

**Ventaja:** Configuraci√≥n declarativa como todo en K8s


```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: miapp.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
```


---

## Ejemplo completo: Ingress Resource

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: mi-dominio.com
    http:
      paths:
      - path: /uno
        pathType: Prefix
        backend:
          service:
            name: app-uno-service
            port:
              number: 80
      - path: /dos
        pathType: Prefix
        backend:
          service:
            name: app-dos-service
            port:
              number: 80
```

---

## Comparaci√≥n: Service vs Ingress

```{mermaid}
graph TB
    A[Acceso Externo] --> B[Service LoadBalancer]
    A --> C[Ingress]
    
    B --> D[1 Service = 1 LB]
    D --> E[Coste alto]
    D --> F[Puertos aleatorios]
    
    C --> G[1 Ingress = M√∫ltiples servicios]
    G --> H[Coste bajo]
    G --> I[Enrutamiento inteligente]
    
    style B fill:#ffebee
    style C fill:#c8e6c9
```

---

## Flujo de tr√°fico con Ingress

```{mermaid}
graph LR
    A[Usuario] --> B[dominio.com/uno]
    B --> C[DNS ‚Üí LoadBalancer IP]
    C --> D[Ingress Controller]
    D --> E[Consulta reglas Ingress]
    E --> F[dominio.com/uno ‚Üí app-uno-service]
    F --> G[app-uno Pods]
    
    style D fill:#e1f5fe
    style E fill:#fff3e0
```

---

## TLS/SSL con Ingress: HTTPS sin dolor

### ¬øC√≥mo cifrar el tr√°fico?

1. Creas un **Secret** con tu certificado TLS
2. Lo referencias en el Ingress

```yaml
spec:
  tls:
  - hosts:
    - mi-dominio.com
    secretName: mi-certificado-tls
  rules:
  - host: mi-dominio.com
    http:
      paths:
      - path: /uno
        ...
```

> üîí **El Ingress Controller maneja el descifrado** ‚Üí 

> tus apps siguen hablando **HTTP interno** (m√°s simple y seguro dentro del cl√∫ster).

---

## M√°s all√° de los servicios web: Jobs y CronJobs


**Problema:**

¬øY las tareas que no son servicios continuos?

**Ejemplos:**

- Procesar archivos por lotes
- Generar reportes nocturnos
- Limpiar datos temporales
- Backup de bases de datos

**Deployment no sirve para esto:**

- Deployment mantiene Pods siempre ejecut√°ndose
- Necesitamos Pods que se ejecuten y terminen


```{mermaid}
graph TB
    A[Tareas batch] --> B[‚ùå Deployment]
    A --> C[‚úÖ Jobs]
    
    style B fill:#ffcdd2
    style C fill:#c8e6c9
```

> üß© **Kubernetes tiene controladores para eso**: `Job` y `CronJob`.

---

## Jobs: Tareas que se ejecutan una vez


**¬øQu√© es un Job?**

- Crea uno o m√°s Pods
- Ejecuta una tarea hasta completarse exitosamente
- Los Pods no se reinician al terminar

**Casos de uso:**

- Procesamiento de datos por lotes
- Migraci√≥n de base de datos
- Ejecuci√≥n de scripts de mantenimiento
- Trabajos de c√°lculo intensivo

**Caracter√≠sticas clave:**

- `completions`: Cu√°ntas veces ejecutar la tarea
- `parallelism`: Cu√°ntos Pods ejecutar simult√°neamente
- `backoffLimit`: Reintentos ante fallos


```{mermaid}
graph TB
    A[Job Created] --> B[Pod Created]
    B --> C[Task Running]
    C --> D[Task Completed]
    D --> E[Pod Terminated]
    
    style D fill:#c8e6c9
```


---

## Anatom√≠a de un Job

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: procesar-archivos
spec:
  completions: 3
  parallelism: 2
  backoffLimit: 4
  template:
    spec:
      containers:
      - name: processor
        image: my-processor:latest
        command: ["python", "procesar.py"]
      restartPolicy: Never
```

**Comportamiento:**

- Ejecutar√° hasta 3 tareas exitosas
- 2 Pods en paralelo m√°ximo
- Hasta 4 reintentos por tarea fallida

---

## CronJobs: Tareas programadas


**¬øQu√© es un CronJob?**

- Como un Job, pero ejecutado con una programaci√≥n
- Usa sintaxis cron est√°ndar
- Crea Jobs seg√∫n la programaci√≥n

**Casos de uso:**

- Backups nocturnos
- Reportes diarios/semanales
- Limpieza de datos temporales
- Sincronizaci√≥n peri√≥dica

**Ejemplo cron:**

- `0 * * * *` = cada hora
- `0 2 * * *` = cada d√≠a a las 2 AM
- `*/5 * * * *` = cada 5 minutos


```{mermaid}
graph TB
    A[CronJob] --> B[Schedule]
    B --> C[Create Job]
    C --> D[Job Runs]
    D --> E[Cleanup]
    
    style B fill:#fff3e0
```


> ‚è∞ **Es el reemplazo moderno de `cron` en servidores**,  
> pero con logs, monitoreo y gesti√≥n integrados en Kubernetes.

---

## Ejemplo de CronJob

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: backup-nightly
spec:
  schedule: "0 2 * * *"  # 2 AM daily
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: postgres:13
            command:
            - /bin/sh
            - -c
            - pg_dump -h $DB_HOST -U $DB_USER $DB_NAME > /backup/backup.sql
          restartPolicy: OnFailure
```

**Caracter√≠sticas importantes:**

- `startingDeadlineSeconds`: Tiempo m√°ximo para iniciar
- `concurrencyPolicy`: Permitir ejecuciones concurrentes
- `successfulJobsHistoryLimit`: Cu√°ntos jobs exitosos conservar

---

## Comparaci√≥n: Deployment vs Job vs CronJob

```{mermaid}
graph TB
    A[Tipo] --> B[Deployment]
    A --> C[Job]
    A --> D[CronJob]
    
    B --> E[Servicios largos]
    C --> F[Tareas √∫nicas]
    D --> G[Tareas programadas]
    
    B --> H[Mantiene N Pods running]
    C --> I[Ejecuta hasta completar]
    D --> J[Crea Jobs seg√∫n schedule]
    
    style B fill:#e1f5fe
    style C fill:#fff3e0
    style D fill:#f3e5f5
```

---

## Flujo completo: Arquitectura con m√∫ltiples controladores

```{mermaid}
graph TB
    A[Usuario Web] --> B[Ingress]
    B --> C[Deployment - App Web]
    
    D[Schedule] --> E[CronJob]
    E --> F[Job - Backup]
    F --> G[Database StatefulSet]
    
    H[Admin] --> I[Job Manual - Migraci√≥n]
    
    style B fill:#c8e6c9
    style C fill:#e1f5fe
    style E fill:#f3e5f5
    style G fill:#fff3e0
```

---

## Patrones comunes de uso



**Aplicaci√≥n web t√≠pica:**

```{mermaid}
graph TB
    A[Ingress] --> B[Deployment - Frontend]
    A --> C[Deployment - Backend]
    C --> D[StatefulSet - Database]
    
    E[CronJob] --> F[Job - Cleanup]
    F --> D
```


**Procesamiento de datos:**

```{mermaid}
graph TB
    A[CronJob - Hourly] --> B[Job - Process Data]
    C[CronJob - Daily] --> D[Job - Generate Reports]
    
    B --> E[Deployment - API]
    D --> F[Storage]
```



---

## Buenas pr√°cticas con Ingress

### 1. Usa nombres de host reales en desarrollo
- Configura `/etc/hosts` para apuntar `mi-dominio.com` a la IP del Ingress
- As√≠ pruebas como en producci√≥n

### 2. Agrupa reglas relacionadas en un solo Ingress
- M√°s f√°cil de gestionar que 10 objetos Ingress separados

### 3. Nunca expongas Services directamente con `LoadBalancer` si usas Ingress
- Rompe el modelo de enrutamiento centralizado

### 4. Usa `pathType: Prefix` (no `ImplementationSpecific`)
- Es m√°s portable entre Ingress Controllers

> üõ°Ô∏è **Ingress es tu primera l√≠nea de defensa**:  
> Valida, filtra y enruta antes de que el tr√°fico llegue a tus apps.

---

## ¬øQu√© NO hacer con Ingress?

| ‚ùå Mal | ‚úÖ Bien |
|--------|--------|
| Usar Ingress para tr√°fico TCP/UDP (ej: bases de datos) | Usar `Service: LoadBalancer` o `NodePort` |
| Olvidar instalar el Ingress Controller | Verificar que el Controller est√© corriendo antes de crear Ingress |
| Poner l√≥gica de negocio en las reglas de Ingress | Usar Ingress solo para enrutamiento, no para autenticaci√≥n compleja |
| Asumir que todos los Ingress Controllers soportan las mismas features | Consultar la documentaci√≥n de tu Controller (NGINX ‚â† Traefik) |

> ‚ö†Ô∏è **Ingress es solo para HTTP/HTTPS** ‚Üí no intentes forzar otros protocolos.

---

## Buenas pr√°cticas con Jobs/CronJobs

**Robustez:**

- Configura `backoffLimit` apropiado
- Usa `activeDeadlineSeconds` para timeout
- Maneja graceful shutdown en los contenedores

**Recursos:**

- Requests/limits de CPU/memoria
- Considera `ttlSecondsAfterFinished` para cleanup
- Storage temporal si es necesario

**Monitoreo:**

- Alertas para Jobs fallidos
- Logs centralizados de ejecuciones
- M√©tricas de duraci√≥n y √©xito

---

## Resumen: Cu√°ndo usar cada recurso

| Escenario | Recurso recomendado |
|-----------|---------------------|
| **Servicio web continuo** | Deployment + Service |
| **Acceso HTTP inteligente** | Ingress |
| **Base de datos/con estado** | StatefulSet |
| **Tarea √∫nica** | Job |
| **Tarea programada** | CronJob |

---

## Resumen visual: Tu cl√∫ster con Ingress

```{mermaid}
graph LR
  Internet -->|mi-dominio.com/uno| IngressController
  Internet -->|mi-dominio.com/dos| IngressController
  IngressController --> AppUno["app-uno<br/>ClusterIP"]
  IngressController --> AppDos["app-dos<br/>ClusterIP"]
  CronJob["CronJob"] -->|programado| BackupJob["Job: backup"]
  BackupJob --> DB["Base de Datos"]
```

- **Un solo punto de entrada** para m√∫ltiples apps  
- **Enrutamiento inteligente** por URL  
- **Tareas programadas** sin servidores adicionales

---

## Arquitectura completa de ejemplo

```{mermaid}
graph TB
    A[üåê Internet] --> B[Ingress]
    
    B --> C[Deployment - Frontend]
    B --> D[Deployment - API]
    B --> E[Deployment - Admin]
    
    D --> F[StatefulSet - PostgreSQL]
    D --> G[Deployment - Redis]
    
    H[CronJob - Backup] --> I[Job - Backup DB]
    I --> F
    
    J[CronJob - Cleanup] --> K[Job - Clean Cache]
    K --> G
    
    style B fill:#c8e6c9
    style F fill:#fff3e0
    style I fill:#f3e5f5
```

---

## ¬°Dominando el tr√°fico y las tareas!

**Hoy has aprendido:**

- Ingress para enrutamiento HTTP inteligente
- Jobs para tareas √∫nicas y batch
- CronJobs para tareas programadas
- Cu√°ndo usar cada tipo de controlador

**Pr√≥ximo:**

Laboratorio pr√°ctico configurando Ingress para m√∫ltiples aplicaciones y automatizando tareas con CronJobs.
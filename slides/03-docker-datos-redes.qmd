---
title: Almacenamiento y Redes en Docker
subtitle: Almacenamiento persistente y comunicación entre contenedores
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
lightbox: true
---

# Almacenamiento y Redes en Docker
**Almacenamiento persistente y comunicación entre contenedores**

---

## ¿Por qué nos importa el almacenamiento?

**Problema:** Los contenedores son efímeros

- Por diseño, los contenedores son temporales
- Cuando un contenedor se elimina, TODO su contenido desaparece
- ¡Incluyendo bases de datos, archivos de configuración, logs!

```{mermaid}
graph LR
    A[Contenedor MySQL] --> B[Datos en capa escribible]
    B --> C[¡Contenedor eliminado!]
    C --> D[💥 Datos perdidos]
```

## ¿Por qué nos importa el almacenamiento? 2

- Todo lo que guardas dentro del contenedor **desaparece** al detenerlo.
- ¡Imagina perder la base de datos cada vez que reinicias tu app!

> 🤯 **¡No! Necesitamos un lugar donde los datos vivan más allá del contenedor.**

**Solución:** Necesitamos almacenamiento PERSISTENTE

> 💡 **¡Tu aplicación no es solo código! Es código + datos + comunicación.**

---

## Storage Drivers: Los Mecánicos Ocultos

Antes, hablemos antes del almacenamiento dentro de Docker:

### ¿Qué hacen?
- Manejan las **capas** de imágenes
- Implementan **copy-on-write**
- Gestionan el **Union File System**

### Drivers populares:
```bash
# Ver tu driver actual
docker system info | grep "Storage Driver"

# Opciones comunes:
# • overlay2 (recomendado)
# • windowsfilter # alternativa en Windows
# • btrf: alternativa en Debian y Ubuntu
# • zfs: permite snapshots, checksum, compresión, etc.
```

## Storage Drivers: Los Mecánicos Ocultos 2

:::{ .columns}

:::{ .column width="60%"}
![Capas Docker](images/docker-layers.png){width=90%}

:::

:::{ .column width="40%"}

\

**Cada instrucción en tu Dockerfile = una nueva capa**

```dockerfile
FROM ubuntu:22.04
LABEL org.opencontainers.image.authors="org@example.com"
COPY . /app
RUN make /app
RUN rm -r $HOME/.cache
CMD python /app/app.py
```
:::
:::

## Storage Drivers: Los Mecánicos Ocultos 3

:::{ .columns}
:::{ .column width="70%"}
![Capas Docker](images/sharing-layers.png){width=90%}

Todos los contenedores generados a partir de una imagen **comparten las capas inmutables**
:::

:::{ .column width="30%"}
Los archivos que modificas dentro de la capa R/W **no afectan a los demás contenedores**. Los archivos que modificas de las capas inmutables R/O son nuevas versiones de los archivos originales **CoW**.
:::
:::

## ¿Por qué los datos desaparecen?

Cuando un contenedor se elimina, **todo su sistema de archivos (UFS) se destruye**.

Esto incluye:

- Archivos creados durante la ejecución  
- Bases de datos  
- Logs  
- Configuraciones generadas

## Solución: Almacenamiento persistente

> 🧠 **Los contenedores son efímeros por diseño** → pero **tus datos no deberían serlo**.

> 💡 **Regla de oro**:  
> **Nunca almacenes datos importantes dentro del contenedor sin persistencia externa.**

---


## Docker ofrece **tres formas principales** de guardar datos fuera del contenedor:

1. **Bind mounts**  
   → Monta un directorio o archivo del **host** dentro del contenedor.

2. **Volumes**  
   → Almacenamiento gestionado por Docker (recomendado para producción).

3. **tmpfs mounts**  
   → Almacenamiento en memoria (no persistente, útil para datos temporales).

## Formas de guardar datos en fuera del contenedor

🧠 **Piensa en ello como elegir entre:**

- Guardar en tu casa (*bind mount*)
- Guardar en una caja fuerte del banco (*volume*)
- Guardar en una pizarra (*tmpfs*)

---

## El sistema de archivos de Docker

```{mermaid}
graph LR
    A[Imagen Base] --> B[Capa 1: SO]
    A --> C[Capa 2: Aplicación]
    A --> D[Capa 3: Configuración]
    
    B --> E[Contenedor]
    C --> E
    D --> E
    
    E --> F[Capa escribible<br/>Union File System]
    
    style F fill:#e1f5fe
```

**Concepto clave:** Capas superpuestas

- **Capas de solo lectura:** Provenientes de la imagen
- **Capa escribible:** Única por contenedor
- **Union File System:** Combina todas las capas

---

## Tipos de almacenamiento en Docker

```{mermaid}
graph LR
    A[Almacenamiento Docker] --> B[Bind Mounts]
    A --> C[Volumes]
    A --> D[tmpfs mounts]
    
    B --> E[Host directamente]
    C --> F[Gestionado por Docker]
    D --> G[Memoria RAM]
    
    style C fill:#c8e6c9
```

---

## Volumes: La opción recomendada

**¿Qué son?**

Un **Volume** es un directorio **gestionado por Docker** fuera del ciclo de vida del contenedor.

- Almacenado en `/var/lib/docker/volumes/` (en Linux)
- Sobrevive a la eliminación del contenedor
- Funciona en todos los sistemas operativos (incluyendo Docker Desktop)
- Compatible con clusters (Swarm, Kubernetes)

## Volumes: La opción recomendada 2

**Ventajas:**

- Aislamiento del sistema de archivos del host  
- Fácil de respaldar (`docker run --rm -v mi-volumen:/datos alpine tar czf - -C /datos .`)  
- Seguro y portable
- Gestionados mediante CLI de Docker
- Mejor rendimiento en algunos sistemas

## Volumes: La opción recomendada 3

:::{ .columns}

:::{ .column width="50%"}
```{mermaid}
graph TB
    A[Contenedor A] --> C[Volume MySQL]
    B[Contenedor B] --> C
    D[Contenedor C] --> C
    
    C --> E[Persiste entre contenedores]
    E --> F[Sobrevive a reinicios]
```

:::
:::{ .column width="50%"}

```{mermaid}
graph TB
  Container["Contenedor"] -->|escribe| Volume["Docker Volume"]
  Volume -->|persiste| Disco["Disco del Host"]
  style Volume fill:#4CAF50,stroke:#388E3C,color:white
```
:::
:::

**Ubicación típica:**

- Linux: `/var/lib/docker/volumes/`
- Windows: `C:\ProgramData\docker\volumes\`

---

## Gestión de Volumes

### Comandos esenciales

```bash
# Crear un volúmen
docker volume create mi-db-data
# Listar volúmenes
docker volume ls
# Inspeccionar un volúmen
docker volume inspect mi-db-data
# Eliminar un volúmen (¡solo si no está en uso!)
docker volume rm mi-db-data
```

> 🔍 **Docker asigna un nombre único si no lo especificas**,  
> pero **¡siempre nombra tus volúmenes!** → facilita la gestión y el debugging.

## Usando Volúmenes en la Práctica

:::{ .columns}
:::{ .column width="50%"}

\

### Opción 1: Volúmen anónimo

```bash
# Docker crea un volúmen automáticamente
docker run -v /ruta/en/contenedor mi-app

# Ejemplo: base de datos
docker run -d \
  --name mysql-db \
  -v /var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=secret \
  mysql:8.0
```
:::
:::{ .column width="50%"}

\

### Opción 2: Volúmen con nombre

```bash
# Volume explícito
docker run -v nombre-volumen:/ruta/en/contenedor mi-app

# Ejemplo completo
docker volume create app-data
docker run -d \
  --name mi-app \
  -v app-data:/app/data \
  -p 8080:8080 \
  mi-app:prod
```
:::
:::

---

## Demo: Aplicación con Persistencia Real

```bash
# 1. Crear volúmen para datos de aplicación
docker volume create app-database

# 2. Ejecutar contenedor con persistencia
docker run -d \
  --name todo-app \
  -v app-database:/app/db \
  -p 3000:3000 \
  todo-app:latest

# 3. Verificar que los datos persisten
docker stop todo-app
docker rm todo-app

# 4. Recuperar datos
docker run -d \
  --name todo-app-restored \
  -v app-database:/app/db \
  -p 3000:3000 \
  todo-app:latest

# ¡Los datos siguen ahí!
```


---

## Bind Mounts: Conexión directa

**¿Qué son?**

- Montaje de un directorio específico del host
- El contenedor accede directamente al filesystem del host
- Mapea un **directorio o archivo específico del host** directamente al contenedor.

### Casos de uso ideales:

- 🔧 **Desarrollo** (cambios en caliente)
- 📝 **Configuraciones** específicas del host
- 🛠️ **Herramientas** del sistema que necesitan acceso

## Bind Mounts: Conexión directa 2

::: {.columns}
::: {.column width="50%"}
```{mermaid}
graph TB
  HostDir["/home/usuario/proyecto"] -->|montado en| Container["/app"]
  Container --> App["App ve los archivos
  en tiempo real"]
```
:::
::: {.column width="50%"}
**Ejemplo real:**
```{mermaid}
graph TB
    A["$(pwd)/app"] --> B["Contenedor App"]
    C["$(pwd)/config"] --> B
    
    style A fill:#fff3e0
    style C fill:#fff3e0
```
:::
:::

```bash
# Sintaxis básica
docker run -v /home/usuario/proyecto:/app mi-app

# Ejemplo real - desarrollo
docker run -v $(pwd)/app:/app \
           -v $(pwd)/config:/config \
           -p 3000:3000 \
           mi-app:dev
```

## ⚠️ Consideraciones al usar Bind Mounts

- **Acoplamiento fuerte** con el host
- **Problemas de portabilidad**
- **Permisos** del sistema de archivos

Sin embargo, es una excelente herramienta para **desarrollo**, **pruebas** y **entornos simples** que realizan tareas especiales.

---

## Demo Práctica: Bind Mount para Desarrollo

```bash
# Estructura de proyecto
mi-proyecto/
├── src/
│   └── app.js
├── package.json
└── Dockerfile

# Ejecutar con bind mount para desarrollo
docker run -it --rm \
  -v $(pwd)/src:/app/src \
  -v $(pwd)/package.json:/app/package.json \
  -p 3000:3000 \
  mi-app:dev

# ¡Los cambios en src/ se reflejan inmediatamente!
```

**Ventaja:** No necesitas reconstruir la imagen para cada cambio de código.

---

## tmpfs: Almacenamiento en memoria

**¿Qué son?**

- Sistema de archivos temporal en memoria RAM
- Extremadamente rápido
- Se pierde al reiniciar el contenedor

### ¿Cuándo usar tmpfs?

- **Datos temporales** sensibles
- **Caché** de alta velocidad
- **Archivos** que no deben persistir
- **Procesamiento** en memoria

## tmpfs: Almacenamiento en memoria 2

```{mermaid}
graph LR
    A[Memoria RAM] --> B[tmpfs mount]
    B --> C[Contenedor]
    
    style A fill:#fce4ec
```

```bash
# Sintaxis
docker run --tmpfs /ruta/en/contenedor mi-app

# Con opciones específicas
docker run --tmpfs /app/cache:size=100m,mode=1777 mi-app
```

## tmpfs: Almacenamiento en memoria 3

### Características:
- 🚀 **Ultra rápido** (en RAM)
- 🔒 **Seguro** (se borra al detener)
- 💾 **Limitado** por memoria disponible

### Ejemplo práctico:
```bash
# Aplicación con caché temporal
docker run -d \
  --tmpfs /tmp/cache:size=512m \
  --name api-cache \
  mi-api:latest
```


---

## Comparación: ¿Cuándo usar cada uno?

| Tipo | Persistencia | Rendimiento | Caso principal |
|------|--------------|-------------|----------------|
| **Volumes** | ✅ Sí | Alto | Producción, bases de datos |
| **Bind Mounts** | ✅ Sí | Medio | Desarrollo, configuraciones |
| **tmpfs** | ❌ No | Muy alto | Datos temporales sensibles |

> 🧩 **Regla mental**:  

> - **Producción → Volume**  
> - **Desarrollo → Bind Mount**

---

## ¿Por qué necesitamos redes en Docker?


**Problema inicial:**

- Los contenedores están aislados
- No pueden comunicarse entre sí por defecto
- No son accesibles desde el exterior

::: {.columns}
::: {.column width="50%"}

**Necesitamos:**

- Comunicación entre contenedores
- Exponer servicios al mundo exterior
- Aislamiento de redes diferentes

:::
::: {.column width="50%"}

```{mermaid}
graph TB
    A[🌐 Internet] --> B[¿Cómo llego?]
    C[Contenedor Web] --> D[Contenedor DB]
    D --> C
    
    style B fill:#ffcdd2
```

:::
:::

---

## Arquitectura de red por defecto

```{mermaid}
graph TB
    A[Host Machine] --> B[Docker Engine]
    B --> C[Docker Daemon]
    
    C --> D[docker0 Bridge]
    D --> E[Contenedor A<br/>172.17.0.2]
    D --> F[Contenedor B<br/>172.17.0.3]
    D --> G[Contenedor C<br/>172.17.0.4]
    
    A --> H[eth0: 192.168.1.100]
    
    style D fill:#e8f5e8
```

**Bridge por defecto:** Todos los contenedores conectados automáticamente


---

## Tipos de redes en Docker

```{mermaid}
graph TB
    A[Tipos de Red] --> B[Bridge]
    A --> C[Host]
    A --> D[None]
    A --> E[Overlay]
    
    B --> F[Aislamiento por defecto]
    C --> G[Comparte red del host]
    D --> H[Sin red]
    E --> I[Multi-host]
    
    style B fill:#bbdefb
```

---

## Bridge Network: El más común

**Características:**

- Red privada interna a Docker
- NAT para comunicación externa
- DNS automático entre contenedores
- Aislamiento por defecto

**Como un router virtual:**

- Cada contenedor tiene IP única
- Pueden comunicarse entre sí
- Salida al exterior mediante NAT

## Bridge Network: El más común 2

Cuando corres un contenedor sin red personalizada:

```bash
docker run -d nginx
```

- Se conecta a la red `bridge` predeterminada.
- Tiene una IP interna (ej: `172.17.0.2`).
- **No puede acceder a otros contenedores por nombre** → solo por IP (¡y las IPs cambian!).

> ❌ **No recomendado para apps multi-contenedor**.

## Bridge Network: El más común 3

```{mermaid}
graph TB
    A[Bridge Network] --> B[Contenedor Web:80]
    A --> C[Contenedor DB:3306]
    A --> D[Contenedor Cache:6379]
    
    B --> E[📡 Puerto 8080 expuesto]
    E --> F[🌐 Internet]
    
    style A fill:#e3f2fd
```

---

## Host Network: Máximo rendimiento

**Características:**

- El contenedor usa la red del host directamente
- Sin aislamiento de red
- Máximo rendimiento (sin NAT)

**Casos de uso:**

- Alto rendimiento necesario
- Cuando necesitas usar puertos del host directamente
- Aplicaciones que manejan su propio aislamiento


```{mermaid}
graph LR
    A[Contenedor] --> B[eth0 del Host]
    B --> C[🌐 Internet]
    
    style A fill:#f3e5f5
```

**⚠️ Precaución:** Menos seguridad - el contenedor ve toda la red del host

## Comunicación entre contenedores

**Problema tradicional:**

- ¿Cómo encuentra un contenedor a otro?
- Las IPs cambian
- Configuración manual complicada

**Solución Docker:**

- DNS automático
- Nombres de contenedor como hostname
- Redes personalizadas


```{mermaid}
graph LR
    A[webapp] --> B[Resuelve: database]
    B --> C[DNS Docker]
    C --> D[172.17.0.3]
    D --> E[contenedor-db]
    
    style C fill:#fff9c4
```

---

## Escenario práctico: Aplicación web + Base de datos

```{mermaid}
graph TB
    A[Usuario] --> B[Puerto 80:8080]
    B --> C[Contenedor Web]
    C --> D[Red personalizada: app-network]
    D --> E[Contenedor Database]
    
    F[Volume DB] --> E
    G[Bind Mount<br/>código fuente] --> C
    
    style D fill:#c8e6c9
    style F fill:#e1f5fe
    style G fill:#fff3e0
```

---

## Patrones comunes de comunicación

**1. Web → API → Database**

```{mermaid}
graph LR
    A[Frontend] --> B[Backend API]
    B --> C[Database]
```

**2. Microservicios**

```{mermaid}
graph TB
    A[API Gateway] --> B[Servicio Users]
    A --> C[Servicio Orders]
    A --> D[Servicio Payments]
```

## Patrones comunes de comunicación 2

**3. Publicación de puertos**

- Exponer servicios específicos
- Mapeo puerto contenedor → puerto host

**4. Comunicación entre hosts**

- Docker Swarm mode
- Overlay networks

---

## Buenas prácticas de redes

**Seguridad:**

- Usa redes personalizadas para aislar grupos de contenedores
- No uses la red "host" a menos que sea necesario
- Limita la exposición de puertos

**Organización:**

- Una red por aplicación/microservicio
- Nombres descriptivos para redes
- Documenta las dependencias entre servicios

---

## Resumen: Almacenamiento

| Concepto | Propósito | Cuándo usar |
|----------|-----------|-------------|
| **Volumes** | Persistencia gestionada | Producción, datos críticos |
| **Bind Mounts** | Desarrollo, configuración | Desarrollo, configs específicas |
| **tmpfs** | Datos temporales | Cachés, datos sensibles |

---

## Resumen: Redes

| Tipo de Red | Aislamiento | Caso de uso |
|-------------|-------------|-------------|
| **Bridge** | Aislamiento por defecto | La mayoría de casos |
| **Host** | Sin aislamiento | Alto rendimiento |
| **None** | Completo | Contenedores sin red |
| **Overlay** | Multi-host | Docker Swarm, clusters |

---

## Patrón final: Aplicación completa

```{mermaid}
graph TB
    A[🌐 Internet] --> B[Load Balancer]
    B --> C[Web Server 1]
    B --> D[Web Server 2]
    
    C --> E[App Network]
    D --> E
    E --> F[Database]
    E --> G[Cache]
    E --> H[Message Queue]
    
    I[Volume DB] --> F
    J[Volume Queue] --> H
    
    style E fill:#f3e5f5
```

---

## Creando una red personalizada

```bash
docker network create mi-red
```

Luego, al crear contenedores:

```bash
docker run -d --network=mi-red --name=db mysql
docker run -d --network=mi-red --name=web nginx
```

Ahora, desde `web`, puedes hacer:

```bash
ping db  # ¡Funciona!
```

> ✨ **Docker resuelve `db` → IP automáticamente. ¡Magia de DNS!**

## Compartiendo datos entre contenedores

¿Y si dos contenedores necesitan los **mismos archivos**?

### Opción 1: Usar un **volúmen compartido**

```{mermaid}
graph LR
  Volume[(datos-compartidos)] --> Contenedor1
  Volume --> Contenedor2
```

Ambos montan el mismo volúmen → ven los mismos archivos.

### Opción 2: Usar un **contenedor de datos** (menos común hoy)

> 💡 **El volúmen compartido es la forma moderna y limpia.**

---

## Buenas prácticas que debes recordar

✅ **Usa volúmenes para datos persistentes en producción**  
✅ **Crea redes personalizadas para grupos de contenedores**  
✅ **Nunca almacenes datos críticos en el filesystem del contenedor**  
✅ **Nombra tus contenedores y redes para hacer todo más legible**

> 🧩 **Docker no es solo "correr una imagen". Es orquestar un ecosistema.**

---

## Formatos de publicación de puertos

| Sintaxis               | Significado                          |
|------------------------|--------------------------------------|
| `-p 8080:80`           | Host:8080 → Contenedor:80            |
| `-p 80`                | Puerto aleatorio en host → 80        |
| `-p 127.0.0.1:8080:80` | Solo accesible desde localhost       |

> 🔒 **Buena práctica**:

> Usa `-p 127.0.0.1:PUERTO:PUERTO` en desarrollo → evita exposición accidental en redes públicas.

---

## ¿Qué NO hacer con puertos?

| ❌ Mal                          | ✅ Bien                          |
|----------------------------------|----------------------------------|
| Publicar todos los puertos       | Solo los necesarios              |
| Usar `-p 0.0.0.0:8080:80` en servidores públicos sin firewall | Restringir a localhost o usar proxy inverso |
| Asumir que el puerto del contenedor es accesible sin `-p` | Siempre publicar explícitamente |

> ⚠️ **Publicar un puerto ≠ exponerlo a internet**…  
> pero **sí lo expone en la máquina host** → ¡cuidado con firewalls y redes!

---

## Resumen visual {.smaller}

::: {.columns}
::: {.column width="40%"}

```{mermaid}
graph TB
  Host -->|Bind Mount| Container1
```

```{mermaid}
graph TB
  DockerEngine -->|Volume| Container2
  DockerEngine -->|Volume| Container3
  Network[(mi-red)] --> Container2
  Network --> Container3
  Container2 <-->|"Se comunican
  por nombre"| Container3
```

:::
::: {.column width="60%"}

### 1. **Persistencia**

- Usa **Volumes** para datos en producción  
- Usa **Bind Mounts** solo para desarrollo

### 2. **Redes**

- **Nunca** uses la red `bridge` por defecto para apps multi-contenedor  
- **Siempre** crea una red personalizada → comunicación por nombre

### 3. **Puertos**

- **Publica solo lo necesario**  
- **Restringe a localhost** en entornos de desarrollo

> 🌟 **Con esto, ya puedes construir apps reales en Docker**.

:::
:::

---

## ¿Qué sigue?

Ahora que entiendes los **conceptos**,  
¡estarás listo para el laboratorio práctico!

> 🚀 **Recuerda**:  

> - Los datos viven en **volúmenes**  
> - Los contenedores se hablan en **redes**  
> - Tú eres el arquitecto de este mundo efímero... ¡pero con memoria!


## ¡Preparados para el laboratorio!

**Lo que hemos cubierto:**

- Fundamentos de almacenamiento persistente
- Tipos de volúmenes y cuándo usar cada uno
- Arquitectura de redes en Docker
- Comunicación entre contenedores
- Patrones comunes y mejores prácticas

**Próximamente:** ¡Manos a la obra con ejercicios prácticos!
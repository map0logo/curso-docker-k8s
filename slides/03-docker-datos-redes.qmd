---
title: Almacenamiento y Redes en Docker
subtitle: Almacenamiento persistente y comunicaciÃ³n entre contenedores
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
---

# Almacenamiento y Redes en Docker
## Almacenamiento persistente y comunicaciÃ³n entre contenedores

---

## Â¿Por quÃ© nos importa el almacenamiento?

::: {.columns}
::: {.column width="50%"}
**Problema:** Los contenedores son efÃ­meros

- Por diseÃ±o, los contenedores son temporales
- Cuando un contenedor se elimina, TODO su contenido desaparece
- Â¡Incluyendo bases de datos, archivos de configuraciÃ³n, logs!

:::

::: {.column width="50%"}
```mermaid
graph TD
    A[Contenedor MySQL] --> B[Datos en capa escribible]
    B --> C[Â¡Contenedor eliminado!]
    C --> D[ğŸ’¥ Datos perdidos]
```
:::
:::

- Todo lo que guardas dentro del contenedor **desaparece** al detenerlo.
- Â¡Imagina perder la base de datos cada vez que reinicias tu app!

> ğŸ¤¯ **Â¡No! Necesitamos un lugar donde los datos vivan mÃ¡s allÃ¡ del contenedor.**


**SoluciÃ³n:** Necesitamos almacenamiento PERSISTENTE


> ğŸ’¡ **Â¡Tu aplicaciÃ³n no es solo cÃ³digo! Es cÃ³digo + datos + comunicaciÃ³n.**

---

## SoluciÃ³n: Almacenamiento persistente

### Â¿Por quÃ© los datos desaparecen?

Cuando un contenedor se elimina, **todo su sistema de archivos se destruye**.  
Esto incluye:

- Archivos creados durante la ejecuciÃ³n  
- Bases de datos  
- Logs  
- Configuraciones generadas

> ğŸ§  **Los contenedores son efÃ­meros por diseÃ±o** â†’ pero **tus datos no deberÃ­an serlo**.

> ğŸ’¡ **Regla de oro**:  
> **Nunca almacenes datos importantes dentro del contenedor sin persistencia externa.**

---


## Docker ofrece **tres formas principales** de guardar datos fuera del contenedor:

1. **Bind mounts**  
   â†’ Monta un directorio o archivo del **host** dentro del contenedor.

2. **Volumes**  
   â†’ Almacenamiento gestionado por Docker (recomendado para producciÃ³n).

3. **tmpfs mounts**  
   â†’ Almacenamiento en memoria (no persistente, Ãºtil para datos temporales).

ğŸ§  **Piensa en ello como elegir entre:**

- Guardar en tu casa (bind mount)
- Guardar en una caja fuerte del banco (volume)
- Guardar en una pizarra (tmpfs)

---

## El sistema de archivos de Docker

::: {.columns}
::: {.column width="60%"}
```mermaid
graph TB
    A[Imagen Base] --> B[Capa 1: SO]
    A --> C[Capa 2: AplicaciÃ³n]
    A --> D[Capa 3: ConfiguraciÃ³n]
    
    B --> E[Contenedor]
    C --> E
    D --> E
    
    E --> F[Capa escribible<br/>Union File System]
    
    style F fill:#e1f5fe
```
:::

::: {.column width="40%"}
**Concepto clave:** Capas superpuestas
- **Capas de solo lectura:** Provenientes de la imagen
- **Capa escribible:** Ãšnica por contenedor
- **Union File System:** Combina todas las capas
:::
:::

---

## Tipos de almacenamiento en Docker

```mermaid
graph LR
    A[Almacenamiento Docker] --> B[Bind Mounts]
    A --> C[Volumes]
    A --> D[tmpfs mounts]
    
    B --> E[Host directamente]
    C --> F[Gestionado por Docker]
    D --> G[Memoria RAM]
    
    style C fill:#c8e6c9
```

---

## Volumes: La opciÃ³n recomendada

::: {.columns}
::: {.column width="50%"}
**Â¿QuÃ© son?**
Un **Volume** es un directorio **gestionado por Docker** fuera del ciclo de vida del contenedor.

- Almacenado en `/var/lib/docker/volumes/` (en Linux)
- Sobrevive a la eliminaciÃ³n del contenedor
- Funciona en todos los sistemas operativos (incluyendo Docker Desktop)
- Compatible con clusters (Swarm, Kubernetes)

**Ventajas:**
- Aislamiento del sistema de archivos del host  
- FÃ¡cil de respaldar (`docker run --rm -v mi-volumen:/datos alpine tar czf - -C /datos .`)  
- Seguro y portable
- Gestionados mediante CLI de Docker
- Mejor rendimiento en algunos sistemas
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[Contenedor A] --> C[Volume MySQL]
    B[Contenedor B] --> C
    D[Contenedor C] --> C
    
    C --> E[Persiste entre contenedores]
    E --> F[Sobrevive a reinicios]
```

```mermaid
graph LR
  Container["Contenedor"] -->|escribe| Volume["Docker Volume"]
  Volume -->|persiste| Disco["Disco del Host"]
  style Volume fill:#4CAF50,stroke:#388E3C,color:white

:::
:::

---

## GestiÃ³n de Volumes

### Comandos esenciales

```bash
# Crear un volume
docker volume create mi-db-data

# Listar volumes
docker volume ls

# Inspeccionar un volume
docker volume inspect mi-db-data

# Eliminar un volume (Â¡solo si no estÃ¡ en uso!)
docker volume rm mi-db-data
```

> ğŸ” **Docker asigna un nombre Ãºnico si no lo especificas**,  
> pero **Â¡siempre nombra tus volumes!** â†’ facilita la gestiÃ³n y el debugging.

---

## Bind Mounts: ConexiÃ³n directa

::: {.columns}
::: {.column width="50%"}
**Â¿QuÃ© son?**
- Montaje de un directorio especÃ­fico del host
- El contenedor accede directamente al filesystem del host
- Mapea un **directorio o archivo especÃ­fico del host** directamente al contenedor.

**Casos de uso:**
- Desarrollo (cÃ³digo fuente)
- Configuraciones especÃ­ficas del host
- Cuando necesitas control total
:::

::: {.column width="50%"}
```mermaid
graph LR
    A[/home/usuario/proyecto] --> B[Contenedor App]
    C[/etc/config] --> B
    
    style A fill:#fff3e0
    style C fill:#fff3e0
```

```mermaid
graph LR
  HostDir["/home/usuario/proyecto"] -->|montado en| Container["/app"]
  Container --> App["App ve los archivos en tiempo real"]
```

:::
:::

**ğŸ“Œ Ideal para desarrollo**, cuando quieres editar archivos en tiempo real.

**âš ï¸ PrecauciÃ³n:**

- Rutas dependen del sistema operativo del host  
- Menos portabilidad  
- Riesgo de sobrescribir archivos del host

---

## tmpfs: Almacenamiento en memoria

::: {.columns}
::: {.column width="60%"}
**Â¿QuÃ© son?**
- Sistema de archivos temporal en memoria RAM
- Extremadamente rÃ¡pido
- Se pierde al reiniciar el contenedor

**Casos de uso:**
- Archivos temporales sensibles
- CachÃ©s que no necesitan persistir
- InformaciÃ³n sensible que no debe escribirse en disco
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Memoria RAM] --> B[tmpfs mount]
    B --> C[Contenedor]
    
    style A fill:#fce4ec
```
:::
:::

---

## ComparaciÃ³n: Â¿CuÃ¡ndo usar cada uno?

| Tipo | Persistencia | Rendimiento | Caso principal |
|------|--------------|-------------|----------------|
| **Volumes** | âœ… SÃ­ | Alto | ProducciÃ³n, bases de datos |
| **Bind Mounts** | âœ… SÃ­ | Medio | Desarrollo, configuraciones |
| **tmpfs** | âŒ No | Muy alto | Datos temporales sensibles |

> ğŸ§© **Regla mental**:  
> - **ProducciÃ³n â†’ Volume**  
> - **Desarrollo â†’ Bind Mount**

---

## Â¿Por quÃ© necesitamos redes en Docker?

::: {.columns}
::: {.column width="50%"}
**Problema inicial:**
- Los contenedores estÃ¡n aislados
- No pueden comunicarse entre sÃ­ por defecto
- No son accesibles desde el exterior

**Necesitamos:**
- ComunicaciÃ³n entre contenedores
- Exponer servicios al mundo exterior
- Aislamiento de redes diferentes
:::

::: {.column width="50%"}
```mermaid
graph LR
    A[ğŸŒ Internet] --> B[Â¿CÃ³mo llego?]
    C[Contenedor Web] --> D[Contenedor DB]
    D --> C
    
    style B fill:#ffcdd2
```
:::
:::

---

## Arquitectura de red por defecto

```mermaid
graph TB
    A[Host Machine] --> B[Docker Engine]
    B --> C[Docker Daemon]
    
    C --> D[docker0 Bridge]
    D --> E[Contenedor A<br/>172.17.0.2]
    D --> F[Contenedor B<br/>172.17.0.3]
    D --> G[Contenedor C<br/>172.17.0.4]
    
    A --> H[eth0: 192.168.1.100]
    
    style D fill:#e8f5e8
```

**Bridge por defecto:** Todos los contenedores conectados automÃ¡ticamente



---

## Tipos de redes en Docker

```mermaid
graph TB
    A[Tipos de Red] --> B[Bridge]
    A --> C[Host]
    A --> D[None]
    A --> E[Overlay]
    
    B --> F[Aislamiento por defecto]
    C --> G[Comparte red del host]
    D --> H[Sin red]
    E --> I[Multi-host]
    
    style B fill:#bbdefb
```

---

## Bridge Network: El mÃ¡s comÃºn

::: {.columns}
::: {.column width="50%"}
**CaracterÃ­sticas:**
- Red privada interna a Docker
- NAT para comunicaciÃ³n externa
- DNS automÃ¡tico entre contenedores
- Aislamiento por defecto

**Como un router virtual:**
- Cada contenedor tiene IP Ãºnica
- Pueden comunicarse entre sÃ­
- Salida al exterior mediante NAT

Cuando corres un contenedor sin red personalizada:

```bash
docker run -d nginx
```

- Se conecta a la red `bridge` predeterminada.
- Tiene una IP interna (ej: `172.17.0.2`).
- **No puede acceder a otros contenedores por nombre** â†’ solo por IP (Â¡y las IPs cambian!).

> âŒ **No recomendado para apps multi-contenedor**.

:::

::: {.column width="50%"}
```mermaid
graph TB
    A[Bridge Network] --> B[Contenedor Web:80]
    A --> C[Contenedor DB:3306]
    A --> D[Contenedor Cache:6379]
    
    B --> E[ğŸ“¡ Puerto 8080 expuesto]
    E --> F[ğŸŒ Internet]
    
    style A fill:#e3f2fd
```
:::
:::

---

## Host Network: MÃ¡ximo rendimiento

::: {.columns}
::: {.column width="50%"}
**CaracterÃ­sticas:**
- El contenedor usa la red del host directamente
- Sin aislamiento de red
- MÃ¡ximo rendimiento (sin NAT)

**Casos de uso:**
- Alto rendimiento necesario
- Cuando necesitas usar puertos del host directamente
- Aplicaciones que manejan su propio aislamiento
:::

::: {.column width="50%"}
```mermaid
graph LR
    A[Contenedor] --> B[eth0 del Host]
    B --> C[ğŸŒ Internet]
    
    style A fill:#f3e5f5
```
:::
:::

**âš ï¸ PrecauciÃ³n:** Menos seguridad - el contenedor ve toda la red del host

---

## ComunicaciÃ³n entre contenedores

::: {.columns}
::: {.column width="50%"}
**Problema tradicional:**
- Â¿CÃ³mo encuentra un contenedor a otro?
- Las IPs cambian
- ConfiguraciÃ³n manual complicada

**SoluciÃ³n Docker:**
- DNS automÃ¡tico
- Nombres de contenedor como hostname
- Redes personalizadas
:::

::: {.column width="50%"}
```mermaid
graph LR
    A[webapp] --> B[Resuelve: database]
    B --> C[DNS Docker]
    C --> D[172.17.0.3]
    D --> E[contenedor-db]
    
    style C fill:#fff9c4
```
:::
:::

---

## Escenario prÃ¡ctico: AplicaciÃ³n web + Base de datos

```mermaid
graph TB
    A[Usuario] --> B[Puerto 80:8080]
    B --> C[Contenedor Web]
    C --> D[Red personalizada: app-network]
    D --> E[Contenedor Database]
    
    F[Volume DB] --> E
    G[Bind Mount<br/>cÃ³digo fuente] --> C
    
    style D fill:#c8e6c9
    style F fill:#e1f5fe
    style G fill:#fff3e0
```

---

## Patrones comunes de comunicaciÃ³n

::: {.columns}
::: {.column width="50%"}
**1. Web â†’ API â†’ Database**
```mermaid
graph LR
    A[Frontend] --> B[Backend API]
    B --> C[Database]
```
**2. Microservicios**
```mermaid
graph TB
    A[API Gateway] --> B[Servicio Users]
    A --> C[Servicio Orders]
    A --> D[Servicio Payments]
```
:::

::: {.column width="50%"}
**3. PublicaciÃ³n de puertos**
- Exponer servicios especÃ­ficos
- Mapeo puerto contenedor â†’ puerto host

**4. ComunicaciÃ³n entre hosts**
- Docker Swarm mode
- Overlay networks
:::
:::

---

## Buenas prÃ¡cticas de redes

**Seguridad:**
- Usa redes personalizadas para aislar grupos de contenedores
- No uses la red "host" a menos que sea necesario
- Limita la exposiciÃ³n de puertos

**OrganizaciÃ³n:**
- Una red por aplicaciÃ³n/microservicio
- Nombres descriptivos para redes
- Documenta las dependencias entre servicios

---

## Resumen: Almacenamiento

| Concepto | PropÃ³sito | CuÃ¡ndo usar |
|----------|-----------|-------------|
| **Volumes** | Persistencia gestionada | ProducciÃ³n, datos crÃ­ticos |
| **Bind Mounts** | Desarrollo, configuraciÃ³n | Desarrollo, configs especÃ­ficas |
| **tmpfs** | Datos temporales | CachÃ©s, datos sensibles |

---

## Resumen: Redes

| Tipo de Red | Aislamiento | Caso de uso |
|-------------|-------------|-------------|
| **Bridge** | Aislamiento por defecto | La mayorÃ­a de casos |
| **Host** | Sin aislamiento | Alto rendimiento |
| **None** | Completo | Contenedores sin red |
| **Overlay** | Multi-host | Docker Swarm, clusters |

---

## PatrÃ³n final: AplicaciÃ³n completa

```mermaid
graph TB
    A[ğŸŒ Internet] --> B[Load Balancer]
    B --> C[Web Server 1]
    B --> D[Web Server 2]
    
    C --> E[App Network]
    D --> E
    E --> F[Database]
    E --> G[Cache]
    E --> H[Message Queue]
    
    I[Volume DB] --> F
    J[Volume Queue] --> H
    
    style E fill:#f3e5f5
```

---

## Creando una red personalizada

```bash
docker network create mi-red
```

Luego, al crear contenedores:

```bash
docker run -d --network=mi-red --name=db mysql
docker run -d --network=mi-red --name=web nginx
```

Ahora, desde `web`, puedes hacer:

```bash
ping db  # Â¡Funciona!
```

> âœ¨ **Docker resuelve `db` â†’ IP automÃ¡ticamente. Â¡Magia de DNS!**

---

## Compartiendo datos entre contenedores

Â¿Y si dos contenedores necesitan los **mismos archivos**?

### OpciÃ³n 1: Usar un **volume compartido**

```mermaid
graph LR
  Volume[(datos-compartidos)] --> Contenedor1
  Volume --> Contenedor2
```

Ambos montan el mismo volumen â†’ ven los mismos archivos.

### OpciÃ³n 2: Usar un **contenedor de datos** (menos comÃºn hoy)

> ğŸ’¡ **El volumen compartido es la forma moderna y limpia.**

---

## Buenas prÃ¡cticas que debes recordar

âœ… **Usa volumes para datos persistentes en producciÃ³n**  
âœ… **Crea redes personalizadas para grupos de contenedores**  
âœ… **Nunca almacenes datos crÃ­ticos en el filesystem del contenedor**  
âœ… **Nombra tus contenedores y redes para hacer todo mÃ¡s legible**

> ğŸ§© **Docker no es solo "correr una imagen". Es orquestar un ecosistema.**

---

## Formatos de publicaciÃ³n de puertos

| Sintaxis               | Significado                          |
|------------------------|--------------------------------------|
| `-p 8080:80`           | Host:8080 â†’ Contenedor:80            |
| `-p 80`                | Puerto aleatorio en host â†’ 80        |
| `-p 127.0.0.1:8080:80` | Solo accesible desde localhost       |

> ğŸ”’ **Buena prÃ¡ctica**:  
> Usa `-p 127.0.0.1:PUERTO:PUERTO` en desarrollo â†’ evita exposiciÃ³n accidental en redes pÃºblicas.

---

## Â¿QuÃ© NO hacer con puertos?

| âŒ Mal                          | âœ… Bien                          |
|----------------------------------|----------------------------------|
| Publicar todos los puertos       | Solo los necesarios              |
| Usar `-p 0.0.0.0:8080:80` en servidores pÃºblicos sin firewall | Restringir a localhost o usar proxy inverso |
| Asumir que el puerto del contenedor es accesible sin `-p` | Siempre publicar explÃ­citamente |

> âš ï¸ **Publicar un puerto â‰  exponerlo a internet**â€¦  
> pero **sÃ­ lo expone en la mÃ¡quina host** â†’ Â¡cuidado con firewalls y redes!

---

## Resumen visual

```mermaid
graph LR
  Host -->|Bind Mount| Container1
  DockerEngine -->|Volume| Container2
  DockerEngine -->|Volume| Container3
  Network[(mi-red)] --> Container2
  Network --> Container3
  Container2 <-->|Se comunican por nombre| Container3
```

### 1. **Persistencia**
- Usa **Volumes** para datos en producciÃ³n  
- Usa **Bind Mounts** solo para desarrollo

### 2. **Redes**
- **Nunca** uses la red `bridge` por defecto para apps multi-contenedor  
- **Siempre** crea una red personalizada â†’ comunicaciÃ³n por nombre

### 3. **Puertos**
- **Publica solo lo necesario**  
- **Restringe a localhost** en entornos de desarrollo

> ğŸŒŸ **Con esto, ya puedes construir apps reales en Docker**.

---

## Â¿QuÃ© sigue?

Ahora que entiendes los **conceptos**,  
Â¡estarÃ¡s listo para el laboratorio prÃ¡ctico!

> ğŸš€ **Recuerda**:  
> - Los datos viven en **volumes**  
> - Los contenedores se hablan en **redes**  
> - TÃº eres el arquitecto de este mundo efÃ­mero... Â¡pero con memoria!


## Â¡Preparados para el laboratorio!

**Lo que hemos cubierto:**
- Fundamentos de almacenamiento persistente
- Tipos de volÃºmenes y cuÃ¡ndo usar cada uno
- Arquitectura de redes en Docker
- ComunicaciÃ³n entre contenedores
- Patrones comunes y mejores prÃ¡cticas

**PrÃ³ximamente:** Â¡Manos a la obra con ejercicios prÃ¡cticos!
---
title: Fundamentos de Docker
subtitle: GestiÃ³n BÃ¡sica de Contenedores
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
lightbox: true

---

# MÃ³dulo 1: IntroducciÃ³n a Docker

## Â¿QuÃ© es Docker? (Y por quÃ© deberÃ­as dejar de sufrir)

- Imagina que tienes una app genial... pero solo funciona *en tu mÃ¡quina*.
- Le dices a un colega: â€œÂ¡ClÃ³nalo y ejecÃºtalo!â€... y te responde: â€œNo funciona ğŸ˜­â€.
- Â¿Por quÃ©? Porque **dependencias, versiones, librerÃ­as, SO, etc.** estÃ¡n diferentes.

ğŸ¯ Docker resuelve esto: **empaqueta tu app + todo lo que necesita** en un contenedor que funciona *igual en cualquier lado*.


## Â¿QuÃ© problema resuelve?

### El problema del "en mi mÃ¡quina funciona"

:::: {.columns}
::: {.column}
**Expectativa**

```{mermaid}
graph TD
    A[Desarrollador] --> B[CÃ³digo que funciona]
    B --> C[Entorno de desarrollo]
    C --> D[Â¡Funciona!]
```
:::

::: {.column}
**Realidad**

- Diferentes sistemas operativos
- Diferentes versiones de librerÃ­as
- Configuraciones inconsistentes
- Dependencias conflictivas

```{mermaid}
graph TD
    E[Dev 1: Ubuntu] --> F[Versiones <br> Configuraciones <br> Dependencias <br> ğŸ¤¦â€â™‚ï¸ğŸ˜]
    G[Dev 2: Windows] --> F
    H[ProducciÃ³n: CentOS] --> F
```
:::

:::


## Contenedor: definiciÃ³n tÃ©cnica

**Un contenedor Docker es una instancia ejecutable de una imagen Docker**

Piensa en esta relaciÃ³n:

```{mermaid}
graph LR
    A[Clase en POO] --> B[Imagen Docker]
    C[Objeto instanciado] --> D[Contenedor Docker]
    
    B --> E[Plantilla estÃ¡tica]
    D --> F[EjecuciÃ³n dinÃ¡mica]
```

## La soluciÃ³n: Docker al rescate

**Docker es una plataforma para desarrollar, enviar y ejecutar aplicaciones en contenedores**

Piensa en los contenedores como...

- **CÃ¡psulas** que empaquetan tu aplicaciÃ³n
- **CÃ¡psulas del tiempo** que preservan el entorno
- **CÃ¡psulas espaciales** que funcionan en cualquier lugar


## Â¿QuÃ© contiene realmente un contenedor?

### El "paquete completo" de tu aplicaciÃ³n

```{mermaid}
graph TB
    A[Contenedor Docker] --> B[CÃ³digo de la aplicaciÃ³n]
    A --> C[Dependencias y librerÃ­as]
    A --> D[Archivos de configuraciÃ³n]
    A --> E[Variables de entorno]
    A --> F[Runtime especÃ­fico]
```

```{mermaid}   
graph TB 
    G[Sistema de archivos] --> H[Capa de escritura]
    I[Red] --> J[Network namespace]
    K[Procesos] --> L[Aislamiento de procesos]
```

## MÃ¡quinas Virtuales vs. Contenedores

### La vieja escuela: MÃ¡quinas Virtuales

```{mermaid}
graph TB
    A[AplicaciÃ³n 1] --> B[Sistema Operativo Invitado 1]
    C[AplicaciÃ³n 2] --> D[Sistema Operativo Invitado 2]
    E[AplicaciÃ³n 3] --> F[Sistema Operativo Invitado 3]
    
    B --> G[Hypervisor]
    D --> G
    F --> G
    G --> H[Sistema Operativo AnfitriÃ³n]
    H --> I[Hardware]
```

## CaracterÃ­sticas de las VMs:

- âœ… Aislamiento completo
- âœ… Compatibilidad total
- âŒ Mucho consumo de recursos
- âŒ Tiempos de inicio lentos
- âŒ Gran overhead

## La nueva era: Contenedores

```{mermaid}
graph TB
    A[AplicaciÃ³n 1] --> B[Bins/Libs]
    C[AplicaciÃ³n 2] --> D[Bins/Libs]
    E[AplicaciÃ³n 3] --> F[Bins/Libs]
    
    B --> G[Docker Engine]
    D --> G
    F --> G
    G --> H[Sistema Operativo AnfitriÃ³n]
    H --> I[Hardware]
```
# CaracterÃ­sticas clave de los contenedores

## 1. Aislamiento ligero

**No es una mÃ¡quina virtual completa**, pero sÃ­ tiene:

- âœ… **Namespaces:** Aislamiento de procesos, red, archivos
- âœ… **Control groups:** LÃ­mites de recursos (CPU, memoria)
- âœ… **Sistema de archivos:** Capa de escritura propia

## 2. Eficiencia de recursos

**Comparte el kernel del sistema operativo anfitriÃ³n**

```{mermaid}
graph TD
    A[App Node.js] --> B[Contenedor 1]
    C[App Python] --> D[Contenedor 2]
    E[Base de datos] --> F[Contenedor 3]
    
    B --> G[Kernel Linux]
    D --> G
    F --> G
    G --> H[Hardware]
```

## 3. Portabilidad total

**"Write once, run anywhere"**

- âœ… Mismo contenedor en desarrollo
- âœ… Mismo contenedor en testing  
- âœ… Mismo contenedor en producciÃ³n

## El ciclo de vida de un contenedor

```{mermaid}
graph LR
    A[Imagen] --> B[Created]
    B --> C[Running]
    C --> D[Paused]
    D --> C
    C --> E[Stopped]
    E --> C
    E --> F[Deleted]
```
### Estados de un contenedor:

1. **Created:** Configurado pero no ejecutÃ¡ndose
2. **Running:** En ejecuciÃ³n activa
3. **Paused:** EjecuciÃ³n suspendida temporalmente
4. **Stopped:** Proceso terminado pero configuraciÃ³n guardada
5. **Deleted:** Eliminado completamente

---

## ComparaciÃ³n directa: VM vs Contenedor

### AnalogÃ­a del edificio

**MÃ¡quina Virtual = Casa independiente**

- Tiene sus propios cimientos (SO completo)
- Muy segura pero costosa de construir
- Mucho espacio "desperdiciado"

**Contenedor = Apartamento**

- Comparte cimientos con otros (SO anfitriÃ³n)
- Eficiente en espacio y recursos
- Aislado pero compartiendo infraestructura

## Tabla comparativa

| Aspecto | MÃ¡quina Virtual | Contenedor |
|---------|----------------|------------|
| TamaÃ±o | GBs | MBs |
| Tiempo de inicio | Minutos | Segundos |
| Rendimiento | 10-20% overhead | Casi nativo |
| Aislamiento | Fuerte | Ligero |
| Portabilidad | Limitada | Excelente |

---

## Arquitectura de Docker

### Los tres pilares fundamentales

1. **Cliente Docker**:

2. **Docker Daemon**:

3. **Registros (Docker Hub, Docker Registry)**:

```{mermaid}
graph LR
    A[ **Cliente Docker**] -->|ordena| B[**Demonio Docker**]
    B -->|guarda/lee| C[**Registro Docker**]
    C -->|descarga imÃ¡genes| B
    B -->|crea contenedores| D[**OS anfitriÃ³n**]

    style A fill:#ffe599,stroke:#333
    style B fill:#b4a7d6,stroke:#333
    style C fill:#9fc5e8,stroke:#333
    style D fill:#d9ead3,stroke:#333
```

## 1. Cliente Docker - Tu interfaz de comunicaciÃ³n

**Â¿QuÃ© es?** La herramienta de lÃ­nea de comandos (`docker`) que usas para hablar con Docker

**Funciones principales:**

- Recibe tus comandos (`docker run`, `docker build`)
- Se comunica con el Daemon
- Te muestra los resultados

```bash
# TÃº escribes esto:
docker run hello-world

# El cliente lo envÃ­a al daemon
# El daemon lo ejecuta
# El cliente te muestra el resultado
```

## 2. Docker Daemon - El cerebro operativo

**Â¿QuÃ© es?** El servicio que corre en segundo plano gestionando todo

**Responsabilidades:**

- ğŸ—ï¸ Construir imÃ¡genes
- ğŸš€ Ejecutar contenedores
- ğŸ’¾ Gestionar almacenamiento
- ğŸŒ Manejar redes
- ğŸ“¦ Administrar volÃºmenes

**Dato curioso:** El daemon es quien realmente hace el trabajo pesado

## 3. Registros Docker - La biblioteca de imÃ¡genes

**Â¿QuÃ© es?** Donde se almacenan y comparten las imÃ¡genes de Docker

**El registro mÃ¡s famoso:** Docker Hub (como GitHub para cÃ³digo)

**Tipos de registros:**

- **PÃºblicos:** Docker Hub (oficiales y de la comunidad)
- **Privados:** Registros empresariales
- **Locales:** Tu propia mÃ¡quina

---

## El flujo fundamental: Build, Share, Run

### El ciclo de vida de una aplicaciÃ³n Dockerizada

```{mermaid}
graph LR
    A[Dockerfile] --> B[**Build**]
    B --> C[Imagen]
    C --> D[**Share**]
    D --> E[Registro]
    E --> F[**Run**]
    F --> G[Contenedor]
```

### **1. Build (Construir)**
- Crear una **imagen** de Docker a partir de un archivo `Dockerfile`.

### **2. Share (Compartir)**
- Subir la imagen a un **registro** (Docker Hub, GitLab Container Registry, etc.).

### **3. Run (Ejecutar)**
- Descargar la imagen y ejecutar su contenedor en cualquier mÃ¡quina con Docker.

---

## Paso 1: BUILD - Crear la imagen

**Â¿QuÃ© es una imagen?** 

- Plantilla de solo lectura con instrucciones
- Como una clase en programaciÃ³n orientada a objetos
- Contiene todo lo necesario para ejecutar la aplicaciÃ³n

**Â¿CÃ³mo se crea?** Con un **Dockerfile**:

```dockerfile
  FROM ubuntu:22.04
  RUN apt-get update && apt-get install -y python3
  COPY app.py /app/
  CMD ["python3", "/app/app.py"]
```

## Proceso de build

1. Descarga imagen base
2. Ejecuta cada instrucciÃ³n
3. Crea capas (layers) por cada instrucciÃ³n
4. Genera la imagen final

## Paso 2: SHARE - Distribuir la imagen

**Â¿Por quÃ© compartir?**

- Para que otros desarrolladores usen tu imagen
- Para desplegar en diferentes entornos
- Para colaborar en equipo

**Comandos clave:**

```bash
docker push mi-imagen:versiÃ³n    # Subir al registro
docker pull mi-imagen:versiÃ³n    # Descargar del registro
```

## Beneficios

- âœ… Consistencia garantizada
- âœ… Versionado claro
- âœ… FÃ¡cil rollback

## Paso 3: RUN - Ejecutar el contenedor

**Â¿QuÃ© es un contenedor?**

- Instancia ejecutable de una imagen
- Como un objeto creado desde una clase
- Aislado pero eficiente

**El comando mÃ¡gico:**

```bash
docker run -d -p 80:80 mi-imagen:versiÃ³n
```

## QuÃ© pasa cuando ejecutas `docker run`

1. âœ… Busca la imagen localmente
2. âœ… Si no existe, la descarga del registro
3. âœ… Crea un sistema de archivos writable
4. âœ… Configura la red isolation
5. âœ… Ejecuta el proceso especificado

---

## Resumen conceptual {.smaller}

### La analogÃ­a de la pizza

**Dockerfile = Receta de la pizza**

- Instrucciones para crear la pizza
- Define ingredientes y pasos

**Imagen = Pizza congelada**

- Pizza lista pero estÃ¡tica
- Se puede compartir y almacenar

**Contenedor = Pizza caliente servida**

- Pizza en ejecuciÃ³n
- Lista para consumir

## Ventajas clave de Docker

- ğŸš€ **Consistencia:** Funciona igual en todos lados
- ğŸ“¦ **Aislamiento:** Aplicaciones no interfieren entre sÃ­
- âš¡ **Eficiencia:** MÃ¡ximo aprovechamiento de recursos
- ğŸ” **Reproducibilidad:** Mismos resultados siempre
- ğŸ“š **Ecosistema:** Herramientas y comunidad robustas

### Para operaciones:

- ğŸ”„ **Despliegues predictivos:** Siempre funciona igual  
- ğŸ“Š **MonitorizaciÃ³n:** Aislamiento facilita el monitoreo 
- ğŸ›¡ï¸ **Seguridad:** Aislamiento reduce superficie de ataque  

---

## PrÃ³ximos pasos

### Lo que viene despuÃ©s...

En los siguientes mÃ³dulos exploraremos:

- ğŸ“ Crear nuestro primer Dockerfile
- ğŸ—ï¸ Construir imÃ¡genes personalizadas
- ğŸ”— Conectar contenedores entre sÃ­
- ğŸ“Š Orquestar mÃºltiples contenedores

## Puntos clave para recordar

1. **Docker soluciona** el problema "en mi mÃ¡quina funciona"
2. **Contenedores son mÃ¡s eficientes** que mÃ¡quinas virtuales
3. **Arquitectura cliente-servidor** con tres componentes principales
4. **Flujo Build-Share-Run** para el ciclo de vida de aplicaciones
5. **ImÃ¡genes son plantillas**, contenedores son instancias ejecutando

# Â¿Preguntas?

*Â¿Alguna duda sobre los conceptos bÃ¡sicos antes de pasar a la prÃ¡ctica?*

# ğŸ³ MÃ³dulo 2: GestiÃ³n BÃ¡sica de Contenedores

## Â¡Domina los contenedores como un DJ domina sus tornamesas!

Â¡Hola de nuevo, Docker Ninja en formaciÃ³n! ğŸ¥‹  

En este mÃ³dulo no vamos a tocar cÃ³digo ni Dockerfiles. Solo vamos a **manejar contenedores vivos** como si fueran mascotas tecnolÃ³gicas: alimentarlos, revisarlos, darles Ã³rdenes... Â¡y a veces decirles adiÃ³s! ğŸ˜¢


## Â¡Imagina esto!  

> Tienes 5 contenedores corriendo. Uno se volviÃ³ loco. Otro no arranca. Otro esconde errores en sus logs. Â¿QuÃ© haces?

Â¡No entres en pÃ¡nico! Docker te da **superpoderes de control** con unos pocos comandos. Vamos a conocerlos uno por uno, con dibujos, analogÃ­as y hasta drama.


## Tu primer dÃ­a como "conductor" de contenedores

```{mermaid}
graph LR
    A[TÃº] --> B[docker run]
    B --> C[ğŸš€ Contenedor inicia]
    C --> D[docker ps]
    D --> E[ğŸ“Š Monitoreo]
    C --> F[docker exec]
    F --> G[âš¡ InteracciÃ³n]
    C --> H[docker stop]
    H --> I[ğŸ’¤ Pausa]
    I --> J[docker start]
    J --> K[ğŸ” ReactivaciÃ³n]
```

**Piensa en Docker como tu nuevo superpoder:**

- ğŸ® **Control total** sobre aplicaciones
- ğŸ” **Visibilidad completa** de lo que pasa dentro
- âš¡ **InteracciÃ³n instantÃ¡nea** cuando lo necesites

---

## Comandos Esenciales: Tu Caja de Herramientas

### El ciclo de vida bÃ¡sico de un contenedor

```{mermaid}
graph LR
    A[ğŸ¯ RUN] --> B[ğŸ‘€ PS]
    B --> C[â¸ï¸ STOP]
    C --> D[â–¶ï¸ START]
    D --> E[ğŸ—‘ï¸ RM]
    E --> A
```
- **`run`**: Crea y ejecuta un contenedor
- **`ps`**: Listar contenedores
- **`stop`**: Detener un contenedor
- **`stop`**: Iniciar un contenedor
- **`rm`**: Eliminar un contenedor

## 1. `docker run` - El Comando MÃ¡gico

### Â¡Dale vida a tus contenedores!

**Â¿QuÃ© hace?** Crea y ejecuta un nuevo contenedor desde una imagen

```bash
# La fÃ³rmula bÃ¡sica
docker run [OPCIONES] IMAGEN [COMANDO]
```
\

### Opciones mÃ¡s comunes (tus "modificadores")

| OpciÃ³n | Significado | Ejemplo |
|--------|-------------|---------|
| `-d` | Detached (en segundo plano) | `docker run -d nginx` |
| `-p` | Mapeo de puertos | `docker run -p 8080:80 nginx` |
| `--name` | Nombre personalizado | `docker run --name mi-web nginx` |
| `-it` | Interactivo con terminal | `docker run -it ubuntu bash` |

## Ejemplos prÃ¡cticos (sin ejecutar aÃºn)

**Ejemplo 1: Servidor web simple**

```bash
docker run -d -p 80:80 --name mi-servidor nginx
```
*"Ejecuta nginx en segundo plano, mapea puerto 80 y llÃ¡malo 'mi-servidor'"*

**Ejemplo 2: Terminal interactiva**

```bash
docker run -it --name mi-terminal ubuntu /bin/bash
```
*"Abre una terminal bash dentro de Ubuntu y mantÃ©n la sesiÃ³n interactiva"*

## Notas sobre `docker run`

ğŸ§  Â¡Ojo! Por defecto, el contenedor se ejecuta en **primer plano**. Para que corra en segundo plano, usa `-d` (de detached):

```{mermaid}
graph LR
    A[Imagen nginx] -->|docker run| B[Contenedor nuevo]
    B --> C[Estado: RUNNING]
    C --> D[PID asignado, puertos, filesystem...]
```

âœ… `docker run` = nacimiento de un contenedor.  
âš ï¸ Â¡Cada `run` crea un contenedor NUEVO! (No reinicia uno viejo)

## 2. `docker ps` - Tu Panel de Control

### Â¿QuÃ© estÃ¡ pasando en tu sistema Docker?

**Â¿QuÃ© hace?** Muestra **solo** los contenedores en ejecuciÃ³n

```bash
# VersiÃ³n bÃ¡sica
docker ps
```
Para ver **todos**: corriendo, detenidos, fallidos, zombies... Â¡todos!

```bash
# VersiÃ³n extendida (incluye detenidos)
docker ps -a
```
Especificar el formato de salida

```bash
# VersiÃ³n ultra-detalle
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
```

## Entendiendo la salida de `docker ps`

\

```bash
CONTAINER ID   IMAGE   COMMAND    CREATED       STATUS       PORTS                 NAMES
a1b2c3d4e5f6   nginx   "nginx..." 2 hours ago   Up 2 hours   0.0.0.0:80->80/tcp   mi-servidor
```

ğŸ“Œ Columnas clave:

- `CONTAINER ID`: El DNI del contenedor (los primeros 12 caracteres del hash).
- `IMAGE`: Â¿De quÃ© imagen naciÃ³?
- `COMMAND`: Â¿QuÃ© comando estÃ¡ ejecutando?
- `STATUS`: Â¿Running? Â¿Exited? Â¿Hace cuÃ¡nto?
- `NAMES`: Â¡Un nombre aleatorio (o el que tÃº le pusiste)!

## Tu dashboard mental

```{mermaid}
graph TB
    A[docker ps] --> B[ğŸ“Š Estado actual]
    B --> C[ğŸ†” IDs Ãºnicos]
    B --> D[â±ï¸ Tiempo ejecuciÃ³n]
    B --> E[ğŸ”— Puertos activos]
    B --> F[ğŸ·ï¸ Nombres contenedores]
```

ğŸ’¡ Tip Ninja: Usa `docker ps -a --no-trunc` para ver IDs completos. 

ğŸ’¡ Tip mÃ¡s Ninja: `docker ps -q` solo muestra los IDs. Â¡Perfecto para scripts!

---

## 3. `docker stop` & `docker start` - El Interruptor

### Controla la energÃ­a de tus contenedores

```{mermaid}
graph LR
    A[ğŸš€ Running] --> B[docker stop]
    B --> C[ğŸ’¤ Stopped]
    C --> D[docker start]
    D --> A
```

### `docker stop` - Apagado elegante

**Â¿QuÃ© hace?** Detiene un contenedor en ejecuciÃ³n de manera controlada

```bash
# Por nombre
docker stop mi-servidor

# Por ID (primeros caracteres)
docker stop a1b2c3
```

## Â¿CÃ³mo funciona el `docker stop`?

1. âœ… EnvÃ­a seÃ±al SIGTERM ("por favor, apÃ¡gate")
2. â³ Espera 10 segundos para shutdown elegante
3. ğŸš¨ Si no responde, envÃ­a SIGKILL ("apÃ¡gate ahora")


## `docker start` - ReactivaciÃ³n

**Â¿QuÃ© hace?** Reinicia un contenedor previamente detenido

```bash
docker start mi-servidor
```
\

**Ventaja clave:** Mantiene la misma configuraciÃ³n

- Â¡Revive un contenedor detenido!  
- Conserva todo su estado anterior: archivos modificados, configuraciones, logs...  
- Â¡NO crea uno nuevo! Solo reanuda el mismo.

---

## 4. `docker rm` - Limpieza Total

### Cuando necesitas borrar contenedores

> â€œCuando un contenedor ya no sirve... hay que darle un adiÃ³s digno.â€

**Â¿QuÃ© hace?** Elimina permanentemente un contenedor

```bash
# Eliminar uno especÃ­fico
docker rm mi-servidor

# Eliminar varios
docker rm cont1 cont2 cont3
```

## Eliminar TODOS los contenedores detenidos

ğŸ’¡ Â¿Quieres borrar TODOS los contenedores detenidos de una vez?

```bash
docker container prune
```

Â¡Limpieza express! ğŸ§¹

```{mermaid}
graph LR
    A[Contenedor STOPPED] -->|docker rm| B[ğŸ—‘ï¸ Eliminado del sistema]
    C[Contenedor RUNNING] -->|docker rm -f| D[â›” Detenido + Eliminado]
```

## Â¡Cuidado! Reglas importantes

```{mermaid}
graph LR
    A[Â¿Quieres eliminar?] --> B{Â¿EstÃ¡ ejecutÃ¡ndose?}
    B -->|SÃ­| C[ğŸš« Error: No se puede eliminar]
    B -->|No| D[âœ… EliminaciÃ³n exitosa]
    
    C --> E[OpciÃ³n force]
    E --> F[docker rm -f]
    F --> G[âš ï¸ EliminaciÃ³n forzada]
```

**Ejemplo seguro:**
```bash
# Primero detener, luego eliminar
docker stop mi-servidor
docker rm mi-servidor
```

## Forzar eliminaciÃ³n

```bash
# O forzar eliminaciÃ³n (no recomendado en producciÃ³n)
docker rm -f mi-servidor
```

âš ï¸ Â¡Cuidado! `docker rm` borra:

- Los cambios en el filesystem del contenedor (si no usaste volÃºmenes).
- Los logs (a menos que los hayas exportado).
- Su historial.


---

## 5. `docker logs` - Tu Ventana al Interior

### Â¿QuÃ© estÃ¡ pasando dentro del contenedor?

> â€œÂ¿QuÃ© te pasa, contenedor? Â¿Por quÃ© fallaste? Â¡HÃ¡blame! ğŸ¤â€

**Â¿QuÃ© hace?** Muestra los logs (registros) de un contenedor

```bash
# Logs bÃ¡sicos
docker logs mi-servidor

# Seguir logs en tiempo real (como tail -f)
docker logs -f mi-servidor

# Ãšltimas 10 lÃ­neas
docker logs --tail 10 mi-servidor

# Logs con timestamps
docker logs -t mi-servidor
```

## Â¿CÃ³mo funciona `docker logs`?

- Muestra la **salida estÃ¡ndar (stdout)** y **errores (stderr)** del proceso principal del contenedor.
- Â¡Incluso si el contenedor estÃ¡ detenido! Los logs persisten hasta que lo borres.

```{mermaid}
graph LR
    A[Contenedor] -->|stdout/stderr| B[Motor de logs de Docker]
    C[docker logs] -->|consulta| B
    B --> D[Te muestra lo que el contenedor 'dijo']
```

ğŸ’¡ Tip: Si tu app escribe logs a archivos (no a consola), Â¡Docker no los verÃ¡! Usa montajes de volumen o redirige a stdout.

## Casos de uso comunes de `docker logs`

**Debugging de aplicaciones:**
```bash
# Â¿Por quÃ© mi app no funciona?
docker logs mi-app

# Ver errores en tiempo real mientras testeamos
docker logs -f mi-app
```

**Monitoreo de servicios:**
```bash
# Â¿EstÃ¡ recibiendo trÃ¡fico mi web?
docker logs --since 1h nginx
```
\

### Estructura tÃ­pica de logs

```
2023-01-15T10:30:00Z Server starting on port 3000
2023-01-15T10:31:15Z Database connection established
2023-01-15T10:32:30Z User login from IP 192.168.1.100
```

---

## 6. `docker exec` - Tu Pase de Acceso

### Entra en contenedores en ejecuciÃ³n

> â€œÂ¿QuÃ© pasa dentro de ese contenedor? Â¡Voy a entrar como espÃ­a y ejecutar comandos!â€

**Â¿QuÃ© hace?** Ejecuta un comando dentro de un contenedor que ya estÃ¡ corriendo

```bash
# FÃ³rmula bÃ¡sica
docker exec [OPCIONES] CONTENEDOR COMANDO
```

## Modo interactivo

**Ejemplo 1: Shell interactivo**

```bash
docker exec -it mi-servidor /bin/bash
```
*"Abre una terminal bash dentro del contenedor 'mi-servidor'"*

### Modo no interactivo 

**Ejemplo 2: EjecuciÃ³n (no interactiva)**

```bash
docker exec mi-servidor ls -la /app
```
*"Lista archivos en /app y sale inmediatamente"*

## Casos de uso reales de `docker exec`

```{mermaid}
graph 
    A[docker exec] --> B[ğŸ”§ Debugging]
    A --> C[ğŸ“ InspecciÃ³n archivos]
    A --> D[âš™ï¸ ConfiguraciÃ³n]
    A --> E[ğŸ“Š Monitoreo]
    
    B --> F[Ver variables entorno]
    C --> G[Revisar logs aplicaciÃ³n]
    D --> H[Editar configuraciones]
    E --> I[Ver procesos internos]
```

### Ejemplos prÃ¡cticos de `docker exec`

```bash
# Ver variables de entorno
docker exec mi-app env
# Revisar uso de memoria
docker exec mi-app free -h
# Ver procesos ejecutÃ¡ndose
docker exec mi-app ps aux
# Crear archivo de configuraciÃ³n
docker exec -it mi-app vi /app/config.conf
```

---

## Flujo de Trabajo Completo

### Tu rutina diaria con contenedores

```{mermaid}
graph LR
    A[ğŸš€ docker run] --> B[ğŸ‘€ docker ps]
    B --> C[ğŸ“ docker logs]
    C --> D{Â¿Problemas?}
    D -->|SÃ­| E[âš¡ docker exec]
    D -->|No| F[â¸ï¸ docker stop]
    E --> F
    F --> G[â–¶ï¸ docker start]
    G --> H[ğŸ—‘ï¸ docker rm]
```

### Ciclo completo de una aplicaciÃ³n web

```bash
# 1. Iniciar
docker run -d -p 8080:80 --name web nginx
# 2. Verificar
docker ps
# 3. Monitorear
docker logs web
# 4. Inspeccionar
docker exec web nginx -t  # Test configuraciÃ³n
# 5. Detener
docker stop web
# 6. Eliminar
docker rm web
```

## Notas sobre `docker exec`

âš ï¸ Â¡Ojo!  

- Solo funciona en contenedores **en ejecuciÃ³n**.  
- El proceso que ejecutas (`bash`, `ls`, etc.) es **independiente** del proceso principal.  
- Si sales de `bash`, el contenedor sigue corriendo. Â¡No lo matas!

---

## Buenas PrÃ¡cticas y Consejos

### Nomenclatura Ãºtil

**Nombres descriptivos:**

- `web-frontend` en lugar de `container-1`
- `db-postgres` en lugar de `c3p0`
- `cache-redis` en lugar de `red-container`

**Tags especÃ­ficos:**

- `app:version1.2` mejor que solo `app`
- `nginx:latest` puede cambiar, `nginx:1.21` es especÃ­fico

## Seguridad bÃ¡sica

```{mermaid}
graph LR
    A[ğŸ”’ Buenas prÃ¡cticas] --> B[No usar root]
    A --> C[Limitar permisos]
    A --> D[Logs seguros]
    
    B --> E[docker exec -u usuario]
    C --> F[Sin --privileged]
    D --> G[No logs sensitivos]
```

---

## Resumen de Comandos

### Tu cheat sheet mental

| Comando | PropÃ³sito | Ejemplo |
|---------|-----------|---------|
| `docker run` | Crear y ejecutar | `docker run -d nginx` |
| `docker ps` | Listar contenedores | `docker ps -a` |
| `docker stop` | Detener contenedor | `docker stop web` |
| `docker start` | Iniciar contenedor | `docker start web` |
| `docker rm` | Eliminar contenedor | `docker rm web` |
| `docker logs` | Ver registros | `docker logs -f web` |
| `docker exec` | Ejecutar comando interno | `docker exec -it web bash` |

## Orden lÃ³gico de operaciones

1. **CREATE** â†’ `docker run`
2. **MONITOR** â†’ `docker ps`, `docker logs`  
3. **INTERACT** â†’ `docker exec`
4. **PAUSE** â†’ `docker stop`
5. **RESUME** â†’ `docker start`
6. **CLEANUP** â†’ `docker rm`

## Â¡Flujo TÃ­pico de Trabajo! (Como un ritual mÃ¡gico)

```{mermaid}
graph LR
    A[Iniciar contenedor] -->|**docker run -d**| B[Ver estado]
    B -->|**docker ps**| C[Â¿Funciona?]
    C -->|SÃ­| D[Ver logs si hay dudas]
    C -->|No| E[Revisar logs: **docker logs**]
    D --> F[Â¿Necesito entrar?]

    style A fill:#d5e8d4,stroke:#333
    style B fill:#d5e8d4,stroke:#333
    style C fill:#fff2cc,stroke:#333
    style D fill:#d5e8d4,stroke:#333
    style E fill:#f8cecc,stroke:#333
    style F fill:#fff2cc,stroke:#333
```

```{mermaid}
graph LR
    F[Â¿Necesito entrar?] -->|Si **docker exec**| I[Ejecutar comandos]
    F -->|No| H[Dejarlo correr]
    I --> J[Salir sin detenerlo]
    J --> H
    H --> K["Al terminar: **docker stop** + **docker rm**"]

    style F fill:#fff2cc,stroke:#333
    style H fill:#d5e8d4,stroke:#333
    style I fill:#d5e8d4,stroke:#333
    style J fill:#d5e8d4,stroke:#333
    style K fill:#f8cecc,stroke:#333
```

---

## Â¡Errores Comunes (y cÃ³mo no morir en el intento)!

ğŸš¨ **â€œError: No such containerâ€**
â†’ Te equivocaste en el nombre o ID. Usa `docker ps -a` para verificar.

ğŸš¨ **â€œYou cannot remove a running containerâ€**
â†’ Â¡DetÃ©nlo primero! `docker stop` â†’ luego `docker rm`.

ğŸš¨ **â€œContainer is not runningâ€ al usar `docker exec`**
â†’ Â¿EstÃ¡ detenido? InÃ­cialo con `docker start`.

ğŸš¨ **No veo nada en `docker logs`**
â†’ Â¿Tu app escribe a archivos? Redirige a stdout o usa volÃºmenes.

---

## Â¡Para cerrar con broche de oro!

> â€œGestionar contenedores no es magia. Es rutina. Como cepillarte los dientes, pero con mÃ¡s poder.â€

ğŸ” `run` â†’ `ps` â†’ `logs` â†’ `exec` â†’ `stop` â†’ `rm`  
Ese es tu ciclo. DomÃ­nalo. EnsÃ©Ã±aselo a otros. Â¡Y nunca mÃ¡s temas a un contenedor rebelde!



## Â¿Preguntas?

**Antes de pasar al laboratorio prÃ¡ctico:**

- â“ Â¿Alguna duda sobre los comandos bÃ¡sicos?
- â“ Â¿ConfusiÃ³n sobre cuÃ¡ndo usar cada comando?
- â“ Â¿Curiosidad sobre casos especÃ­ficos?

**Â¡En el siguiente mÃ³dulo veremos imÃ¡genes Docker!**
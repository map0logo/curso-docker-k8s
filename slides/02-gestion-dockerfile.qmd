---
title: Uso de Dockerfiles
subtitle: CreaciÃ³n y GestiÃ³n de ImÃ¡genes
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
lightbox: true
---

# Â¡Bienvenidos al MÃ³dulo 3: ImÃ¡genes Docker!

## Â¿QuÃ© aprenderemos hoy?

```{mermaid}
graph TD
    A[ImÃ¡genes Docker] --> B[BÃºsqueda en Docker Hub]
    A --> C[AnatomÃ­a Dockerfile]
    A --> D[RUN vs CMD vs ENTRYPOINT]
    A --> E[Mejores PrÃ¡cticas]
```

- Comprender quÃ© son las imÃ¡genes de Docker y cÃ³mo funcionan.
- Aprender a buscar, crear y optimizar imÃ¡genes.
- Conocer las mejores prÃ¡cticas para construir imÃ¡genes seguras y eficientes.

# **Nota:** 

Este mÃ³dulo es como un viaje por el corazÃ³n de Docker. Â¡PrepÃ¡rate para sumergirte en el mundo de las imÃ¡genes!


---

## Â¿QuÃ© es exactamente una imagen Docker?

### La receta de un contenedor ğŸ°

Pensemos en una imagen como...

- **Molde para galletas**: Define la forma pero no es la galleta misma
- **Receta de cocina**: Instrucciones para crear un plato especÃ­fico
- **Plantilla**: Puedes crear mÃºltiples contenedores a partir de una imagen

> **DefiniciÃ³n tÃ©cnica**: Sistema de archivos de solo lectura + metadatos

## Imagen Docker: Concepto

Plantilla inmutable que contiene todo lo necesario para ejecutar una aplicaciÃ³n:

  - CÃ³digo
  - Bibliotecas
  - Dependencias
  - Variables de entorno
  - Configuraciones

---

## BÃºsqueda de imÃ¡genes en repositorios

### Â¿QuÃ© es Docker Hub?

Es un repositorio pÃºblico donde puedes encontrar imÃ¡genes preconstruidas para casi cualquier propÃ³sito.

Ejemplos populares:

  - `nginx`: Para servidores web.
  - `postgres`: Para bases de datos.
  - `python`: Para aplicaciones en Python.

## Docker Hub: El "App Store" de Docker ğŸª

### Â¿QuÃ© tipos de imÃ¡genes puedes encontrar?

```{mermaid}
graph TB
    A[Docker Hub] --> B[ImÃ¡genes Oficiales]
    A --> C[ImÃ¡genes Verificadas]
    A --> D[ImÃ¡genes de Comunidad]
    
    B --> B1[nginx, node, python]
    C --> C1[Empresas verificadas]
    D --> D1[Desarrolladores]
```

---

## BÃºsqueda prÃ¡ctica en Docker Hub

### Comandos esenciales para explorar

```bash
# Buscar imÃ¡genes
docker search nginx

# Ver detalles de una imagen
docker inspect nginx:latest

# Descargar una imagen
docker pull nginx:alpine
```

\

### Etiquetas (tags) importantes:

- `latest` - Ãšltima versiÃ³n (Â¡cuidado en producciÃ³n!)
- `alpine` - VersiÃ³n minimalista con Alpine Linux
- Versiones especÃ­ficas: `nginx:1.21`, `node:16-alpine`

## Alternativas a Docker: El Panorama Actual

### No solo existe Docker en el mundo de los contenedores

```{mermaid}
graph TB
    A[Alternativas a Docker] --> B[Podman]
    A --> C[Containerd]
    A --> D[Kubernetes Pods]
    A --> E[LXC/LXD]
    
    B --> B1[Sin daemon, rootless]
    C --> C1[Motor subyacente]
    D --> D1[OrquestaciÃ³n nativa]
    E --> E1[Contenedores de sistema]
```

---

## Podman: El Competidor MÃ¡s Fuerte ğŸ¥Š

### Â¿Por quÃ© la gente se muda a Podman?

**Ventajas clave:**

- âœ… **Sin daemon**: No necesita proceso background siempre ejecutÃ¡ndose
- âœ… **Rootless**: Ejecuta contenedores sin privilegios root (mÃ¡s seguro)
- âœ… **Compatible con Docker**: Usa los mismos Dockerfiles
- âœ… **Pods nativos**: Como Kubernetes pero local

**Comandos familiares:**
```bash
podman run nginx:alpine      # En lugar de docker run
podman build -t mi-app .     # Mismo Dockerfile
```

**Â¿Maduro para producciÃ³n?**
âœ… **SÃ** - Red Hat lo usa extensivamente

---

## Containerd: El Motor Subyacente ğŸ”§

### Docker por dentro usa containerd

**RelaciÃ³n interesante:**
```{mermaid}
graph LR
    A[Docker] --> B[containerd]
    B --> C[runc]
    C --> D[Contenedor]
    
    style A fill:#lightblue
    style B fill:#lightgreen
```

**Â¿CuÃ¡ndo usar containerd directamente?**

- Cuando necesitas mÃ¡ximo rendimiento y control
- En plataformas de orquestaciÃ³n (Kubernetes lo adopta)
- Para sistemas embebidos o de recursos limitados

**Madurez:** âœ… **Muy maduro** - Es el estÃ¡ndar industrial

---

## Kubernetes con Containerd: La EvoluciÃ³n Natural

### Â¿Por quÃ© Kubernetes prefiere containerd?

```bash
# Kubernetes ya no depende de Docker
kubelet --container-runtime=containerd
```

**Ventajas:**

- Menor overhead que Docker
- Mejor integraciÃ³n con el ecosistema Kubernetes
- MÃ¡s ligero y especÃ­fico para orquestaciÃ³n

**Â¿Maduro?** âœ… **SÃ­** - Desde Kubernetes 1.20+ es estÃ¡ndar

---

## LXC/LXD: Contenedores de Sistema Completo ğŸ–¥ï¸

### Diferente filosofÃ­a:

| CaracterÃ­stica | Docker | LXC |
|----------------|---------|-----|
| **PropÃ³sito** | AplicaciÃ³n | Sistema operativo |
| **TamaÃ±o** | MBs | GBs |
| **Uso tÃ­pico** | Microservicios | MÃ¡quinas virtuales ligeras |

**Â¿CuÃ¡ndo usar LXC?**

- Cuando necesitas un "sistema operativo completo" en contenedor
- Para hosting tradicional pero mÃ¡s ligero que VMs
- Entornos de desarrollo que simulan servidores completos

---

## Â¿EstÃ¡n maduras para producciÃ³n? ğŸ“Š

### Resumen por tecnologÃ­a:

| TecnologÃ­a | Madurez | Caso de uso ideal |
|------------|---------|-------------------|
| **Podman** | âœ… Alta | Desarrollo local, entornos enterprise Red Hat |
| **Containerd** | âœ… Muy Alta | Kubernetes, plataformas cloud |
| **LXC/LXD** | âœ… Alta | Hosting, VMs ligeras, desarrollo sistema completo |
| **Docker** | âœ… EstÃ¡ndar | Desarrollo general, CI/CD |

**Veredicto:** El ecosistema estÃ¡ maduro, cada herramienta tiene su nicho.

---

## Alternativas a Docker Hub: Registros de Contenedores ğŸŒ

### El panorama de registros:

```{mermaid}
graph TB
    A[Registros de Contenedores] --> B[PÃºblicos]
    A --> C[Privados/Enterprise]
    A --> D[Autohospedados]
    
    B --> B1[Docker Hub]
    B --> B2[GHCR GitHub]
    B --> B3[Quay.io]
    
    C --> C1[Azure ACR]
    C --> C2[AWS ECR]
    C --> C3[GCP GCR]
    
    D --> D1[Harbor]
    D --> D2[Nexus]
    D --> D3[Portus]
```

---

## GitHub Container Registry (GHCR) ğŸ™

### La apuesta de GitHub

**Â¿Por quÃ© usarlo?**

- âœ… IntegraciÃ³n nativa con GitHub Actions
- âœ… Gratuito para paquetes pÃºblicos
- âœ… Permisos basados en repositorios GitHub
- âœ… Buen rendimiento

**Ejemplo de uso:**
```yaml
# GitHub Actions
- name: Build and push
  uses: docker/build-push-action@v2
  with:
    push: true
    tags: ghcr.io/usuario/app:latest
```

---

## Quay.io: La alternativa empresarial ğŸ¢

### Desarrollado por Red Hat

**CaracterÃ­sticas destacadas:**

- ğŸ”’ Escaneo de vulnerabilidades integrado
- ğŸ‘¥ Control de acceso granular
- ğŸ”„ ReplicaciÃ³n entre registros
- ğŸ“Š Analytics de uso

**Casos de uso:**

- Empresas que necesitan seguridad avanzada
- Entornos regulados (healthcare, finance)
- IntegraciÃ³n con OpenShift

---

## Registros Cloud: ACR, ECR, GCR â˜ï¸

### Cada cloud tiene su registro optimizado

| Cloud | Registro | Ventajas |
|-------|----------|----------|
| **AWS** | ECR | IntegraciÃ³n IAM, costo con EC2 |
| **Azure** | ACR | IntegraciÃ³n con AKS, DevOps |
| **GCP** | GCR/AR | IntegraciÃ³n con GKE, seguridad |

**Â¿CuÃ¡ndo usarlos?**

- Cuando tu infraestructura estÃ¡ en ese cloud
- Para mejor rendimiento y costos integrados
- Cuando necesitas polÃ­ticas de seguridad del cloud

---

## Registros Autohospedados: Harbor ğŸ°

### Para control total:

**Harbor caracterÃ­sticas:**

- âœ… Escaneo de vulnerabilidades (Trivy/Clair)
- âœ… ReplicaciÃ³n entre instancias
- âœ… Soporte para imÃ¡genes Helm
- âœ… Interfaz web completa

**Â¿CuÃ¡ndo autohospedar?**

- Empresas con requisitos de soberanÃ­a de datos
- Entornos air-gapped (sin internet)
- Cuando necesitas polÃ­ticas personalizadas
- Para tener control total sobre los costos

---

## Â¿CuÃ¡ndo usar cada alternativa? ğŸ§­

### GuÃ­a de decisiÃ³n:

```{mermaid}
graph LR
    A[Â¿QuÃ© registro usar?] --> B{Â¿Proyecto en GitHub?}
    B -->|SÃ­| C[GHCR]
    B -->|No| D{Â¿Empresa Red Hat/OpenShift?}
    
    D -->|SÃ­| E[Quay.io]
    D -->|No| F{Â¿Infraestructura cloud?}
    
    F -->|AWS| G[AWS ECR]
    F -->|Azure| H[Azure ACR]
    F -->|GCP| I[GCP AR]
    F -->|On-premise| J[Harbor autohospedado]
```

---

## Casos EspecÃ­ficos de Uso ğŸ¯

### Docker Hub sigue siendo relevante para:

- **ImÃ¡genes base oficiales** (ubuntu, nginx, node)
- **Comunidad open source** (mayor ecosistema)
- **Desarrollo y pruebas** (mÃ¡s rÃ¡pido para prototipos)

### Cambiar a alternativas cuando:

- **LÃ­mites de descarga** de Docker Hub te afectan
- **Seguridad empresarial** es crÃ­tica
- **IntegraciÃ³n cloud** especÃ­fica es necesaria
- **Costos** de Docker Hub Pro son prohibitivos

---

## Tendencias y Futuro ğŸ”®

### Lo que estamos viendo:

1. **Kubernetes + Containerd** = Nuevo estÃ¡ndar
2. **Podman** ganando terreno en enterprise
3. **Registros cloud** dominando en empresas
4. **Autohospedado** para casos especÃ­ficos

**RecomendaciÃ³n pragmÃ¡tica:**

- **Desarrollo local**: Docker o Podman segÃºn preferencia
- **ProducciÃ³n cloud**: Usar el registro nativo del provider
- **Empresa on-premise**: Evaluar Harbor vs Quay.io

---

## Resumen Ejecutivo ğŸ“‹

### Estado de madurez:

| TecnologÃ­a | Madurez ProducciÃ³n | RecomendaciÃ³n |
|------------|-------------------|---------------|
| **Podman** | âœ… Alta | SÃ­, especialmente para Red Hat shops |
| **Containerd** | âœ… Muy Alta | SÃ­, estÃ¡ndar en Kubernetes |
| **GHCR** | âœ… Alta | SÃ­, para proyectos GitHub |
| **ECR/ACR/GCR** | âœ… Muy Alta | SÃ­, segÃºn cloud provider |

**ConclusiÃ³n:** El ecosistema estÃ¡ maduro y diversificado. Â¡Elige segÃºn tu caso de uso especÃ­fico! ğŸ¯

---

## AnatomÃ­a de un Dockerfile ğŸ“

### El "libro de instrucciones" de tu imagen

```dockerfile
# Sintaxis bÃ¡sica - Piensa en capas de cebolla ğŸ§…
FROM ubuntu:20.04          # Capa base
LABEL maintainer="tu@email.com"
WORKDIR /app               # Directorio de trabajo
COPY . .                   # Copiar archivos
RUN apt-get update && apt-get install -y python3
CMD ["python3", "app.py"]  # Comando por defecto
```

## Consejos para seleccionar imÃ¡genes Docker

- Verifica la cantidad de descargas para evaluar la popularidad.
- Revisa las etiquetas (tags) para elegir la versiÃ³n adecuada.
- Prefiere imÃ¡genes oficiales (`OFFICIAL`).

**Ejemplo prÃ¡ctico:** Buscar la imagen oficial de `nginx`:
```bash
docker pull nginx:latest
```

> Nota: No siempre `latest` es la mejor opciÃ³n. Ya que cambia con frecuencia.

## AnatomÃ­a de un Dockerfile 1

### Â¿QuÃ© es un Dockerfile?

Es un archivo de texto que contiene instrucciones para construir una imagen personalizada.

### Estructura bÃ¡sica:

```Dockerfile
# Base image
FROM ubuntu:20.04
# Autor
LABEL maintainer="tu_nombre@example.com"
# Instalar dependencias
RUN apt-get update && apt-get install -y python3
# Copiar archivos
COPY app.py /app/
# Definir directorio de trabajo
WORKDIR /app
# Puerto expuesto
EXPOSE 8080
# Comando por defecto
CMD ["python3", "app.py"]
```

## AnatomÃ­a de un Dockerfile 2

> **AnatomÃ­a de un Dockerfile**
```{mermaid}
graph TD
    A[Dockerfile] --> B[Base Image]
    A --> C[Instrucciones RUN]
    A --> D[COPY/ADD]
    A --> E[EXPOSE]
    A --> F[CMD/ENTRYPOINT]
```

---

## Las 3 R's: RUN, CMD, ENTRYPOINT

### Â¡No te confundas! Son como diferentes tipos de chefs ğŸ‘¨â€ğŸ³

```{mermaid}
graph TD
    A[Instrucciones de EjecuciÃ³n] --> B[RUN]
    A --> C[CMD]
    A --> D[ENTRYPOINT]
    
    B --> B1[ConstrucciÃ³n]
    C --> C1[Valor por defecto]
    D --> D1[Ejecutable fijo]
```

---

## RUN: El Chef Constructor ğŸ‘·â€â™‚ï¸

### Se ejecuta durante la CONSTRUCCIÃ“N de la imagen

```dockerfile
# Ejemplos de RUN
RUN apt-get update && apt-get install -y curl
RUN npm install
RUN pip install -r requirements.txt
```

\

**CaracterÃ­sticas clave:**

- âœ… Se ejecuta al construir la imagen (`docker build`)
- âŒ No se ejecuta al iniciar el contenedor
- ğŸ“ Cada RUN crea una nueva capa

---

## CMD: El Comando por Defecto ğŸ¯

### Es lo que se ejecuta al INICIAR el contenedor

```dockerfile
# Diferentes formas de usar CMD
CMD ["nginx", "-g", "daemon off;"]    # Forma exec (recomendada)
CMD nginx -g "daemon off;"           # Forma shell
CMD ["python3", "app.py"]
```

\

**Â¡Importante!** CMD puede ser SOBREESCRITO al ejecutar el contenedor:
```bash
docker run mi-imagen echo "Hola"  # Â¡Sobreescribe el CMD!
```

## El Mecanismo de Sobrescritura de CMD

### Piensa en CMD como una "sugerencia por defecto"

```{mermaid}
graph LR
    A[docker run mi-imagen echo &quot;Hola&quot;] --> B[Docker Engine]
    B --> C{"Â¿Tiene argumentos
    despuÃ©s de la imagen?"}
    C -->|SÃ­| D[Reemplaza CMD completo]
    C -->|No| E[Usa CMD del Dockerfile]
    
    D --> F[Ejecuta: echo &quot;Hola&quot;]
    E --> G[Ejecuta CMD original]
```

**Lo que Docker hace internamente:**

1. âœ… Carga la imagen `mi-imagen`
2. âœ… Ve que hay argumentos despuÃ©s del nombre: `echo "Hola"`

## Â¿QuÃ© pasa realmente bajo el capÃ³? ğŸ”§

### Ejemplo prÃ¡ctico:

**Dockerfile:**
```dockerfile
FROM ubuntu:20.04
CMD ["python3", "app.py"]  # Comando por defecto
```

**Al ejecutar:**
```bash
docker run mi-imagen echo "Hola"
```

**Lo que Docker hace internamente:**

3. âœ… **Descarta completamente** el `CMD ["python3", "app.py"]`
4. âœ… Ejecuta `echo "Hola"` en su lugar


---

## ENTRYPOINT: El Ejecutable Principal ğŸš€

### Define el programa PRINCIPAL del contenedor

```dockerfile
# ENTRYPOINT + CMD trabajando juntos
ENTRYPOINT ["nginx"]
CMD ["-g", "daemon off;"]
```

**Comportamiento especial:**

- El CMD se convierte en argumentos del ENTRYPOINT
- DifÃ­cil de sobrescribir (requiere `--entrypoint`)

```bash
# Ejemplo prÃ¡ctico
docker run mi-nginx -t  # Ejecuta: nginx -t
```

## Â¿Y quÃ© pasa con ENTRYPOINT? ğŸ¤”

### AquÃ­ la magia es diferente:

```dockerfile
ENTRYPOINT ["nginx"]
CMD ["-g", "daemon off;"]
```

**Al ejecutar:**
```bash
docker run mi-nginx -t
```

**Resultado:** `nginx -t` (Â¡CMD se convierte en argumentos!)

```{mermaid}
graph LR
    A[ENTRYPOINT] --> C[nginx]
    B[CMD o argumentos] --> D[Argumentos]
    C --> E[Comando final]
    D --> E
```


---

## RUN vs CMD vs ENTRYPOINT: Resumen

\

| InstrucciÃ³n | Â¿CuÃ¡ndo se ejecuta? | Â¿Se puede sobrescribir? | PropÃ³sito |
|-------------|---------------------|-----------|------------------------|
| **RUN**     | Durante construcciÃ³n | No | Instalar paquetes, configurar |
| **CMD**     | Al iniciar contenedor | SÃ­ fÃ¡cilmente | Comando por defecto |
| **ENTRYPOINT** | Al iniciar contenedor | SÃ­ (con flag) | Ejecutable principal |

---

## Casos de Uso PrÃ¡cticos ğŸ¯

### Â¿CuÃ¡ndo usar esta funcionalidad?

**1. Debugging y troubleshooting:**
```bash
# En lugar del CMD normal, ejecuta un shell
docker run -it mi-app /bin/bash
# Ver variables de entorno
docker run mi-app env
```

**2. Testing diferentes configuraciones:**
```bash
# Probar con diferentes parÃ¡metros
docker run mi-app --help
docker run mi-app --version
```

**3. Comandos administrativos:**
```bash
# Ejecutar tareas de mantenimiento
docker run mi-database backup-script.sh
```

---

## Resumen de Comportamientos ğŸª

\

| Escenario | Comando | Resultado |
|-----------|---------|-----------|
| **Solo CMD** | `docker run app` | Ejecuta CMD del Dockerfile |
| **CMD + args** | `docker run app echo "Hola"` | Ejecuta `echo "Hola"` |
| **ENTRYPOINT + CMD** | `docker run nginx` | Ejecuta `nginx -g "daemon off;"` |
| **ENTRYPOINT + args** | `docker run nginx -t` | Ejecuta `nginx -t` |


## Mejoras: OptimizaciÃ³n de Capas (Caching) âš¡

### Â¿QuÃ© es el caching?

- Docker guarda cada instrucciÃ³n como una capa.
- Las capas anteriores se reutilizan si no cambian.

### El arte de hacer builds rÃ¡pidos

**Problema comÃºn:**
```dockerfile
FROM ubuntu
COPY . /app          # Si cambias un archivo...
RUN apt-get update && apt-get install -y python3  # Â¡TODO se re-ejecuta!
```

**SoluciÃ³n inteligente:**
```dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y python3  # Capa que cambia poco
COPY . /app          # Capa que cambia frecuentemente
```

---

## Estrategia de ordenamiento de capas

### Consejos:
1. Coloca instrucciones que cambian menos al principio.
2. Agrupa comandos con `&&` para reducir capas.

### Del menos cambiante al mÃ¡s cambiante

```{mermaid}
graph LR
    A[COPY cÃ³digo app] --> B[Instalar dependencias]
    B --> C[Configurar sistema]
    C --> D[Imagen base]
    
    style A fill:#f9f,stroke:#333
    style B fill:#ccf,stroke:#333
    style C fill:#cfc,stroke:#333
    style D fill:#ffc,stroke:#333
```

**Regla de oro:** Coloca lo que MÃS cambia al FINAL del Dockerfile.

---

## Ejecutar contenedores como usuario no-root por seguridad

### Â¿Por quÃ© evitar root?

- Ejecutar como root puede exponer tu sistema a riesgos de seguridad.

### SoluciÃ³n:

1. Crea un usuario dentro del Dockerfile.
2. Cambia al usuario antes de ejecutar el comando principal.

## Seguridad: No ejecutes como root! ğŸ›¡ï¸

### El principio de mÃ­nimo privilegio

**âŒ MAL:**
```dockerfile
FROM ubuntu
COPY . /app
RUN chmod 777 /app    # Â¡Peligro!
CMD ["python3", "app.py"]  # Se ejecuta como root
```

**âœ… BIEN:**
```dockerfile
FROM ubuntu
RUN groupadd -r appuser && useradd -r -g appuser appuser
USER appuser
COPY --chown=appuser:appuser . /app
CMD ["python3", "app.py"]
```

---

## Uso de Multi-stage builds

### Â¿QuÃ© son los Multi-stage builds?

- Permiten dividir el proceso de construcciÃ³n en varias etapas para reducir el tamaÃ±o final de la imagen.

### Ventajas:

- ImÃ¡genes mÃ¡s ligeras.
- Mejor seguridad (no incluyen herramientas innecesarias).

## Multi-stage Builds: ImÃ¡genes ligeras ğŸ¯

### Construye en un ambiente, ejecuta en otro

```dockerfile
# Stage 1: ConstrucciÃ³n (puede ser pesado)
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Stage 2: ProducciÃ³n (solo lo necesario)
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
```

## Ejemplo: Multi-stage builds

```Dockerfile
# Etapa 1: ConstrucciÃ³n
FROM python:3.9 AS builder
COPY . /app
RUN pip install --target=/app -r requirements.txt

# Etapa 2: ProducciÃ³n
FROM python:3.9-slim
COPY --from=builder /app /app
CMD ["python3", "/app/app.py"]
```
```{mermaid}
graph TD
    A[Etapa 1: ConstrucciÃ³n] --> B[Compila y genera artefactos]
    C[Etapa 2: ProducciÃ³n] --> D[Utiliza solo los artefactos necesarios]
```

---

## Beneficios de Multi-stage Builds

```{mermaid}
graph LR
    A[Stage 1: Build] --> B[Herramientas completas]
    C[Stage 2: Runtime] --> D[Solo lo esencial]
    
    B --> B1[Python, Node.js, compiladores]
    B --> B2[Dependencias de desarrollo]
    D --> D1[Solo archivos estÃ¡ticos]
    D --> D2[Runtime mÃ­nimo]
```

**Resultado:** Imagen final mÃ¡s pequeÃ±a y segura ğŸ‰

## Herramientas para Escribir Dockerfiles: Tu Kit de Supervivencia

### No estÃ¡s solo en la creaciÃ³n de Dockerfiles

```{mermaid}
graph TB
    A[Herramientas Dockerfile] --> B[Linters]
    A --> C[Editores Inteligentes]
    A --> D[Generadores]
    A --> E[Analizadores]
    
    B --> B1[hadolint]
    B --> B2[dockerfile-utils]
    
    C --> C1[VS Code]
    C --> C2[IntelliJ]
    C --> C3[Docker Extension]
    
    D --> D1[Dockerfile Generator]
    D --> D2[fromnode]
    
    E --> E1[dive]
    E --> E2[docker-slim]
```

---

## Hadolint: El Linter que Te Salva de Errores ğŸš¨

### Â¡Como un corrector ortogrÃ¡fico para Dockerfiles!

**Â¿QuÃ© hace?**

- Detecta malas prÃ¡cticas
- Sugiere optimizaciones
- Encuentra vulnerabilidades potenciales

**InstalaciÃ³n y uso:**
```bash
# Instalar
scoop install hadolint # Windows
brew install hadolint  # macOS
sudo apt install hadolint # Linux
# o usar container
docker run --rm -i hadolint/hadolint < Dockerfile

# Usar
hadolint Dockerfile
```

## Ejemplo de errores que detecta Hadolint

```dockerfile
# âŒ MAL - Hadolint te avisarÃ¡
FROM ubuntu
RUN apt-get update  # DL3008: Siempre combine apt-get update con install
RUN apt-get install -y curl

# âœ… BIEN - Hadolint aprobarÃ¡
RUN apt-get update && apt-get install -y curl
```

---

## Visual Studio Code: Tu Editor con Superpoderes ğŸ’»

### Extensiones esenciales para Docker:

**Docker Extension (Microsoft):**

- Autocompletado de instrucciones
- Sintaxis highlighting
- Comandos integrados
- Debugging de contenedores

## vsCode Dockerfile Extension

**Code completiÃ³n en acciÃ³n:**

```dockerfile
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
# â†‘ Te sugiere --only=production automÃ¡ticamente
```

**Snippets comunes:**

- `dockerfile-from` â†’ `FROM ...`
- `dockerfile-run` â†’ `RUN ...`
- `dockerfile-copy` â†’ `COPY ...`

---

## Dive: Analiza tus ImÃ¡genes como un Detective ğŸ”

### Â¿QuÃ© hay dentro de tu imagen?

**Dive te permite:**

- Ver cada capa de tu imagen
- Analizar el tamaÃ±o de cada capa
- Encontrar archivos innecesarios
- Calcular eficiencia de la imagen

## Dive en AcciÃ³n

```bash
# Instalar
brew install dive

# Analizar imagen
dive mi-imagen:latest
```

**Salida ejemplo:**
```
Layer 1: 120MB - InstalaciÃ³n de paquetes
Layer 2: 5MB   - CÃ³digo de la app
Layer 3: 300MB â† Â¡ARCHIVOS TEMPORALES INNECESARIOS!
```

---

## Dockerignore: El GuardiÃ¡n de tu Build ğŸ›¡ï¸

### Â¿Por quÃ© necesitas .dockerignore?

**Problema sin .dockerignore:**
```bash
# Contexto de build incluye TODO
docker build .  # â† Incluye node_modules, logs, etc.
```

**SoluciÃ³n con .dockerignore:**
```bash
# Contexto de build solo incluye lo necesario
docker build .  # â† Ignora archivos especificados
```

```{mermaid}
graph LR
    A[Directorio Proyecto] --> B{docker build}
    B --> C[Sin .dockerignore: EnvÃ­a TODO]
    B --> D[Con .dockerignore: Filtra archivos]
    
    C --> C1[Lento, capas grandes]
    D --> D1[RÃ¡pido, capas optimizadas]
```

---

## AnatomÃ­a de un .dockerignore ğŸ“

### Sintaxis similar a .gitignore

**.dockerignore ejemplo:**
```dockerignore
# Ignorar node_modules (se instalan en build)
node_modules/
npm-debug.log

# Ignorar logs y temporales
*.log
tmp/
temp/

# Ignorar archivos de desarrollo
.git/
.gitignore
README.md
.dockerignore

# Ignorar archivos de entorno (pueden tener secrets)
.env
.env.local
```

---

## Â¿Por quÃ© .dockerignore es CRÃTICO? âš ï¸

### 3 razones principales:

**1. Seguridad ğŸ”’**
```dockerignore
# Evita que secrets lleguen a la imagen
.env
.aws/
id_rsa*
*.pem
```

**2. Performance ğŸš€**
```dockerignore
# Evita enviar gigabytes innecesarios
node_modules/    # 500MB que se reinstalarÃ¡n anyway
.git/           # Historial completo
```

**3. TamaÃ±o de imagen ğŸ“¦**
```dockerignore
# Archivos que inflan la imagen sin beneficio
*.map           # Source maps de producciÃ³n
test/           # Tests que no se ejecutan en prod
```

---

## Errores Comunes con .dockerignore âŒ

### Â¡Cuidado con estos patrones!

**Problema 1: Ignorar archivos necesarios**
```dockerignore
# âŒ MAL - Ignora TODOS los .json incluyendo package.json!
*.json

# âœ… BIEN - EspecÃ­fico
*.config.json
tsconfig.json
```

**Problema 2: Patrones incorrectos**
```dockerignore
# âŒ MAL - No funciona como esperas
src/test/      # Solo ignora en raÃ­z, no en subdirectorios

# âœ… BIEN - PatrÃ³n correcto
**/test/
**/*.test.js
```

---

## Caso PrÃ¡ctico: Antes y DespuÃ©s ğŸ¯

### Sin .dockerignore:
```bash
# Build lento y pesado
Sending build context to Docker daemon: 1.2GB
```

\

### Con .dockerignore optimizado:
```bash
# Build rÃ¡pido y liviano
Sending build context to Docker daemon: 15.6MB
```

## `.dockerignore` efectivo

```dockerignore
# Dependencias
node_modules/
vendor/

# Control de versiones
.git/
.svn/

# Logs y temporales
*.log
tmp/
.cache/

# Entorno y configuraciÃ³n local
.env
.idea/
.vscode/

# DocumentaciÃ³n
README.md
docs/
```

---

## Herramientas para .dockerignore ğŸ› ï¸

### Â¿CÃ³mo validar que funciona?

**dockerignore CLI:**
```bash
# Ver quÃ© archivos se ignorarÃ­an
npx dockerignore check

# Generar .dockerignore para tu proyecto
npx dockerignore generate node,git,env
```

**VerificaciÃ³n manual:**
```bash
# Ver contexto que se enviarÃ­a
docker build --no-cache --progress=plain .
```

---

## IntegraciÃ³n con CI/CD ğŸ”„

### .dockerignore en tus pipelines:

**GitHub Actions ejemplo:**
```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Build Docker image
        run: |
          # .dockerignore asegura que solo se envÃ­e lo necesario
          docker build -t mi-app .
```

---

## Buenas PrÃ¡cticas Combinadas ğŸ†

### Dockerfile + .dockerignore = Ã‰xito garantizado

**Estructura ideal:**
```
proyecto/
â”œâ”€â”€ .dockerignore          # â† Filtra archivos
â”œâ”€â”€ Dockerfile             # â† Instrucciones build
â”œâ”€â”€ src/                   # â† Solo esto va al build
â”œâ”€â”€ package.json           # â† Necesario para npm install
â””â”€â”€ node_modules/          # â† IGNORADO (se recrea en build)
```

**Flujo optimizado:**
```{mermaid}
graph LR
    A[Source Code] --> B[.dockerignore]
    B --> C[Build Context Filtrado]
    C --> D[Dockerfile]
    D --> E[Imagen Optimizada]
```

---

## Resumen Ejecutivo ğŸ“‹

### Herramientas imprescindibles:

| Herramienta | PropÃ³sito | Â¿CuÃ¡ndo usar? |
|-------------|-----------|---------------|
| **hadolint** | Linter Dockerfile | Siempre, en CI/CD |
| **VS Code Docker** | Desarrollo | Durante escritura de Dockerfiles |
| **dive** | AnÃ¡lisis imÃ¡genes | OptimizaciÃ³n de tamaÃ±o |
| **.dockerignore** | Filtro archivos | TODO proyecto Docker |

\

### .dockerignore es NO negociable porque:
- âœ… Mejora seguridad
- âœ… Acelera builds
- âœ… Reduce tamaÃ±o de imÃ¡genes
- âœ… Previene leaks de informaciÃ³n

---

## Â¡Tu Dockerfile Perfecto Espera! ğŸš€

**Con estas herramientas:**

- EscribirÃ¡s Dockerfiles mÃ¡s seguros y eficientes
- DetectarÃ¡s errores antes del build
- OptimizarÃ¡s el tamaÃ±o de tus imÃ¡genes
- MantendrÃ¡s secrets fuera de tus contenedores

---

## Resumen del MÃ³dulo 3 ğŸ“

### Lo esencial que debes recordar:

1. **Docker Hub** es tu aliado para encontrar imÃ¡genes base
2. **Dockerfile** es la receta de tu imagen
3. **RUN** vs **CMD** vs **ENTRYPOINT** tienen propÃ³sitos distintos
4. **Optimiza capas** para builds mÃ¡s rÃ¡pidos
5. **Seguridad primero**: no uses root
6. **Multi-stage** para imÃ¡genes de producciÃ³n optimizadas
7. **.dockerignore** para optimizar builds
8. **Herramientas** para editar Dockerfiles

---

## PrÃ³ximos pasos ğŸš€

### En el laboratorio practicaremos:

- Crear tu primer Dockerfile desde cero
- Experimentar con RUN, CMD y ENTRYPOINT
- Optimizar un Dockerfile existente
- Implementar multi-stage builds

**Â¡Preparados para el hands-on!** ğŸ’»

# Preguntas y Respuestas â“

**Â¿Alguna duda sobre los conceptos de imÃ¡genes?**

Â¡No te quedes con dudas! Este es el fundamento de todo lo que viene despuÃ©s.



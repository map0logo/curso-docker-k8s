---
title: Docker Compose
subtitle: Orquestaci√≥n de aplicaciones con m√∫ltiples contenedores
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png

---

# Docker Compose y Orquestaci√≥n de aplicaciones con m√∫ltiples contenedores

---

## El problema: Aplicaciones multi-contenedor

::: {.columns}
::: {.column width="50%"}
**¬øTe ha pasado esto?**
```bash
docker run -d --name db -v db_data:/data mysql
docker run -d --name web -p 80:80 --link db nginx
docker run -d --name cache --link db redis
docker run -d --name app --link db --link web --link cache nodejs
```

**Problemas:**
- Comandos largos y complejos
- Dependencias dif√≠ciles de gestionar
- Orden de inicio cr√≠tico
- Configuraci√≥n dispersa
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[MySQL] --> B[¬øInici√≥ primero?]
    C[Redis] --> D[¬øDepende de MySQL?]
    E[Nginx] --> F[¬øPuertos conflictivos?]
    G[Node.js] --> H[¬øEnlaces correctos?]
    
    style B fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
    style H fill:#ffebee
```
:::
:::

**Soluci√≥n necesaria:** Orquestaci√≥n simplificada

Imagina que cada contenedor es un m√∫sico:  
uno toca la guitarra (la base de datos), otro la bater√≠a (el backend), y otro el teclado (el frontend).  
**Docker Compose** es el director que los hace tocar juntos en armon√≠a.

---

## ¬øQu√© es Docker Compose?

::: {.columns}
::: {.column width="60%"}
**Definici√≥n:**
- Herramienta para definir y ejecutar aplicaciones multi-contenedor
- Usa un archivo YAML para configurar los servicios
- Gestiona el ciclo de vida completo de la aplicaci√≥n

**Analog√≠a:**
- Como un "director de orquesta" para contenedores
- Partitura (docker-compose.yml) ‚Üí M√∫sica (aplicaci√≥n ejecut√°ndose)

**Beneficios clave:**
- Una sola command para levantar toda la app
- Configuraci√≥n versionable
- Reproducible en cualquier entorno
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[docker-compose.yml] --> B[Docker Compose]
    B --> C[Redes]
    B --> D[Vol√∫menes]
    B --> E[Contenedores]
    
    C --> F[Aplicaci√≥n ejecut√°ndose]
    D --> F
    E --> F
```
:::
:::

---

## ¬øPor qu√© necesitamos Docker Compose?

- **Docker solo** maneja **un contenedor a la vez**.
- Las aplicaciones reales usan **m√∫ltiples servicios**:  
  - Base de datos
  - API
  - Frontend
  - Cache
  - Colas de mensajes
- Sin Compose:  
  ```bash
  docker run -d --name db postgres
  docker run -d --name redis redis
  docker run -d --name api --link db --link redis my-api
  docker run -d --name web --link api my-web
  ```
  üòµ‚Äçüí´ ¬°Demasiado manual y propenso a errores!

---

## Anatom√≠a de docker-compose.yml

```yaml
version: '3.8'
services:
  web:
    image: nginx:alpine
    ports:
      - "80:80"
    depends_on:
      - app

  app:
    build: ./app
    environment:
      - DATABASE_URL=postgresql://db:5432
    depends_on:
      - database

  database:
    image: postgres:13
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```
---

### üîë **Tres elementos clave**:  
  1. **`version`**: Versi√≥n del formato de Compose  
  2. **`services`**: Cada contenedor es un "servicio"  
  3. **Configuraci√≥n por servicio**: imagen, puertos, vol√∫menes, dependencias...

---

## Conceptos fundamentales de Compose

```mermaid
graph TB
    A[Compose Concepts] --> B[Services]
    A --> C[Networks]
    A --> D[Volumes]
    A --> E[Dependencies]
    
    B --> F[Contenedores que forman la app]
    C --> G[Comunicaci√≥n entre servicios]
    D --> H[Almacenamiento persistente]
    E --> I[Orden de inicio]
    
    style B fill:#e3f2fd
    style C fill:#e8f5e8
    style D fill:#fff3e0
```

---

## Services: El coraz√≥n de Compose

::: {.columns}
::: {.column width="50%"}
**¬øQu√© es un servicio?**
- Definici√≥n de c√≥mo debe ejecutarse un contenedor
- Puede tener m√∫ltiples instancias (r√©plicas)
- Configuraci√≥n centralizada

**Configuraciones comunes:**
- `image` o `build`
- `ports` y `expose`
- `environment` y `env_file`
- `volumes` y `networks`
- `depends_on` para dependencias
:::

::: {.column width="50%"}
```mermaid
graph LR
    A[Service Definition] --> B[1..N Instances]
    B --> C[Container 1]
    B --> D[Container 2]
    B --> E[Container N]
    
    style A fill:#f3e5f5
```
:::
:::

**Ejemplo:** `web`, `api`, `database`, `cache` son servicios

---

## Redes: ¬øC√≥mo se comunican los contenedores?

::: {.columns}
::: {.column width="50%}
**Comportamiento por defecto:**
- Docker Compose crea una red privada para tus servicios.
- DNS autom√°tico usando nombres de servicio
- Tu API puede llamar a `http://db:5432` sin saber la IP.
- Puedes definir redes personalizadas si necesitas aislar grupos de otras aplicaciones
:::

::: {.column width="50%"}
**Comunicaci√≥n simplificada:**
```yaml
# web puede conectar a "db:5432"
# sin conocer la IP real
```
:::

```mermaid
graph LR
  A[Frontend] -->|http://api:3000| B(API)
  B -->|db:5432| C[(Base de Datos)]
  B -->|redis:6379| D[(Redis Cache)]
```

‚úÖ Comunicaci√≥n segura, sin exponer puertos al host.


::: {.column width="50%"}
```mermaid
graph TB
    A[compose-app_default] --> B[web]
    A --> C[app]
    A --> D[database]
    A --> E[cache]
    
    B --> F[Resuelve: app]
    B --> G[Resuelve: database]
    C --> H[Resuelve: cache]
    
    style A fill:#e8f5e8
```
:::
:::

---

## Dependencias y orden de inicio de los servicios

::: {.columns}
::: {.column width="50%"}
**`depends_on`:**
- Controla el orden de inicio
- No espera que el servicio est√© "listo"
- Solo garantiza qu√© se inicia despu√©s

**Problema com√∫n:**
- La DB se inicia, pero tarda en aceptar conexiones
- La app falla porque intenta conectar demasiado pronto

> ‚ö†Ô∏è **Importante**: `depends_on` **no espera a que el servicio est√© "listo"**, solo que se haya iniciado.

**Soluci√≥n avanzada:**
- Healthchecks
- Scripts de espera personalizados
:::

::: {.column width="50%"}
```mermaid
graph LR
    A[database] --> B[app]
    B --> C[web]
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style C fill:#ffccbc
```
```yaml
services:
  web:
    depends_on:
      - app
  app:
    depends_on:
      - database
```
:::
:::

---

## Variables de entorno y configuraciones

::: {.columns}
::: {.column width="50%}
**Flexibilidad con variables:**
```yaml
services:
  database:
    image: postgres:${POSTGRES_VERSION:-13}
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
```

> üîê Usa archivos `.env` para valores sensibles:

```env
DB_PASS=supersecreto123
API_KEY=abc123
```

Compose los carga **autom√°ticamente** si existe un `.env` en la misma carpeta.

**Archivos de entorno:**
- `.env` (autom√°tico)
- `env_file:` espec√≠fico por servicio

**Beneficio:** Diferentes configuraciones por entorno
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[.env file] --> B[Compose Interpolation]
    C[env_file:] --> B
    B --> D[Final Configuration]
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
```
:::
:::

---

## Vol√∫menes y persistencia en Compose

::: {.columns}
::: {.column width="60%"}
**Tipos de vol√∫menes:**
- **Named volumes:** Gestionados por Docker
- **Bind mounts:** Directorios del host
- **Anonymous volumes:** Temporales

**En Compose:**
```yaml
services:
  database:
    volumes:
      - db_data:/var/lib/data
      - ./config:/app/config

volumes:
  db_data:
```
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Named Volume] --> B[Persiste entre deploys]
    C[Bind Mount] --> D[Desarrollo]
    E[Anonymous] --> F[Temporal]
    
    style A fill:#c8e6c9
    style C fill:#fff3e0
```
:::
:::

üóÉÔ∏è El volumen `db_data` vive **m√°s all√°** del ciclo de vida del contenedor.

---

## Escalando servicios

::: {.columns}
::: {.column width="50%}
**Escala horizontal simple:**
```bash
docker-compose up --scale web=3 --scale api=2
```

**L√≠mites:**
- Compose no hace load balancing
- √ötil para desarrollo y testing
- Producci√≥n necesita m√°s herramientas

**Caso de uso t√≠pico:**
- Probar c√≥mo se comporta la app con m√∫ltiples instancias
- Desarrollo de caracter√≠sticas de concurrencia
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[web] --> B[web_1]
    A --> C[web_2]
    A --> D[web_3]
    
    E[api] --> F[api_1]
    E --> G[api_2]
    
    style A fill:#f3e5f5
    style E fill:#e1f5fe
```
:::
:::

---

## Perfiles: Organizando servicios

::: {.columns}
::: {.column width="60%"}
**Para diferentes contextos:**
```yaml
services:
  frontend:
    profiles: ["frontend"]
    
  backend:
    profiles: ["backend"]
    
  database:
    profiles: ["database", "production"]
    
  debug-tools:
    profiles: ["development"]
```

**Uso:**
```bash
docker-compose --profile frontend up
docker-compose --profile development up
```
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Perfiles] --> B[Development]
    A --> C[Production]
    A --> D[Testing]
    
    B --> E[Servicios de debug]
    C --> F[Servicios optimizados]
    D --> G[Servicios de test]
```
:::
:::

---

## Docker Compose vs Docker Swarm

::: {.columns}
::: {.column width="50%}
**Docker Compose:**
- Single-host
- Desarrollo y testing
- Configuraci√≥n simple
- Comandos directos

**Docker Swarm:**
- Multi-host
- Producci√≥n
- Alta disponibilidad
- Escalado autom√°tico
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[Compose] --> B[1 Host]
    B --> C[App Completa]
    
    D[Swarm] --> E[M√∫ltiples Hosts]
    E --> F[Cluster]
    F --> G[Alta Disponibilidad]
    
    style A fill:#e1f5fe
    style D fill:#c8e6c9
```
:::
:::

---

## Introducci√≥n a Docker Swarm

::: {.columns}
::: {.column width="60%"}
**¬øQu√© es?**
- Orquestaci√≥n nativa de Docker
- Convierte m√∫ltiples hosts en un cluster
- Gestiona despliegues, escalado, y alta disponibilidad

**Conceptos clave:**
- **Manager nodes:** Gestionan el cluster
- **Worker nodes:** Ejecutan los contenedores
- **Services:** Aplicaciones escalables
- **Stacks:** Deploys con Compose files
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Manager] --> B[Worker 1]
    A --> C[Worker 2]
    A --> D[Worker 3]
    
    B --> E[Contenedores]
    C --> E
    D --> E
    
    style A fill:#ffccbc
```
:::
:::

---

## Servicios en Swarm Mode

::: {.columns}
::: {.column width="50%}
**Diferencias con Compose:**
- Servicios distribuidos en m√∫ltiples nodos
- Escalado autom√°tico
- Load balancing integrado
- Health checks y auto-recovery

**Ejemplo:**
```bash
docker service create --name web --replicas 3 nginx
```
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[Service: web] --> B[Replica 1]
    A --> C[Replica 2]
    A --> D[Replica 3]
    
    B --> E[Node A]
    C --> F[Node B]
    D --> G[Node C]
    
    style A fill:#f3e5f5
```
:::
:::

---

## Stacks: Compose en producci√≥n

::: {.columns}
::: {.column width="60%}
**¬øQu√© son?**
- Deploys de aplicaciones multi-servicio en Swarm
- Usan archivos docker-compose.yml mejorados
- Gestionan servicios, redes, y vol√∫menes en cluster

**Comando:**
```bash
docker stack deploy -c docker-compose.yml myapp
```

**Ventajas:**
- Misma configuraci√≥n que desarrollo
- Despliegue declarativo
- Rollbacks sencillos
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[docker-compose.yml] --> B[Stack Deploy]
    B --> C[Swarm Cluster]
    C --> D[Servicios distribuidos]
    
    style B fill:#c8e6c9
```
:::
:::

---

## Health Checks en orquestaci√≥n

::: {.columns}
::: {.column width="60%}
**Problema:** ¬øC√≥mo sabe el orquestador si un servicio est√° sano?

**Soluci√≥n:** Health checks
```yaml
services:
  web:
    image: nginx
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 30s
      timeout: 10s
      retries: 3
```

**Comportamiento:**
- Swarm rerutea tr√°fico lejos de instancias enfermas
- Compose puede esperar a que los servicios est√©n listos
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[Health Check] --> B[‚úÖ Healthy]
    A --> C[‚ùå Unhealthy]
    
    B --> D[Recibe tr√°fico]
    C --> E[No recibe tr√°fico]
    
    style B fill:#c8e6c9
    style C fill:#ffcdd2
```
:::
:::

---

## Patrones comunes de orquestaci√≥n

::: {.columns}
::: {.column width="50%}
**1. Aplicaci√≥n web tradicional:**
```mermaid
graph TB
    A[Load Balancer] --> B[Web Servers]
    B --> C[App Servers]
    C --> D[Database]
```

**2. Microservicios:**
```mermaid
graph LR
    A[API Gateway] --> B[Service A]
    A --> C[Service B]
    A --> D[Service C]
```
:::

::: {.column width="50%"}
**3. Worker queues:**
```mermaid
graph TB
    A[API] --> B[Message Queue]
    B --> C[Workers]
```

**4. Batch processing:**
```mermaid
graph LR
    A[Scheduler] --> B[Batch Jobs]
```
:::
:::

---

## Configuraciones y secretos

::: {.columns}
::: {.column width="60%}
**Problema:** C√≥mo manejar configuraciones sensibles

**Soluci√≥n:**
- **Configs:** Archivos de configuraci√≥n no sensibles
- **Secrets:** Informaci√≥n sensible (passwords, API keys)

**En Swarm:**
```yaml
services:
  app:
    configs:
      - app_config
    secrets:
      - db_password

configs:
  app_config:
    file: ./config.yml

secrets:
  db_password:
    file: ./db_password.txt
```
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Configs] --> B[Read-only en contenedores]
    C[Secrets] --> D[Encriptados en reposo]
    
    style C fill:#ffebee
```
:::
:::

---

## Buenas pr√°cticas de orquestaci√≥n

**Desarrollo:**
- Usa Compose para entorno local
- Perfiles para diferentes configuraciones
- Variables de entorno para diferencias entre entornos

**Producci√≥n:**
- Health checks en todos los servicios
- L√≠mites de recursos (CPU, memoria)
- Estrategias de despliegue (rolling updates)
- Logs centralizados y monitoreo

---

## Flujo de trabajo t√≠pico

```mermaid
graph LR
    A[Desarrollo] --> B[Compose Local]
    B --> C[Testing]
    C --> D[CI/CD]
    D --> E[Registry]
    E --> F[Swarm Production]
    
    style A fill:#e1f5fe
    style F fill:#c8e6c9
```

**Consistencia:** Misma configuraci√≥n en todos los entornos

---

## Resumen: Docker Compose

| Caracter√≠stica | Beneficio |
|----------------|-----------|
| **Archivo YAML** | Configuraci√≥n versionable |
| **Servicios** | Aplicaciones multi-contenedor |
| **Redes autom√°ticas** | Comunicaci√≥n simplificada |
| **Dependencias** | Orden de inicio controlado |

---

## Resumen: Orquestaci√≥n avanzada

| Concepto | Prop√≥sito |
|----------|-----------|
| **Docker Swarm** | Orquestaci√≥n multi-host |
| **Services** | Aplicaciones escalables |
| **Stacks** | Deploys con Compose files |
| **Health Checks** | Monitoreo y auto-recovery |

---

## Evoluci√≥n natural

```mermaid
graph TB
    A[Contenedores simples] --> B[Docker Compose]
    B --> C[Multi-contenedor apps]
    C --> D[Docker Swarm]
    D --> E[Producci√≥n enterprise]
    
    style B fill:#e1f5fe
    style D fill:#c8e6c9
```

**Tu viaje:** De contenedores individuales a aplicaciones complejas orquestadas

---

## ¬°Preparados para el siguiente nivel!

**Lo que hemos cubierto:**
- Fundamentos de Docker Compose
- Orquestaci√≥n de aplicaciones multi-contenedor
- Diferencias entre desarrollo y producci√≥n
- Introducci√≥n a Docker Swarm

**Pr√≥ximo paso:** Laboratorio pr√°ctico donde aplicaremos estos conceptos con ejercicios reales
---
title: Docker Compose
subtitle: OrquestaciÃ³n de aplicaciones con mÃºltiples contenedores
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png

---

# Docker Compose y OrquestaciÃ³n de aplicaciones con mÃºltiples contenedores

---

## El problema: Aplicaciones multi-contenedor


**Â¿Te ha pasado esto?**
```bash
docker run -d --name db -v db_data:/data mysql
docker run -d --name web -p 80:80 --link db nginx
docker run -d --name cache --link db redis
docker run -d --name app --link db --link web --link cache nodejs
```

**Problemas:**
- Comandos largos y complejos
- Dependencias difÃ­ciles de gestionar
- Orden de inicio crÃ­tico
- ConfiguraciÃ³n dispersa


```{{mermaid}}
graph TB
    A[MySQL] --> B[Â¿IniciÃ³ primero?]
    C[Redis] --> D[Â¿Depende de MySQL?]
    E[Nginx] --> F[Â¿Puertos conflictivos?]
    G[Node.js] --> H[Â¿Enlaces correctos?]
    
    style B fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
    style H fill:#ffebee
```
:::
:::

**SoluciÃ³n necesaria:** OrquestaciÃ³n simplificada

Imagina que cada contenedor es un mÃºsico:  
uno toca la guitarra (la base de datos), otro la baterÃ­a (el backend), y otro el teclado (el frontend).  
**Docker Compose** es el director que los hace tocar juntos en armonÃ­a.

---

## Â¿QuÃ© es Docker Compose?

::: {.columns}
::: {.column width="60%"}
**DefiniciÃ³n:**
- Herramienta para definir y ejecutar aplicaciones multi-contenedor
- Usa un archivo YAML para configurar los servicios
- Gestiona el ciclo de vida completo de la aplicaciÃ³n

**AnalogÃ­a:**
- Como un "director de orquesta" para contenedores
- Partitura (docker-compose.yml) â†’ MÃºsica (aplicaciÃ³n ejecutÃ¡ndose)

**Beneficios clave:**
- Una sola command para levantar toda la app
- ConfiguraciÃ³n versionable
- Reproducible en cualquier entorno
:::

::: {.column width="40%"}
```{mermaid}
graph TB
    A[docker-compose.yml] --> B[Docker Compose]
    B --> C[Redes]
    B --> D[VolÃºmenes]
    B --> E[Contenedores]
    
    C --> F[AplicaciÃ³n ejecutÃ¡ndose]
    D --> F
    E --> F
```
:::
:::

---

## Â¿Por quÃ© necesitamos Docker Compose?

- **Docker solo** maneja **un contenedor a la vez**.
- Las aplicaciones reales usan **mÃºltiples servicios**:  
  - Base de datos
  - API
  - Frontend
  - Cache
  - Colas de mensajes
- Sin Compose:  
  ```bash
  docker run -d --name db postgres
  docker run -d --name redis redis
  docker run -d --name api --link db --link redis my-api
  docker run -d --name web --link api my-web
  ```
  ğŸ˜µâ€ğŸ’« Â¡Demasiado manual y propenso a errores!

---

## AnatomÃ­a de docker-compose.yml

```yaml
version: '3.8'
services:
  web:
    image: nginx:alpine
    ports:
      - "80:80"
    depends_on:
      - app

  app:
    build: ./app
    environment:
      - DATABASE_URL=postgresql://db:5432
    depends_on:
      - database

  database:
    image: postgres:13
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```
---

### ğŸ”‘ **Tres elementos clave**:  
  1. **`version`**: VersiÃ³n del formato de Compose  
  2. **`services`**: Cada contenedor es un "servicio"  
  3. **ConfiguraciÃ³n por servicio**: imagen, puertos, volÃºmenes, dependencias...

---

## Conceptos fundamentales de Compose

```{mermaid}
graph TB
    A[Compose Concepts] --> B[Services]
    A --> C[Networks]
    A --> D[Volumes]
    A --> E[Dependencies]
    
    B --> F[Contenedores que forman la app]
    C --> G[ComunicaciÃ³n entre servicios]
    D --> H[Almacenamiento persistente]
    E --> I[Orden de inicio]
    
    style B fill:#e3f2fd
    style C fill:#e8f5e8
    style D fill:#fff3e0
```

---

## Services: El corazÃ³n de Compose

::: {.columns}
::: {.column width="50%"}
**Â¿QuÃ© es un servicio?**
- DefiniciÃ³n de cÃ³mo debe ejecutarse un contenedor
- Puede tener mÃºltiples instancias (rÃ©plicas)
- ConfiguraciÃ³n centralizada

**Configuraciones comunes:**
- `image` o `build`
- `ports` y `expose`
- `environment` y `env_file`
- `volumes` y `networks`
- `depends_on` para dependencias
:::

::: {.column width="50%"}
```{mermaid}
graph LR
    A[Service Definition] --> B[1..N Instances]
    B --> C[Container 1]
    B --> D[Container 2]
    B --> E[Container N]
    
    style A fill:#f3e5f5
```
:::
:::

**Ejemplo:** `web`, `api`, `database`, `cache` son servicios

---

## Redes: Â¿CÃ³mo se comunican los contenedores?

::: {.columns}
::: {.column width="50%}
**Comportamiento por defecto:**
- Docker Compose crea una red privada para tus servicios.
- DNS automÃ¡tico usando nombres de servicio
- Tu API puede llamar a `http://db:5432` sin saber la IP.
- Puedes definir redes personalizadas si necesitas aislar grupos de otras aplicaciones
:::

::: {.column width="50%"}
**ComunicaciÃ³n simplificada:**
```yaml
# web puede conectar a "db:5432"
# sin conocer la IP real
```
:::

```{mermaid}
graph LR
  A[Frontend] -->|http://api:3000| B(API)
  B -->|db:5432| C[(Base de Datos)]
  B -->|redis:6379| D[(Redis Cache)]
```

âœ… ComunicaciÃ³n segura, sin exponer puertos al host.


::: {.column width="50%"}
```{mermaid}
graph TB
    A[compose-app_default] --> B[web]
    A --> C[app]
    A --> D[database]
    A --> E[cache]
    
    B --> F[Resuelve: app]
    B --> G[Resuelve: database]
    C --> H[Resuelve: cache]
    
    style A fill:#e8f5e8
```
:::
:::

---

## Dependencias y orden de inicio de los servicios

::: {.columns}
::: {.column width="50%"}
**`depends_on`:**
- Controla el orden de inicio
- No espera que el servicio estÃ© "listo"
- Solo garantiza quÃ© se inicia despuÃ©s

**Problema comÃºn:**
- La DB se inicia, pero tarda en aceptar conexiones
- La app falla porque intenta conectar demasiado pronto

> âš ï¸ **Importante**: `depends_on` **no espera a que el servicio estÃ© "listo"**, solo que se haya iniciado.

**SoluciÃ³n avanzada:**
- Healthchecks
- Scripts de espera personalizados
:::

::: {.column width="50%"}
```{mermaid}
graph LR
    A[database] --> B[app]
    B --> C[web]
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style C fill:#ffccbc
```
```yaml
services:
  web:
    depends_on:
      - app
  app:
    depends_on:
      - database
```
:::
:::

---

## Variables de entorno y configuraciones

::: {.columns}
::: {.column width="50%}
**Flexibilidad con variables:**
```yaml
services:
  database:
    image: postgres:${POSTGRES_VERSION:-13}
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
```

> ğŸ” Usa archivos `.env` para valores sensibles:

```env
DB_PASS=supersecreto123
API_KEY=abc123
```

Compose los carga **automÃ¡ticamente** si existe un `.env` en la misma carpeta.

**Archivos de entorno:**
- `.env` (automÃ¡tico)
- `env_file:` especÃ­fico por servicio

**Beneficio:** Diferentes configuraciones por entorno
:::

::: {.column width="50%"}
```{mermaid}
graph TB
    A[.env file] --> B[Compose Interpolation]
    C[env_file:] --> B
    B --> D[Final Configuration]
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
```
:::
:::

---

## VolÃºmenes y persistencia en Compose

::: {.columns}
::: {.column width="60%"}
**Tipos de volÃºmenes:**
- **Named volumes:** Gestionados por Docker
- **Bind mounts:** Directorios del host
- **Anonymous volumes:** Temporales

**En Compose:**
```yaml
services:
  database:
    volumes:
      - db_data:/var/lib/data
      - ./config:/app/config

volumes:
  db_data:
```
:::

::: {.column width="40%"}
```{mermaid}
graph TB
    A[Named Volume] --> B[Persiste entre deploys]
    C[Bind Mount] --> D[Desarrollo]
    E[Anonymous] --> F[Temporal]
    
    style A fill:#c8e6c9
    style C fill:#fff3e0
```
:::
:::

ğŸ—ƒï¸ El volumen `db_data` vive **mÃ¡s allÃ¡** del ciclo de vida del contenedor.

---

## Escalando servicios

Con Compose puedes **escalar servicios** fÃ¡cilmente:

```bash
docker-compose up --scale api=3
```
---

> ğŸ» Ahora tienes **3 instancias del API** corriendo simultÃ¡neamente.  
> (Ideal para pruebas de carga o balanceo simple)

> âš ï¸ Pero: Compose **no es un orquestador de producciÃ³n** como Kubernetes.  
> Es para desarrollo, pruebas y entornos simples.

---

::: {.columns}
::: {.column width="50%}
**Escala horizontal simple:**
```bash
docker-compose up --scale web=3 --scale api=2
```

**LÃ­mites:**
- Compose no hace load balancing
- Ãštil para desarrollo y testing
- ProducciÃ³n necesita mÃ¡s herramientas

**Caso de uso tÃ­pico:**
- Probar cÃ³mo se comporta la app con mÃºltiples instancias
- Desarrollo de caracterÃ­sticas de concurrencia
:::

::: {.column width="50%"}
```{mermaid}
graph TB
    A[web] --> B[web_1]
    A --> C[web_2]
    A --> D[web_3]
    
    E[api] --> F[api_1]
    E --> G[api_2]
    
    style A fill:#f3e5f5
    style E fill:#e1f5fe
```
:::
:::

---

## Perfiles: Organizando servicios

::: {.columns}
::: {.column width="60%"}
**Para diferentes contextos:**
```yaml
services:
  frontend:
    profiles: ["frontend"]
    
  backend:
    profiles: ["backend"]
    
  database:
    profiles: ["database", "production"]
    
  debug-tools:
    profiles: ["development"]
```

**Uso:**
```bash
docker-compose --profile frontend up
docker-compose --profile development up
```
:::

::: {.column width="40%"}
```{mermaid}
graph TB
    A[Perfiles] --> B[Development]
    A --> C[Production]
    A --> D[Testing]
    
    B --> E[Servicios de debug]
    C --> F[Servicios optimizados]
    D --> G[Servicios de test]
```
:::
:::

---

## Docker Compose vs Docker Swarm

::: {.columns}
::: {.column width="50%}
**Docker Compose:**
- Single-host
- Desarrollo y testing
- ConfiguraciÃ³n simple
- Comandos directos

**Docker Swarm:**
- Multi-host
- ProducciÃ³n
- Alta disponibilidad
- Escalado automÃ¡tico
:::

::: {.column width="50%"}
```{mermaid}
graph TB
    A[Compose] --> B[1 Host]
    B --> C[App Completa]
    
    D[Swarm] --> E[MÃºltiples Hosts]
    E --> F[Cluster]
    F --> G[Alta Disponibilidad]
    
    style A fill:#e1f5fe
    style D fill:#c8e6c9
```
:::
:::

---

## IntroducciÃ³n a Docker Swarm

::: {.columns}
::: {.column width="60%"}
**Â¿QuÃ© es?**
- OrquestaciÃ³n nativa de Docker
- Convierte mÃºltiples hosts en un cluster
- Gestiona despliegues, escalado, y alta disponibilidad

**Conceptos clave:**
- **Manager nodes:** Gestionan el cluster
- **Worker nodes:** Ejecutan los contenedores
- **Services:** Aplicaciones escalables
- **Stacks:** Deploys con Compose files
:::

::: {.column width="40%"}
```{mermaid}
graph TB
    A[Manager] --> B[Worker 1]
    A --> C[Worker 2]
    A --> D[Worker 3]
    
    B --> E[Contenedores]
    C --> E
    D --> E
    
    style A fill:#ffccbc
```
:::
:::

---

## Servicios en Swarm Mode

::: {.columns}
::: {.column width="50%}
**Diferencias con Compose:**
- Servicios distribuidos en mÃºltiples nodos
- Escalado automÃ¡tico
- Load balancing integrado
- Health checks y auto-recovery

**Ejemplo:**
```bash
docker service create --name web --replicas 3 nginx
```
:::

::: {.column width="50%"}
```{mermaid}
graph TB
    A[Service: web] --> B[Replica 1]
    A --> C[Replica 2]
    A --> D[Replica 3]
    
    B --> E[Node A]
    C --> F[Node B]
    D --> G[Node C]
    
    style A fill:#f3e5f5
```
:::
:::

---

## Stacks: Compose en producciÃ³n

::: {.columns}
::: {.column width="60%}
**Â¿QuÃ© son?**
- Deploys de aplicaciones multi-servicio en Swarm
- Usan archivos docker-compose.yml mejorados
- Gestionan servicios, redes, y volÃºmenes en cluster

**Comando:**
```bash
docker stack deploy -c docker-compose.yml myapp
```

**Ventajas:**
- Misma configuraciÃ³n que desarrollo
- Despliegue declarativo
- Rollbacks sencillos
:::

::: {.column width="40%"}
```{mermaid}
graph TB
    A[docker-compose.yml] --> B[Stack Deploy]
    B --> C[Swarm Cluster]
    C --> D[Servicios distribuidos]
    
    style B fill:#c8e6c9
```
:::
:::

---

## Health Checks en orquestaciÃ³n

::: {.columns}
::: {.column width="60%}
**Problema:** Â¿CÃ³mo sabe el orquestador si un servicio estÃ¡ sano?

**SoluciÃ³n:** Health checks
```yaml
services:
  web:
    image: nginx
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 30s
      timeout: 10s
      retries: 3
```

**Comportamiento:**
- Swarm rerutea trÃ¡fico lejos de instancias enfermas
- Compose puede esperar a que los servicios estÃ©n listos
:::

::: {.column width="40%"}
```{mermaid}
graph LR
    A[Health Check] --> B[âœ… Healthy]
    A --> C[âŒ Unhealthy]
    
    B --> D[Recibe trÃ¡fico]
    C --> E[No recibe trÃ¡fico]
    
    style B fill:#c8e6c9
    style C fill:#ffcdd2
```
:::
:::

---

## Patrones comunes de orquestaciÃ³n

::: {.columns}
::: {.column width="50%}
**1. AplicaciÃ³n web tradicional:**
```{mermaid}
graph TB
    A[Load Balancer] --> B[Web Servers]
    B --> C[App Servers]
    C --> D[Database]
```

**2. Microservicios:**
```{mermaid}
graph LR
    A[API Gateway] --> B[Service A]
    A --> C[Service B]
    A --> D[Service C]
```
:::

::: {.column width="50%"}
**3. Worker queues:**
```{mermaid}
graph TB
    A[API] --> B[Message Queue]
    B --> C[Workers]
```

**4. Batch processing:**
```{mermaid}
graph LR
    A[Scheduler] --> B[Batch Jobs]
```
:::
:::

---

## Configuraciones y secretos

::: {.columns}
::: {.column width="60%}
**Problema:** CÃ³mo manejar configuraciones sensibles

**SoluciÃ³n:**
- **Configs:** Archivos de configuraciÃ³n no sensibles
- **Secrets:** InformaciÃ³n sensible (passwords, API keys)

**En Swarm:**
```yaml
services:
  app:
    configs:
      - app_config
    secrets:
      - db_password

configs:
  app_config:
    file: ./config.yml

secrets:
  db_password:
    file: ./db_password.txt
```
:::

::: {.column width="40%"}
```{mermaid}
graph TB
    A[Configs] --> B[Read-only en contenedores]
    C[Secrets] --> D[Encriptados en reposo]
    
    style C fill:#ffebee
```
:::
:::

---

## Buenas prÃ¡cticas de orquestaciÃ³n

**Desarrollo:**
- Usa Compose para entorno local
- Perfiles para diferentes configuraciones
- Variables de entorno para diferencias entre entornos

**ProducciÃ³n:**
- Health checks en todos los servicios
- LÃ­mites de recursos (CPU, memoria)
- Estrategias de despliegue (rolling updates)
- Logs centralizados y monitoreo

**En resumen:**

1. **Separa entornos**: usa `docker-compose.dev.yml`, `docker-compose.test.yml`
2. **No expongas puertos innecesarios** al host (solo lo que necesites acceder desde fuera)
3. **Usa nombres descriptivos** para servicios y volÃºmenes
4. **Versiona tu `docker-compose.yml`** en Git (Â¡pero no el `.env`!)
5. **Documenta** en comentarios lo que hace cada servicio


---

## Flujo de trabajo tÃ­pico

```{mermaid}
graph LR
    A[Desarrollo] --> B[Compose Local]
    B --> C[Testing]
    C --> D[CI/CD]
    D --> E[Registry]
    E --> F[Swarm Production]
    
    style A fill:#e1f5fe
    style F fill:#c8e6c9
```

**Consistencia:** Misma configuraciÃ³n en todos los entornos

---

## Resumen: Docker Compose

| CaracterÃ­stica | Beneficio |
|----------------|-----------|
| **Archivo YAML** | ConfiguraciÃ³n versionable |
| **Servicios** | Aplicaciones multi-contenedor |
| **Redes automÃ¡ticas** | ComunicaciÃ³n simplificada |
| **Dependencias** | Orden de inicio controlado |

---

## Resumen: OrquestaciÃ³n avanzada

| Concepto | PropÃ³sito |
|----------|-----------|
| **Docker Swarm** | OrquestaciÃ³n multi-host |
| **Services** | Aplicaciones escalables |
| **Stacks** | Deploys con Compose files |
| **Health Checks** | Monitoreo y auto-recovery |

---

## EvoluciÃ³n natural

```{mermaid}
graph TB
    A[Contenedores simples] --> B[Docker Compose]
    B --> C[Multi-contenedor apps]
    C --> D[Docker Swarm]
    D --> E[ProducciÃ³n enterprise]
    
    style B fill:#e1f5fe
    style D fill:#c8e6c9
```

**Tu viaje:** De contenedores individuales a aplicaciones complejas orquestadas

---

## Â¡Preparados para el siguiente nivel!

**Lo que hemos cubierto:**
- Fundamentos de Docker Compose
- OrquestaciÃ³n de aplicaciones multi-contenedor
- Diferencias entre desarrollo y producciÃ³n
- IntroducciÃ³n a Docker Swarm

---

## Â¿QuÃ© sigue?

- Laboratorio prÃ¡ctico: Â¡crearemos una app con frontend, backend y base de datos!
- Profundizaremos en:
  - Health checks
  - Perfiles (`profiles`)
  - Sobrescritura de archivos (`-f`)
  - IntegraciÃ³n con Docker Swarm (opcional)

> ğŸ§  Recuerda: **la orquestaciÃ³n empieza con entender los bloques**.  
> Â¡Y tÃº ya tienes los tuyos!

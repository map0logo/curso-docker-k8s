---
title: Docker Compose
subtitle: OrquestaciÃ³n de aplicaciones con mÃºltiples contenedores
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png

---

# Docker Compose y OrquestaciÃ³n de aplicaciones con mÃºltiples contenedores

---

## El problema: Aplicaciones multi-contenedor


**Â¿Te ha pasado esto?**

```bash
docker run -d --name db -v db_data:/data mysql
docker run -d --name web -p 80:80 --link db nginx
docker run -d --name cache --link db redis
docker run -d --name app --link db --link web --link cache nodejs
```

**Problemas:**

- Comandos largos y complejos
- Dependencias difÃ­ciles de gestionar
- Orden de inicio crÃ­tico
- ConfiguraciÃ³n dispersa


```{{mermaid}}
graph TB
    A[MySQL] --> B[Â¿IniciÃ³ primero?]
    C[Redis] --> D[Â¿Depende de MySQL?]
    E[Nginx] --> F[Â¿Puertos conflictivos?]
    G[Node.js] --> H[Â¿Enlaces correctos?]
    
    style B fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
    style H fill:#ffebee
```

**SoluciÃ³n necesaria:** OrquestaciÃ³n simplificada

Imagina que cada contenedor es un mÃºsico:  
uno toca la guitarra (la base de datos), otro la baterÃ­a (el backend), y otro el teclado (el frontend).  
**Docker Compose** es el director que los hace tocar juntos en armonÃ­a.

---

## Â¿QuÃ© es la orquestaciÃ³n de contenedores?

### El problema del â€œmodo manualâ€

Cuando trabajas con mÃºltiples contenedores:

- Cada uno tiene su **propia configuraciÃ³n** (puertos, volÃºmenes, variables)
- Necesitan **comunicarse entre sÃ­**
- Debes gestionar su **ciclo de vida** (iniciar, detener, reiniciar)
- El orden de inicio **importa** (Â¡la DB debe estar lista antes que la app!)

> ğŸ§© **OrquestaciÃ³n = automatizar la coordinaciÃ³n de mÃºltiples contenedores**  
> como si fueran una sola aplicaciÃ³n.

---

## Â¿QuÃ© es Docker Compose?


**DefiniciÃ³n:**

- Herramienta para definir y ejecutar aplicaciones multi-contenedor
- Usa un archivo YAML para configurar los servicios
- Gestiona el ciclo de vida completo de la aplicaciÃ³n

**AnalogÃ­a:**

- Como un "director de orquesta" para contenedores
- Partitura (docker-compose.yml) â†’ MÃºsica (aplicaciÃ³n ejecutÃ¡ndose)

> ğŸ¼ **Piensa en `docker-compose.yml` como una partitura musical**:

> Define quÃ© â€œinstrumentosâ€ (servicios) tocan, cÃ³mo se conectan y quÃ© â€œnotasâ€ (configuraciones) usan.

---


**Beneficios clave:**

- Una sola command para levantar toda la app
- ConfiguraciÃ³n versionable
- Reproducible en cualquier entorno

```{mermaid}
graph TB
    A[docker-compose.yml] --> B[Docker Compose]
    B --> C[Redes]
    B --> D[VolÃºmenes]
    B --> E[Contenedores]
    
    C --> F[AplicaciÃ³n ejecutÃ¡ndose]
    D --> F
    E --> F
```

---

## Â¿Por quÃ© necesitamos Docker Compose?

- **Docker solo** maneja **un contenedor a la vez**.
- Las aplicaciones reales usan **mÃºltiples servicios**:  
  - Base de datos
  - API
  - Frontend
  - Cache
  - Colas de mensajes
- Sin Compose:  
  ```bash
  docker run -d --name db postgres
  docker run -d --name redis redis
  docker run -d --name api --link db --link redis my-api
  docker run -d --name web --link api my-web
  ```
  ğŸ˜µâ€ğŸ’« Â¡Demasiado manual y propenso a errores!

---

## AnatomÃ­a de docker-compose.yml

```yaml
version: '3.8'
services:
  web:
    image: nginx:alpine
    ports:
      - "80:80"
    depends_on:
      - app

  app:
    build: ./app
    environment:
      - DATABASE_URL=postgresql://db:5432
    depends_on:
      - database

  database:
    image: postgres:13
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```
---

### ğŸ”‘ **Tres bloques clave**:  

> 1. **`services`**: tus contenedores (microservicios)
> 2. **`volumes`**: almacenamiento persistente
> 3. **`networks`**: cÃ³mo se comunican entre sÃ­

---

## Conceptos fundamentales de Compose

```{mermaid}
graph TB
    A[Compose Concepts] --> B[Services]
    A --> C[Networks]
    A --> D[Volumes]
    A --> E[Dependencies]
    
    B --> F[Contenedores que forman la app]
    C --> G[ComunicaciÃ³n entre servicios]
    D --> H[Almacenamiento persistente]
    E --> I[Orden de inicio]
    
    style B fill:#e3f2fd
    style C fill:#e8f5e8
    style D fill:#fff3e0
```

---

### Cada servicio = un contenedor

```yaml
services:
  api:
    build: ./fastapi-app        # o 'image: mi-api:latest'
    ports:
      - "8000:8000"
    environment:
      - DB_HOST=db
      - DB_USER=postgres
    depends_on:
      - db
    networks:
      - app_net
```

> ğŸ’¡ **Claves importantes**:
> - **`depends_on`**: asegura que `db` se inicie antes que `api`  
>   (Â¡pero no espera a que estÃ© "listo"! Solo a que el contenedor arranque)
> - **`DB_HOST=db`**: usa el **nombre del servicio** como hostname â†’ Â¡gracias a la red de Compose!

---


## Services: El corazÃ³n de Compose


**Â¿QuÃ© es un servicio?**

- DefiniciÃ³n de cÃ³mo debe ejecutarse un contenedor
- Puede tener mÃºltiples instancias (rÃ©plicas)
- ConfiguraciÃ³n centralizada

**Configuraciones comunes:**

- `image` o `build`
- `ports` y `expose`
- `environment` y `env_file`
- `volumes` y `networks`
- `depends_on` para dependencias


```{mermaid}
graph LR
    A[Service Definition] --> B[1..N Instances]
    B --> C[Container 1]
    B --> D[Container 2]
    B --> E[Container N]
    
    style A fill:#f3e5f5
```


**Ejemplo:** `web`, `api`, `database`, `cache` son servicios

---

## Redes: Â¿CÃ³mo se comunican los contenedores?


**Comportamiento por defecto:**

- Docker Compose crea una red privada para tus servicios.
- DNS automÃ¡tico usando nombres de servicio
- Tu API puede llamar a `http://db:5432` sin saber la IP.
- Puedes definir redes personalizadas si necesitas aislar grupos de otras aplicaciones


**ComunicaciÃ³n simplificada:**

```yaml
# web puede conectar a "db:5432"
# sin conocer la IP real
```

```{mermaid}
graph LR
  A[Frontend] -->|http://api:3000| B(API)
  B -->|db:5432| C[(Base de Datos)]
  B -->|redis:6379| D[(Redis Cache)]
```

âœ… ComunicaciÃ³n segura, sin exponer puertos al host.


```{mermaid}
graph TB
    A[compose-app_default] --> B[web]
    A --> C[app]
    A --> D[database]
    A --> E[cache]
    
    B --> F[Resuelve: app]
    B --> G[Resuelve: database]
    C --> H[Resuelve: cache]
    
    style A fill:#e8f5e8
```

---

## Dependencias y orden de inicio de los servicios


**`depends_on`:**

- Controla el orden de inicio
- No espera que el servicio estÃ© "listo"
- Solo garantiza quÃ© se inicia despuÃ©s

**Problema comÃºn:**

- La DB se inicia, pero tarda en aceptar conexiones
- La app falla porque intenta conectar demasiado pronto

> âš ï¸ **Importante**: `depends_on` **no espera a que el servicio estÃ© "listo"**, solo que se haya iniciado.

**SoluciÃ³n avanzada:**

- Healthchecks
- Scripts de espera personalizados


```{mermaid}
graph LR
    A[database] --> B[app]
    B --> C[web]
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style C fill:#ffccbc
```

```yaml
services:
  web:
    depends_on:
      - app
  app:
    depends_on:
      - database
```
---

## Variables de entorno y configuraciones

**Flexibilidad con variables:**

```yaml
services:
  database:
    image: postgres:${POSTGRES_VERSION:-13}
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
```

> ğŸ” Usa archivos `.env` para valores sensibles:

```env
DB_PASS=supersecreto123
API_KEY=abc123
```

Compose los carga **automÃ¡ticamente** si existe un `.env` en la misma carpeta.

**Archivos de entorno:**

- `.env` (automÃ¡tico)
- `env_file:` especÃ­fico por servicio

**Beneficio:** 

Diferentes configuraciones por entorno


```{mermaid}
graph TB
    A[.env file] --> B[Compose Interpolation]
    C[env_file:] --> B
    B --> D[Final Configuration]
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
```

---

## VolÃºmenes y persistencia en Compose


**Tipos de volÃºmenes:**

- **Named volumes:** Gestionados por Docker
- **Bind mounts:** Directorios del host
- **Anonymous volumes:** Temporales

**En Compose:**

```yaml
services:
  database:
    volumes:
      - db_data:/var/lib/data
      - ./config:/app/config

volumes:
  db_data:
```

```{mermaid}
graph TB
    A[Named Volume] --> B[Persiste entre deploys]
    C[Bind Mount] --> D[Desarrollo]
    E[Anonymous] --> F[Temporal]
    
    style A fill:#c8e6c9
    style C fill:#fff3e0
```


ğŸ—ƒï¸ El volumen `db_data` vive **mÃ¡s allÃ¡** del ciclo de vida del contenedor.

---

## Escalando servicios

Con Compose puedes **escalar servicios** fÃ¡cilmente:

```bash
docker-compose up --scale api=3
```
---

> ğŸ» Ahora tienes **3 instancias del API** corriendo simultÃ¡neamente.  
> (Ideal para pruebas de carga o balanceo simple)

> âš ï¸ Pero: Compose **no es un orquestador de producciÃ³n** como Kubernetes.  
> Es para desarrollo, pruebas y entornos simples.

---


**Escala horizontal simple:**

```bash
docker-compose up --scale web=3 --scale api=2
```

**LÃ­mites:**

- Compose no hace load balancing
- Ãštil para desarrollo y testing
- ProducciÃ³n necesita mÃ¡s herramientas

**Caso de uso tÃ­pico:**

- Probar cÃ³mo se comporta la app con mÃºltiples instancias
- Desarrollo de caracterÃ­sticas de concurrencia


```{mermaid}
graph TB
    A[web] --> B[web_1]
    A --> C[web_2]
    A --> D[web_3]
    
    E[api] --> F[api_1]
    E --> G[api_2]
    
    style A fill:#f3e5f5
    style E fill:#e1f5fe
```


---

## Perfiles: Organizando servicios


**Para diferentes contextos:**

```yaml
services:
  frontend:
    profiles: ["frontend"]
    
  backend:
    profiles: ["backend"]
    
  database:
    profiles: ["database", "production"]
    
  debug-tools:
    profiles: ["development"]
```

**Uso:**

```bash
docker-compose --profile frontend up
docker-compose --profile development up
```


```{mermaid}
graph TB
    A[Perfiles] --> B[Development]
    A --> C[Production]
    A --> D[Testing]
    
    B --> E[Servicios de debug]
    C --> F[Servicios optimizados]
    D --> G[Servicios de test]
```


---

## Docker Compose vs Docker Swarm


**Docker Compose:**

- Single-host
- Desarrollo y testing
- ConfiguraciÃ³n simple
- Comandos directos

**Docker Swarm:**

- Multi-host
- ProducciÃ³n
- Alta disponibilidad
- Escalado automÃ¡tico


```{mermaid}
graph TB
    A[Compose] --> B[1 Host]
    B --> C[App Completa]
    
    D[Swarm] --> E[MÃºltiples Hosts]
    E --> F[Cluster]
    F --> G[Alta Disponibilidad]
    
    style A fill:#e1f5fe
    style D fill:#c8e6c9
```

---

## IntroducciÃ³n a Docker Swarm


**Â¿QuÃ© es?**

- OrquestaciÃ³n nativa de Docker
- Convierte mÃºltiples hosts en un cluster
- Gestiona despliegues, escalado, y alta disponibilidad

**Conceptos clave:**

- **Manager nodes:** Gestionan el cluster
- **Worker nodes:** Ejecutan los contenedores
- **Services:** Aplicaciones escalables
- **Stacks:** Deploys con Compose files


```{mermaid}
graph TB
    A[Manager] --> B[Worker 1]
    A --> C[Worker 2]
    A --> D[Worker 3]
    
    B --> E[Contenedores]
    C --> E
    D --> E
    
    style A fill:#ffccbc
```


---

## Servicios en Swarm Mode


**Diferencias con Compose:**

- Servicios distribuidos en mÃºltiples nodos
- Escalado automÃ¡tico
- Load balancing integrado
- Health checks y auto-recovery

**Ejemplo:**

```bash
docker service create --name web --replicas 3 nginx
```


```{mermaid}
graph TB
    A[Service: web] --> B[Replica 1]
    A --> C[Replica 2]
    A --> D[Replica 3]
    
    B --> E[Node A]
    C --> F[Node B]
    D --> G[Node C]
    
    style A fill:#f3e5f5
```

---

## Stacks: Compose en producciÃ³n


**Â¿QuÃ© son?**

- Deploys de aplicaciones multi-servicio en Swarm
- Usan archivos docker-compose.yml mejorados
- Gestionan servicios, redes, y volÃºmenes en cluster

**Comando:**

```bash
docker stack deploy -c docker-compose.yml myapp
```

**Ventajas:**

- Misma configuraciÃ³n que desarrollo
- Despliegue declarativo
- Rollbacks sencillos


```{mermaid}
graph TB
    A[docker-compose.yml] --> B[Stack Deploy]
    B --> C[Swarm Cluster]
    C --> D[Servicios distribuidos]
    
    style B fill:#c8e6c9
```


---

## Health Checks en orquestaciÃ³n


**Problema:** Â¿CÃ³mo sabe el orquestador si un servicio estÃ¡ sano?

**SoluciÃ³n:** Health checks

```yaml
services:
  web:
    image: nginx
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 30s
      timeout: 10s
      retries: 3
```

**Comportamiento:**

- Swarm rerutea trÃ¡fico lejos de instancias enfermas
- Compose puede esperar a que los servicios estÃ©n listos


```{mermaid}
graph LR
    A[Health Check] --> B[âœ… Healthy]
    A --> C[âŒ Unhealthy]
    
    B --> D[Recibe trÃ¡fico]
    C --> E[No recibe trÃ¡fico]
    
    style B fill:#c8e6c9
    style C fill:#ffcdd2
```


---

## Patrones comunes de orquestaciÃ³n

**1. AplicaciÃ³n web tradicional:**

```{mermaid}
graph TB
    A[Load Balancer] --> B[Web Servers]
    B --> C[App Servers]
    C --> D[Database]
```

**2. Microservicios:**

```{mermaid}
graph LR
    A[API Gateway] --> B[Service A]
    A --> C[Service B]
    A --> D[Service C]
```

**3. Worker queues:**

```{mermaid}
graph TB
    A[API] --> B[Message Queue]
    B --> C[Workers]
```

**4. Batch processing:**

```{mermaid}
graph LR
    A[Scheduler] --> B[Batch Jobs]
```

---

## Configuraciones y secretos


**Problema:** CÃ³mo manejar configuraciones sensibles

**SoluciÃ³n:**

- **Configs:** Archivos de configuraciÃ³n no sensibles
- **Secrets:** InformaciÃ³n sensible (passwords, API keys)

**En Swarm:**

```yaml
services:
  app:
    configs:
      - app_config
    secrets:
      - db_password

configs:
  app_config:
    file: ./config.yml

secrets:
  db_password:
    file: ./db_password.txt
```

```{mermaid}
graph TB
    A[Configs] --> B[Read-only en contenedores]
    C[Secrets] --> D[Encriptados en reposo]
    
    style C fill:#ffebee
```

---

## Buenas prÃ¡cticas de orquestaciÃ³n

**Desarrollo:**

- Usa Compose para entorno local
- Perfiles para diferentes configuraciones
- Variables de entorno para diferencias entre entornos

**ProducciÃ³n:**

- Health checks en todos los servicios
- LÃ­mites de recursos (CPU, memoria)
- Estrategias de despliegue (rolling updates)
- Logs centralizados y monitoreo

**En resumen:**

1. **Separa entornos**: usa `docker-compose.dev.yml`, `docker-compose.test.yml`
2. **No expongas puertos innecesarios** al host (solo lo que necesites acceder desde fuera)
3. **Usa nombres descriptivos** para servicios y volÃºmenes
4. **Versiona tu `docker-compose.yml`** en Git (Â¡pero no el `.env`!)
5. **Documenta** en comentarios lo que hace cada servicio


---

## Flujo de trabajo tÃ­pico

```{mermaid}
graph LR
    A[Desarrollo] --> B[Compose Local]
    B --> C[Testing]
    C --> D[CI/CD]
    D --> E[Registry]
    E --> F[Swarm Production]
    
    style A fill:#e1f5fe
    style F fill:#c8e6c9
```

**Consistencia:** Misma configuraciÃ³n en todos los entornos

---

## Resumen: Docker Compose

| CaracterÃ­stica | Beneficio |
|----------------|-----------|
| **Archivo YAML** | ConfiguraciÃ³n versionable |
| **Servicios** | Aplicaciones multi-contenedor |
| **Redes automÃ¡ticas** | ComunicaciÃ³n simplificada |
| **Dependencias** | Orden de inicio controlado |

---

## Resumen: OrquestaciÃ³n avanzada

| Concepto | PropÃ³sito |
|----------|-----------|
| **Docker Swarm** | OrquestaciÃ³n multi-host |
| **Services** | Aplicaciones escalables |
| **Stacks** | Deploys con Compose files |
| **Health Checks** | Monitoreo y auto-recovery |

---

## EvoluciÃ³n natural

```{mermaid}
graph TB
    A[Contenedores simples] --> B[Docker Compose]
    B --> C[Multi-contenedor apps]
    C --> D[Docker Swarm]
    D --> E[ProducciÃ³n enterprise]
    
    style B fill:#e1f5fe
    style D fill:#c8e6c9
```

**Tu viaje:** De contenedores individuales a aplicaciones complejas orquestadas

---

## Flujo de trabajo ideal con Compose

**Es un ciclo rÃ¡pido, repetible y consistente**, perfecto para equipos.

```{mermaid}
flowchart LR
  A[Editar docker-compose.yml] --> B[docker-compose up -d]
  B --> C[Desarrollar y probar]
  C --> D[docker-compose logs -f]
  D --> E[Debuggear con docker-compose exec]
  E --> F[docker-compose down]
  F -->|Opcional| G[docker-compose down -v\n(borra volÃºmenes)]
```

---

## Buenas prÃ¡cticas con Docker Compose

### 1. Usa `depends_on` con cuidado

- Solo controla el **orden de inicio**, no la â€œdisponibilidadâ€ del servicio.
- Para esperar a que una DB estÃ© lista, usa scripts de `healthcheck` o herramientas como `wait-for-it`.

### 2. Nombra tus recursos

- Compose genera nombres como `miapp_db_1` â†’ pero si defines `container_name`, pierdes escalabilidad.
- **Mejor no usar `container_name`** â†’ deja que Compose gestione los nombres.

### 3. Separa entornos

- Usa `.env` para variables sensibles o por entorno:
  ```env
  DB_PASSWORD=supersecreto
  API_PORT=8000
  ```
- ReferÃ©ncialas en `docker-compose.yml` con `${DB_PASSWORD}`

> ğŸ§¼ **MantÃ©n tu `docker-compose.yml` limpio, declarativo y versionable**.

---

## Â¿QuÃ© NO hacer con Compose?

| âŒ Mal | âœ… Bien |
|--------|--------|
| Usar `container_name` innecesariamente | Dejar que Compose gestione nombres |
| Hardcodear contraseÃ±as en el YAML | Usar variables de entorno o archivos `.env` |
| Olvidar `depends_on` cuando el orden importa | Definir dependencias explÃ­citas |
| Usar Compose en producciÃ³n sin considerar alternativas | Usar Compose solo para desarrollo/local |

> âš ï¸ **Compose es para desarrollo/local** â†’ en producciÃ³n, considera Kubernetes, Swarm o plataformas cloud.

---

## Resumen visual: Tu stack en un solo archivo

```{mermaid}
graph TD
  ComposeFile["docker-compose.yml"] --> ServicioAPI["api:\n  build: ./fastapi\n  ports: [8000:8000]\n  environment:\n    - DB_HOST=db"]
  ComposeFile --> ServicioDB["db:\n  image: postgres\n  volumes:\n    - db_data:/var/lib..."]
  ComposeFile --> ServicioPGAdmin["pgadmin:\n  image: dpage/pgadmin4\n  ports: [8080:80]"]
  ServicioAPI --> Red["Red: default (creada por Compose)"]
  ServicioDB --> Red
  ServicioPGAdmin --> Red
  ServicioDB --> Volumen["Volumen: db_data"]
```

> âœ… **Con un solo archivo**:

> - Definiste **3 servicios**  
> - Configuraste **red automÃ¡tica**  
> - AÃ±adiste **persistencia**  
> - Expusiste **puertos controlados**

---

## Â¿QuÃ© sigue?

- Laboratorio prÃ¡ctico: Â¡crearemos una app con frontend, backend y base de datos!
- Profundizaremos en:
  - Health checks
  - Perfiles (`profiles`)
  - Sobrescritura de archivos (`-f`)
  - IntegraciÃ³n con Docker Swarm (opcional)

> ğŸ§  Recuerda: **la orquestaciÃ³n empieza con entender los bloques**.  


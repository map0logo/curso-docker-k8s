---
title: Docker Compose
subtitle: Orquestación de aplicaciones con múltiples contenedores
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png

---

# Docker Compose y Orquestación de aplicaciones con múltiples contenedores

---

## El problema: Aplicaciones multi-contenedor


**¿Te ha pasado esto?**

```bash
docker run -d --name db -v db_data:/data mysql
docker run -d --name web -p 80:80 --link db nginx
docker run -d --name cache --link db redis
docker run -d --name app --link db --link web --link cache nodejs
```

**Problemas:**

- Comandos largos y complejos
- Dependencias difíciles de gestionar
- Orden de inicio crítico
- Configuración dispersa


```{{mermaid}}
graph TB
    A[MySQL] --> B[¿Inició primero?]
    C[Redis] --> D[¿Depende de MySQL?]
    E[Nginx] --> F[¿Puertos conflictivos?]
    G[Node.js] --> H[¿Enlaces correctos?]
    
    style B fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
    style H fill:#ffebee
```

**Solución necesaria:** Orquestación simplificada

Imagina que cada contenedor es un músico:  
uno toca la guitarra (la base de datos), otro la batería (el backend), y otro el teclado (el frontend).  
**Docker Compose** es el director que los hace tocar juntos en armonía.

---

## ¿Qué es la orquestación de contenedores?

### El problema del “modo manual”

Cuando trabajas con múltiples contenedores:

- Cada uno tiene su **propia configuración** (puertos, volúmenes, variables)
- Necesitan **comunicarse entre sí**
- Debes gestionar su **ciclo de vida** (iniciar, detener, reiniciar)
- El orden de inicio **importa** (¡la DB debe estar lista antes que la app!)

> 🧩 **Orquestación = automatizar la coordinación de múltiples contenedores**  
> como si fueran una sola aplicación.

---

## ¿Qué es Docker Compose?


**Definición:**

- Herramienta para definir y ejecutar aplicaciones multi-contenedor
- Usa un archivo YAML para configurar los servicios
- Gestiona el ciclo de vida completo de la aplicación

**Analogía:**

- Como un "director de orquesta" para contenedores
- Partitura (docker-compose.yml) → Música (aplicación ejecutándose)

> 🎼 **Piensa en `docker-compose.yml` como una partitura musical**:

> Define qué “instrumentos” (servicios) tocan, cómo se conectan y qué “notas” (configuraciones) usan.

---


**Beneficios clave:**

- Una sola command para levantar toda la app
- Configuración versionable
- Reproducible en cualquier entorno

```{mermaid}
graph TB
    A[docker-compose.yml] --> B[Docker Compose]
    B --> C[Redes]
    B --> D[Volúmenes]
    B --> E[Contenedores]
    
    C --> F[Aplicación ejecutándose]
    D --> F
    E --> F
```

---

## ¿Por qué necesitamos Docker Compose?

- **Docker solo** maneja **un contenedor a la vez**.
- Las aplicaciones reales usan **múltiples servicios**:  
  - Base de datos
  - API
  - Frontend
  - Cache
  - Colas de mensajes
- Sin Compose:  
  ```bash
  docker run -d --name db postgres
  docker run -d --name redis redis
  docker run -d --name api --link db --link redis my-api
  docker run -d --name web --link api my-web
  ```
  😵‍💫 ¡Demasiado manual y propenso a errores!

---

## Anatomía de docker-compose.yml

```yaml
version: '3.8'
services:
  web:
    image: nginx:alpine
    ports:
      - "80:80"
    depends_on:
      - app

  app:
    build: ./app
    environment:
      - DATABASE_URL=postgresql://db:5432
    depends_on:
      - database

  database:
    image: postgres:13
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```
---

### 🔑 **Tres bloques clave**:  

> 1. **`services`**: tus contenedores (microservicios)
> 2. **`volumes`**: almacenamiento persistente
> 3. **`networks`**: cómo se comunican entre sí

---

## Conceptos fundamentales de Compose

```{mermaid}
graph TB
    A[Compose Concepts] --> B[Services]
    A --> C[Networks]
    A --> D[Volumes]
    A --> E[Dependencies]
    
    B --> F[Contenedores que forman la app]
    C --> G[Comunicación entre servicios]
    D --> H[Almacenamiento persistente]
    E --> I[Orden de inicio]
    
    style B fill:#e3f2fd
    style C fill:#e8f5e8
    style D fill:#fff3e0
```

---

### Cada servicio = un contenedor

```yaml
services:
  api:
    build: ./fastapi-app        # o 'image: mi-api:latest'
    ports:
      - "8000:8000"
    environment:
      - DB_HOST=db
      - DB_USER=postgres
    depends_on:
      - db
    networks:
      - app_net
```

> 💡 **Claves importantes**:
> - **`depends_on`**: asegura que `db` se inicie antes que `api`  
>   (¡pero no espera a que esté "listo"! Solo a que el contenedor arranque)
> - **`DB_HOST=db`**: usa el **nombre del servicio** como hostname → ¡gracias a la red de Compose!

---


## Services: El corazón de Compose


**¿Qué es un servicio?**

- Definición de cómo debe ejecutarse un contenedor
- Puede tener múltiples instancias (réplicas)
- Configuración centralizada

**Configuraciones comunes:**

- `image` o `build`
- `ports` y `expose`
- `environment` y `env_file`
- `volumes` y `networks`
- `depends_on` para dependencias


```{mermaid}
graph LR
    A[Service Definition] --> B[1..N Instances]
    B --> C[Container 1]
    B --> D[Container 2]
    B --> E[Container N]
    
    style A fill:#f3e5f5
```


**Ejemplo:** `web`, `api`, `database`, `cache` son servicios

---

## Redes: ¿Cómo se comunican los contenedores?


**Comportamiento por defecto:**

- Docker Compose crea una red privada para tus servicios.
- DNS automático usando nombres de servicio
- Tu API puede llamar a `http://db:5432` sin saber la IP.
- Puedes definir redes personalizadas si necesitas aislar grupos de otras aplicaciones


**Comunicación simplificada:**

```yaml
# web puede conectar a "db:5432"
# sin conocer la IP real
```

```{mermaid}
graph LR
  A[Frontend] -->|http://api:3000| B(API)
  B -->|db:5432| C[(Base de Datos)]
  B -->|redis:6379| D[(Redis Cache)]
```

✅ Comunicación segura, sin exponer puertos al host.


```{mermaid}
graph TB
    A[compose-app_default] --> B[web]
    A --> C[app]
    A --> D[database]
    A --> E[cache]
    
    B --> F[Resuelve: app]
    B --> G[Resuelve: database]
    C --> H[Resuelve: cache]
    
    style A fill:#e8f5e8
```

---

## Dependencias y orden de inicio de los servicios


**`depends_on`:**

- Controla el orden de inicio
- No espera que el servicio esté "listo"
- Solo garantiza qué se inicia después

**Problema común:**

- La DB se inicia, pero tarda en aceptar conexiones
- La app falla porque intenta conectar demasiado pronto

> ⚠️ **Importante**: `depends_on` **no espera a que el servicio esté "listo"**, solo que se haya iniciado.

**Solución avanzada:**

- Healthchecks
- Scripts de espera personalizados


```{mermaid}
graph LR
    A[database] --> B[app]
    B --> C[web]
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style C fill:#ffccbc
```

```yaml
services:
  web:
    depends_on:
      - app
  app:
    depends_on:
      - database
```
---

## Variables de entorno y configuraciones

**Flexibilidad con variables:**

```yaml
services:
  database:
    image: postgres:${POSTGRES_VERSION:-13}
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
```

> 🔐 Usa archivos `.env` para valores sensibles:

```env
DB_PASS=supersecreto123
API_KEY=abc123
```

Compose los carga **automáticamente** si existe un `.env` en la misma carpeta.

**Archivos de entorno:**

- `.env` (automático)
- `env_file:` específico por servicio

**Beneficio:** 

Diferentes configuraciones por entorno


```{mermaid}
graph TB
    A[.env file] --> B[Compose Interpolation]
    C[env_file:] --> B
    B --> D[Final Configuration]
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
```

---

## Volúmenes y persistencia en Compose


**Tipos de volúmenes:**

- **Named volumes:** Gestionados por Docker
- **Bind mounts:** Directorios del host
- **Anonymous volumes:** Temporales

**En Compose:**

```yaml
services:
  database:
    volumes:
      - db_data:/var/lib/data
      - ./config:/app/config

volumes:
  db_data:
```

```{mermaid}
graph TB
    A[Named Volume] --> B[Persiste entre deploys]
    C[Bind Mount] --> D[Desarrollo]
    E[Anonymous] --> F[Temporal]
    
    style A fill:#c8e6c9
    style C fill:#fff3e0
```


🗃️ El volumen `db_data` vive **más allá** del ciclo de vida del contenedor.

---

## Escalando servicios

Con Compose puedes **escalar servicios** fácilmente:

```bash
docker-compose up --scale api=3
```
---

> 🎻 Ahora tienes **3 instancias del API** corriendo simultáneamente.  
> (Ideal para pruebas de carga o balanceo simple)

> ⚠️ Pero: Compose **no es un orquestador de producción** como Kubernetes.  
> Es para desarrollo, pruebas y entornos simples.

---


**Escala horizontal simple:**

```bash
docker-compose up --scale web=3 --scale api=2
```

**Límites:**

- Compose no hace load balancing
- Útil para desarrollo y testing
- Producción necesita más herramientas

**Caso de uso típico:**

- Probar cómo se comporta la app con múltiples instancias
- Desarrollo de características de concurrencia


```{mermaid}
graph TB
    A[web] --> B[web_1]
    A --> C[web_2]
    A --> D[web_3]
    
    E[api] --> F[api_1]
    E --> G[api_2]
    
    style A fill:#f3e5f5
    style E fill:#e1f5fe
```


---

## Perfiles: Organizando servicios


**Para diferentes contextos:**

```yaml
services:
  frontend:
    profiles: ["frontend"]
    
  backend:
    profiles: ["backend"]
    
  database:
    profiles: ["database", "production"]
    
  debug-tools:
    profiles: ["development"]
```

**Uso:**

```bash
docker-compose --profile frontend up
docker-compose --profile development up
```


```{mermaid}
graph TB
    A[Perfiles] --> B[Development]
    A --> C[Production]
    A --> D[Testing]
    
    B --> E[Servicios de debug]
    C --> F[Servicios optimizados]
    D --> G[Servicios de test]
```


---

## Docker Compose vs Docker Swarm


**Docker Compose:**

- Single-host
- Desarrollo y testing
- Configuración simple
- Comandos directos

**Docker Swarm:**

- Multi-host
- Producción
- Alta disponibilidad
- Escalado automático


```{mermaid}
graph TB
    A[Compose] --> B[1 Host]
    B --> C[App Completa]
    
    D[Swarm] --> E[Múltiples Hosts]
    E --> F[Cluster]
    F --> G[Alta Disponibilidad]
    
    style A fill:#e1f5fe
    style D fill:#c8e6c9
```

---

## Introducción a Docker Swarm


**¿Qué es?**

- Orquestación nativa de Docker
- Convierte múltiples hosts en un cluster
- Gestiona despliegues, escalado, y alta disponibilidad

**Conceptos clave:**

- **Manager nodes:** Gestionan el cluster
- **Worker nodes:** Ejecutan los contenedores
- **Services:** Aplicaciones escalables
- **Stacks:** Deploys con Compose files


```{mermaid}
graph TB
    A[Manager] --> B[Worker 1]
    A --> C[Worker 2]
    A --> D[Worker 3]
    
    B --> E[Contenedores]
    C --> E
    D --> E
    
    style A fill:#ffccbc
```


---

## Servicios en Swarm Mode


**Diferencias con Compose:**

- Servicios distribuidos en múltiples nodos
- Escalado automático
- Load balancing integrado
- Health checks y auto-recovery

**Ejemplo:**

```bash
docker service create --name web --replicas 3 nginx
```


```{mermaid}
graph TB
    A[Service: web] --> B[Replica 1]
    A --> C[Replica 2]
    A --> D[Replica 3]
    
    B --> E[Node A]
    C --> F[Node B]
    D --> G[Node C]
    
    style A fill:#f3e5f5
```

---

## Stacks: Compose en producción


**¿Qué son?**

- Deploys de aplicaciones multi-servicio en Swarm
- Usan archivos docker-compose.yml mejorados
- Gestionan servicios, redes, y volúmenes en cluster

**Comando:**

```bash
docker stack deploy -c docker-compose.yml myapp
```

**Ventajas:**

- Misma configuración que desarrollo
- Despliegue declarativo
- Rollbacks sencillos


```{mermaid}
graph TB
    A[docker-compose.yml] --> B[Stack Deploy]
    B --> C[Swarm Cluster]
    C --> D[Servicios distribuidos]
    
    style B fill:#c8e6c9
```


---

## Health Checks en orquestación


**Problema:** ¿Cómo sabe el orquestador si un servicio está sano?

**Solución:** Health checks

```yaml
services:
  web:
    image: nginx
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 30s
      timeout: 10s
      retries: 3
```

**Comportamiento:**

- Swarm rerutea tráfico lejos de instancias enfermas
- Compose puede esperar a que los servicios estén listos


```{mermaid}
graph LR
    A[Health Check] --> B[✅ Healthy]
    A --> C[❌ Unhealthy]
    
    B --> D[Recibe tráfico]
    C --> E[No recibe tráfico]
    
    style B fill:#c8e6c9
    style C fill:#ffcdd2
```


---

## Patrones comunes de orquestación

**1. Aplicación web tradicional:**

```{mermaid}
graph TB
    A[Load Balancer] --> B[Web Servers]
    B --> C[App Servers]
    C --> D[Database]
```

**2. Microservicios:**

```{mermaid}
graph LR
    A[API Gateway] --> B[Service A]
    A --> C[Service B]
    A --> D[Service C]
```

**3. Worker queues:**

```{mermaid}
graph TB
    A[API] --> B[Message Queue]
    B --> C[Workers]
```

**4. Batch processing:**

```{mermaid}
graph LR
    A[Scheduler] --> B[Batch Jobs]
```

---

## Configuraciones y secretos


**Problema:** Cómo manejar configuraciones sensibles

**Solución:**

- **Configs:** Archivos de configuración no sensibles
- **Secrets:** Información sensible (passwords, API keys)

**En Swarm:**

```yaml
services:
  app:
    configs:
      - app_config
    secrets:
      - db_password

configs:
  app_config:
    file: ./config.yml

secrets:
  db_password:
    file: ./db_password.txt
```

```{mermaid}
graph TB
    A[Configs] --> B[Read-only en contenedores]
    C[Secrets] --> D[Encriptados en reposo]
    
    style C fill:#ffebee
```

---

## Buenas prácticas de orquestación

**Desarrollo:**

- Usa Compose para entorno local
- Perfiles para diferentes configuraciones
- Variables de entorno para diferencias entre entornos

**Producción:**

- Health checks en todos los servicios
- Límites de recursos (CPU, memoria)
- Estrategias de despliegue (rolling updates)
- Logs centralizados y monitoreo

**En resumen:**

1. **Separa entornos**: usa `docker-compose.dev.yml`, `docker-compose.test.yml`
2. **No expongas puertos innecesarios** al host (solo lo que necesites acceder desde fuera)
3. **Usa nombres descriptivos** para servicios y volúmenes
4. **Versiona tu `docker-compose.yml`** en Git (¡pero no el `.env`!)
5. **Documenta** en comentarios lo que hace cada servicio


---

## Flujo de trabajo típico

```{mermaid}
graph LR
    A[Desarrollo] --> B[Compose Local]
    B --> C[Testing]
    C --> D[CI/CD]
    D --> E[Registry]
    E --> F[Swarm Production]
    
    style A fill:#e1f5fe
    style F fill:#c8e6c9
```

**Consistencia:** Misma configuración en todos los entornos

---

## Resumen: Docker Compose

| Característica | Beneficio |
|----------------|-----------|
| **Archivo YAML** | Configuración versionable |
| **Servicios** | Aplicaciones multi-contenedor |
| **Redes automáticas** | Comunicación simplificada |
| **Dependencias** | Orden de inicio controlado |

---

## Resumen: Orquestación avanzada

| Concepto | Propósito |
|----------|-----------|
| **Docker Swarm** | Orquestación multi-host |
| **Services** | Aplicaciones escalables |
| **Stacks** | Deploys con Compose files |
| **Health Checks** | Monitoreo y auto-recovery |

---

## Evolución natural

```{mermaid}
graph TB
    A[Contenedores simples] --> B[Docker Compose]
    B --> C[Multi-contenedor apps]
    C --> D[Docker Swarm]
    D --> E[Producción enterprise]
    
    style B fill:#e1f5fe
    style D fill:#c8e6c9
```

**Tu viaje:** De contenedores individuales a aplicaciones complejas orquestadas

---

## Flujo de trabajo ideal con Compose

**Es un ciclo rápido, repetible y consistente**, perfecto para equipos.

```{mermaid}
flowchart LR
  A[Editar docker-compose.yml] --> B[docker-compose up -d]
  B --> C[Desarrollar y probar]
  C --> D[docker-compose logs -f]
  D --> E[Debuggear con docker-compose exec]
  E --> F[docker-compose down]
  F -->|Opcional| G[docker-compose down -v\n(borra volúmenes)]
```

---

## Buenas prácticas con Docker Compose

### 1. Usa `depends_on` con cuidado

- Solo controla el **orden de inicio**, no la “disponibilidad” del servicio.
- Para esperar a que una DB esté lista, usa scripts de `healthcheck` o herramientas como `wait-for-it`.

### 2. Nombra tus recursos

- Compose genera nombres como `miapp_db_1` → pero si defines `container_name`, pierdes escalabilidad.
- **Mejor no usar `container_name`** → deja que Compose gestione los nombres.

### 3. Separa entornos

- Usa `.env` para variables sensibles o por entorno:
  ```env
  DB_PASSWORD=supersecreto
  API_PORT=8000
  ```
- Referéncialas en `docker-compose.yml` con `${DB_PASSWORD}`

> 🧼 **Mantén tu `docker-compose.yml` limpio, declarativo y versionable**.

---

## ¿Qué NO hacer con Compose?

| ❌ Mal | ✅ Bien |
|--------|--------|
| Usar `container_name` innecesariamente | Dejar que Compose gestione nombres |
| Hardcodear contraseñas en el YAML | Usar variables de entorno o archivos `.env` |
| Olvidar `depends_on` cuando el orden importa | Definir dependencias explícitas |
| Usar Compose en producción sin considerar alternativas | Usar Compose solo para desarrollo/local |

> ⚠️ **Compose es para desarrollo/local** → en producción, considera Kubernetes, Swarm o plataformas cloud.

---

## Resumen visual: Tu stack en un solo archivo

```{mermaid}
graph TD
  ComposeFile["docker-compose.yml"] --> ServicioAPI["api:\n  build: ./fastapi\n  ports: [8000:8000]\n  environment:\n    - DB_HOST=db"]
  ComposeFile --> ServicioDB["db:\n  image: postgres\n  volumes:\n    - db_data:/var/lib..."]
  ComposeFile --> ServicioPGAdmin["pgadmin:\n  image: dpage/pgadmin4\n  ports: [8080:80]"]
  ServicioAPI --> Red["Red: default (creada por Compose)"]
  ServicioDB --> Red
  ServicioPGAdmin --> Red
  ServicioDB --> Volumen["Volumen: db_data"]
```

> ✅ **Con un solo archivo**:

> - Definiste **3 servicios**  
> - Configuraste **red automática**  
> - Añadiste **persistencia**  
> - Expusiste **puertos controlados**

---

## ¿Qué sigue?

- Laboratorio práctico: ¡crearemos una app con frontend, backend y base de datos!
- Profundizaremos en:
  - Health checks
  - Perfiles (`profiles`)
  - Sobrescritura de archivos (`-f`)
  - Integración con Docker Swarm (opcional)

> 🧠 Recuerda: **la orquestación empieza con entender los bloques**.  


---
title: IntroducciÃ³n a Kubernetes
subtitle: Arquitectura, Namespaces y Objetos
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
---

# MÃ³dulo 7: IntroducciÃ³n a Kubernetes

## El Monolito: Una Roca de 1000 Toneladas

### Â¿QuÃ© es un Monolito?

Imagina una aplicaciÃ³n de software como una roca gigante de 1000 toneladas.

- **Todo en uno**: Todo el cÃ³digo de la aplicaciÃ³n estÃ¡ en un solo bloque.
- **Un solo lenguaje**: Normalmente escrito en un solo lenguaje de programaciÃ³n (a veces anticuado).
- **Arquitectura Ãºnica**: Basado en patrones de arquitectura de software que pueden estar obsoletos.

## El Monolito

```{mermaid}
graph TD
    A[Monolito] --> B[LÃ³gica de Negocio A]
    A --> C[LÃ³gica de Negocio B]
    A --> D[LÃ³gica de Negocio C]
    A --> E[Base de Datos Ãšnica]
    B --> F[Servidor Ãšnico]
    C --> F
    D --> F
    E --> F
```

> En el monolito, la lÃ³gica de negocio y la base de datos se encuentran en un **mismo servidor**. Por lo tanto, comparten la **misma memoria** y el **mismo espacio de almacenamiento**. **Cualquier cambio** en cualquiera de estos componentes requiere una **actualizaciÃ³n de todo el monolito**.

## CaracterÃ­sticas del Monolito

- **Crecimiento Continuo**: Cada nueva caracterÃ­stica aÃ±ade mÃ¡s cÃ³digo, aumentando la complejidad.
- **Tiempos de CompilaciÃ³n Largos**: Compilar y construir la aplicaciÃ³n lleva cada vez mÃ¡s tiempo.
- **Facilidad Administrativa (Relativa)**: Se ejecuta en un solo servidor (MÃ¡quina Virtual o Mainframe).

---

## Los Problemas de la Roca Gigante

### 1. Costo de Hardware

- **Sistema Ãšnico y Poderoso**: El monolito necesita un servidor muy grande y costoso para satisfacer todos sus requisitos (CPU, memoria, almacenamiento).
- **Complejo y Costoso**: Este hardware no solo es caro, sino a veces difÃ­cil de conseguir.

### 2. Escalabilidad Limitada

- **Escala Todo o Nada**: No puedes escalar solo la parte de la aplicaciÃ³n que tiene mucha demanda. Tienes que escalar **todo** el monolito.
- **SoluciÃ³n Costosa**: Esto significa desplegar una nueva instancia completa en otro servidor, normalmente detrÃ¡s de un balanceador de carga caro.

## Los Problemas de la Roca Gigante 2

### 3. Mantenimiento y Actualizaciones

```{mermaid}
graph LR
    U[Usuarios] --> LB[Balanceador de Carga<br>Muy Caro]
    LB --> M1[Instancia Monolito 1<br>Servidor Grande]
    LB --> M2[Instancia Monolito 2<br>Servidor Grande]
```

- **Tiempo de Inactividad (Downtime)**: Las actualizaciones, parches o migraciones requieren detener toda la aplicaciÃ³n.
- **Ventanas de Mantenimiento**: Hay que planificar con mucho tiempo estas interrupciones porque afectan a todos los clientes.
- **Alta Disponibilidad Compleja**: Configuraciones activo/pasivo son posibles pero aÃ±aden complejidad y costos de licencias.

---

## Las Piedras: Microservicios al Rescate

### Â¿QuÃ© son los Microservicios?

Si el monolito es una roca de 1000 toneladas, los microservicios son **piedras**.

- **Piezas PequeÃ±as y Manejables**: Cada piedra (microservicio) realiza una funciÃ³n de negocio especÃ­fica.
- **Acoplados DÃ©bilmente (Loosely Coupled)**: Son independientes y se comunican entre sÃ­ a travÃ©s de APIs.

## Las Piedras: Microservicios al Rescate 2

```{mermaid}
graph TD
    U[Cliente] --> G[API Gateway]

    G --> MS1[Microservicio A<br>GestiÃ³n de Usuarios]
    G --> MS2[Microservicio B<br>CatÃ¡logo de Productos]
    G --> MS3[Microservicio C<br>Procesar Pedidos]

    MS1 --> DB1[Base de Datos A]
    MS2 --> DB2[Base de Datos B]
    MS3 --> DB3[Base de Datos C]
```

## Beneficios de las Piedras (en lugar de LA Roca Gigante)

1.  **Despliegue Independiente**: Cada servicio se puede desplegar en un servidor pequeÃ±o con solo los recursos que necesita. Â¡MÃ¡s barato!
2.  **Flexibilidad TecnolÃ³gica**: Cada microservicio puede estar escrito en el lenguaje de programaciÃ³n mÃ¡s adecuado para su funciÃ³n.
3.  **Escalabilidad Granular**: Â¿El servicio de pedidos estÃ¡ saturado? Puedes escalar solo ese servicio, no toda la aplicaciÃ³n.
4.  **Actualizaciones Sin Interrupciones**: Se actualiza un servicio a la vez. Los demÃ¡s siguen funcionando. Â¡No hay downtime!

---

## La Gran TransformaciÃ³n: RefactorizaciÃ³n

### El Dilema: Â¿CÃ³mo Partir la Roca?

Las empresas con aplicaciones monolÃ­ticas antiguas se enfrentan a un desafÃ­o: **refactorizar**.

**Refactorizar** significa reestructurar el cÃ³digo existente sin cambiar su comportamiento externo. Es como esculpir las piedras a partir de la roca gigante.

## RefactorizaciÃ³n: Dos Enfoques Principales 1

### 1. Big-Bang (Gran ExplosiÃ³n)

- **Parar el Mundo**: Se detiene el desarrollo de nuevas funciones.
- **Esfuerzo Total**: Todo el equipo se centra en refactorizar el monolito completo de una vez.
- **Alto Riesgo**: Puede paralizar el negocio y, si falla, el daÃ±o es enorme.

```{mermaid}
graph LR
    A[Monolito] -->|RefactorizaciÃ³n Masiva| B[Nuevo Sistema de Microservicios]
```

## RefactorizaciÃ³n: Dos Enfoques Principales 2

### 2. RefactorizaciÃ³n Incremental (Recomendado)

- **TransiciÃ³n Gradual**: Se extraen funciones del monolito una por una, convirtiÃ©ndolas en microservicios.
- **Nuevas CaracterÃ­sticas como Microservicios**: Las nuevas funciones se desarrollan directamente como microservicios que se comunican con el monolito mediante APIs.
- **El Monolito se Desvanece**: Poco a poco, el monolito se hace mÃ¡s pequeÃ±o hasta desaparecer.

## RefactorizaciÃ³n Incremental

```{mermaid}
graph TB
    subgraph A ["Fase 1"]
        M1[Monolito Grande] --> MS1[Nuevo Microservicio A]
    end
    subgraph B ["Fase 2"]
        M2[Monolito Mediano] --> MS2[Microservicio Refactorizado B]
    end
    subgraph C ["Fase 3"]
        M3[Monolito PequeÃ±o] --> MS3[Microservicio Refactorizado C]
    end
    M1 --> M2
    M2 --> M3
    M3 --> M4[Monolito Desaparece]

    style A fill:#FFFFFF
    style B fill:#FFFFFF 
    style C fill:#FFFFFF
```

---

## DesafÃ­os en el Camino

### Â¿Es Mi Monolito un Buen Candidato?

- **Lenguajes Muy Antiguos (COBOL, Assembler)**: A veces es mÃ¡s econÃ³mico reescribir la aplicaciÃ³n desde cero.
- **DiseÃ±o Pobre**: Si la aplicaciÃ³n original estÃ¡ mal diseÃ±ada, refactorizarla puede ser peor que reconstruirla.
- **Acoplamiento Fuerte con la Base de Datos**: Separar la lÃ³gica de los datos puede ser muy difÃ­cil.

## El DesafÃ­o de la EjecuciÃ³n

Si despliegas muchos microservicios en un mismo servidor, sus bibliotecas y entornos de ejecuciÃ³n pueden entrar en conflicto.

**SoluciÃ³n Necesaria**: Se necesita una forma de aislar cada microservicio para que funcione de forma independiente y sin conflictos.

**El HÃ©roe: Los Contenedores de Aplicaciones**

### La soluciÃ³n a los desafÃ­os de la refactorizaciÃ³n

Los contenedores llegaron para salvar el dÃ­a. Son **entornos de ejecuciÃ³n ligeros y encapsulados** para aplicaciones.

## Los Contenedores

```{mermaid}
graph TB
    S[Servidor FÃ­sico/Virtual] --> OS[Sistema Operativo]
    OS --> CE[Motor de Contenedores]

    subgraph C ["Contenedores Aislados"]
        CE --> C1[Contenedor A<br>Microservicio A<br>LibrerÃ­as Propias]
        CE --> C2[Contenedor B<br>Microservicio B<br>LibrerÃ­as Propias]
        CE --> C3[Contenedor C<br>Microservicio C<br>LibrerÃ­as Propias]
    end

    style C fill:#FFFFFF
```

## Â¿Por quÃ© los Contenedores son Geniales?

- **Aislamiento**: Cada microservicio corre en su propio contenedor, evitando conflictos de librerÃ­as.
- **Ligereza**: Los contenedores comparten el sistema operativo del host, por lo que consumen muchos menos recursos que una mÃ¡quina virtual completa.
- **Portabilidad**: Un contenedor se ejecuta igual en tu portÃ¡til, en un servidor de prueba o en la nube.
- **Alta UtilizaciÃ³n**: Puedes ejecutar muchos contenedores en un mismo servidor, aprovechando mejor el hardware.

## De los monolitos a los microservicios

El viaje del monolito a los microservicios es un proceso de modernizaciÃ³n crucial. Aunque presenta desafÃ­os, un enfoque incremental apoyado por tecnologÃ­as como los contenedores permite transformar una "roca" rÃ­gida y costosa en un conjunto Ã¡gil y flexible de "piedras" listas para la nube.

[Casos de Ã©xito](https://kubernetes.io/case-studies/)

[El caso de Wikimedia](https://kubernetes.io/case-studies/wikimedia/)

## Â¿QuÃ© es Kubernetes (K8s)?

**Â¡Imagina que eres el director de una gran orquesta!** ğŸ»

Kubernetes es como ese director que:

- Sabe quÃ© instrumentos (contenedores) necesitas
- Los coloca en el lugar correcto
- Asegura que toquen en armonÃ­a
- Reemplaza mÃºsicos si se enferman
- Escala la orquesta segÃºn el tamaÃ±o del auditorio

## DefiniciÃ³n formal

Sistema de orquestaciÃ³n de contenedores de cÃ³digo abierto que automatiza:

- Despliegue
- Escalado
- GestiÃ³n de aplicaciones en contenedores

**Â¿Por quÃ© "K8s"?**

K-u-b-e-r-n-e-t-e-s (8 letras en medio) â†’ Â¡Ahorramos tiempo!

---

## El Problema que Resuelve Kubernetes

```{mermaid}
graph LR
    A[**AplicaciÃ³n MonolÃ­tica**] --> B[Problemas: Escala difÃ­cil, Fallo Ãºnico]
    B --> C[Microservicios en Contenedores]
    C --> D["Nuevos Problemas
    OrquestaciÃ³n compleja"]
    D --> E[**Kubernetes al Rescate!**]
    
    style A fill:#f9f,stroke:#333
    style E fill:#9f9,stroke:#333
```

**Antes de Kubernetes:**

- "Â¡Se cayÃ³ un contenedor! Â¿QuiÃ©n lo reinicia?"
- "Â¿CÃ³mo distribuyo la carga entre mis 50 contenedores?"
- "Necesito actualizar sin downtime... Â¿magia?"

**Con Kubernetes:**
- "Dime lo que quieres, yo me encargo del cÃ³mo"


## Â¿Por quÃ© Kubernetes?

Antes de K8s, gestionar contenedores era como...

- ğŸ§± **Construir una casa ladrillo por ladrillo**, sin plano.
- ğŸ”§ **Reiniciar manualmente** cada contenedor si fallaba.
- ğŸ“¦ **Dificultad para escalar**: Â¿Necesitas 10 copias de tu app? Â¡A copiar y pegar!

## Con Kubernetes

Usando Kubernetes, la gestion de contenedores obtiene...

- ğŸ¤– **AutomatizaciÃ³n**: El sistema se encarga de mantener tu app en el estado deseado.
- ğŸ“ˆ **Escalado automÃ¡tico**: Aumenta o reduce rÃ©plicas segÃºn la carga.
- ğŸ”„ **Actualizaciones sin caÃ­das**: Despliega nuevas versiones sin que tus usuarios lo noten.

---

## Arquitectura de Kubernetes: La Gran Foto

```{mermaid}
graph
    subgraph Cluster [**Kubernetes Cluster**]
        direction TB
        style Cluster fill:#fff,stroke:#333
    
        subgraph N1 [**Nodo 1**]
            direction LR
            style N1 fill:#fff,stroke:#333
            F[Kubelet] --> Q
            G[Kube-proxy] --> Q

            subgraph Q [**CRI**]
                direction TB
                style Q fill:#fff,stroke:#333
                P3[Pod 1]
                P4[Pod m]
            end
        end
        subgraph N2 [**Nodo 2**]
            direction LR
            style N2 fill:#fff,stroke:#333
            I[Kubelet] --> P
            K[Kube-proxy] --> P
            subgraph P [**CRI**]
                direction TB
                style P fill:#fff,stroke:#333
                P1[Pod 1]
                P2[Pod n]
            end
        end

        subgraph CP [**Control Plane**]
            direction TB
            style CP fill:#fff,stroke:#333
            A[API Server] --> |Almacena estado| B[Etcd] 
            C[Scheduler] --> |Asigna pods a nodos| A
            D[Controller Manager] --> |Controla procesos| A
        end

        F --> |Comunica con| A
        G -.-> A
        I --> |Comunica con| A
        K -.-> A
    end
    
```
---

## **Control Plane** El Cerebro del ClÃºster 1

**API Server** [kube-apiserver](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/)

*Â¡El recepcionista!*

- Ãšnica interfaz para comunicarse con el cluster
- Valida y procesa todas las solicitudes
- "Â¿Quieres hablar con Kubernetes? Habla conmigo primero"


## **Control Plane** El Cerebro del ClÃºster 2

**Scheduler** [kube-scheduler](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/)

*Â¡El agente de asignaciÃ³n!*

- Observa pods sin nodo asignado
- Encuentra el nodo perfecto basado en:
  - Recursos necesarios
  - PolÃ­ticas
  - Restricciones


## **Control Plane** El Cerebro del ClÃºster 3

**Controller Manager** [kube-controller-manager](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/)

*Â¡El supervisor obsesivo!*

- Controla que la realidad coincida con lo deseado
- "Â¿Dijiste 3 rÃ©plicas? Voy a verificar... sÃ­, son 3. Espera, ahora son 2! Â¡Creo otra!"

## **Control Plane** El Cerebro del ClÃºster 4

**Etcd** [etcd.io](https://etcd.io)

*La memoria del cluster*

- Base de datos clave-valor que guarda TODO el estado del cluster
- Lee y escribe usando herramientas HTTP estÃ¡ndar
- Vigila claves y directorios especÃ­ficos por cambios y reacciona a los cambios

---

## **Nodos** Los Trabajadores 1

**Kubelet** [kubelet](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/)

*Â¡El capataz del nodo!*

- Agente que corre en CADA nodo
- Recibe Ã³rdenes del Control Plane
- Se asegura que los contenedores estÃ©n sanos
- "Â¡SÃ­ jefe! Los contenedores estÃ¡n corriendo perfectamente"


## **Nodos** Los Trabajadores 2

**Kube-proxy** [kube-proxy](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/)

*Â¡El director de trÃ¡fico!*

- Maneja la red dentro del nodo
- Enruta el trÃ¡fico a los contenedores correctos
- "Â¿Buscas el servicio web? Por aquÃ­, por favor"

## **Nodos** Los Trabajadores 3

**Container Runtime:** [containerd.io](https://containerd.io)

*Â¡El jefe de cuadrilla!*

- Docker, containerd, etc.
- El que realmente ejecuta los contenedores
- La comunicaciÃ³n entre el Kubelet y el Container Runtime se hace mediante el **CRI** (Container Runtime Interface)

# Namespaces y Objetos

## IntroducciÃ³n a `kubectl`

**`kubectl` = Kubernetes Control Tool**

- `kubectl` es la **CLI** (interfaz de lÃ­nea de comandos) para interactuar con el clÃºster.
- Se comunica con el **API Server** del Control Plane mediante YAML o comandos.

**Tu varita mÃ¡gica para controlar Kubernetes** âœ¨


## IntroducciÃ³n a `kubectl` 2

Comandos bÃ¡sicos:

- `kubectl get pods` - "Â¿QuÃ© pods tienes?"
- `kubectl create deployment` - "Crea esto"
- `kubectl describe pod` - "CuÃ©ntame todo sobre este pod"

Si escribes varios comandos en un archivo, puedes ejecutarlos con:

- `kubectl apply -f archivo.yaml` - "Haz lo que dice este archivo"

---

## Namespaces: Departamentos en un Edificio

Imagina un edificio de oficinas:

- Cada empresa (equipo/proyecto) tiene su **piso** (Namespace).
- Pueden tener un "servidor web" llamado `frontend`, pero **no chocan** porque estÃ¡n en pisos distintos.
- Â¡Evitas el caos de nombres y recursos compartidos!

```{mermaid}
graph TB
    subgraph Cluster[ClÃºster de Kubernetes]
        direction TB
        style Cluster fill:#ffffff
    subgraph Namespace1[dev]
        style Namespace1 fill:#FFE5B8
        Pod1[Pod: frontend]
        Pod2[Pod: db]
        style Pod1 fill:#ffffff
        style Pod2 fill:#ffffff
    end
    subgraph Namespace2[prod]
        style Namespace2 fill:#FFE5B8
        Pod3[Pod: frontend]
        Pod4[Pod: db]
        style Pod3 fill:#ffffff
        style Pod4 fill:#ffffff
    end
    subgraph Namespace3[monitoring]
        style Namespace3 fill:#FFE5B8
        Pod5[Pod: prometheus]
        Pod6[Pod: grafana]
        style Pod5 fill:#ffffff
        style Pod6 fill:#ffffff
    end
    end
```

## Â¿Por quÃ© namespaces?

- **Aislamiento:** Equipo desarrollo vs producciÃ³n
- **OrganizaciÃ³n:** Como carpetas para tus recursos
- **Cuotas:** LÃ­mites de recursos por namespace
- **Acceso:** Permisos diferentes por namespace


> ğŸ›¡ï¸ **Namespaces aÃ­slan recursos lÃ³gicamente**, no fÃ­sicamente. Â¡No son contenedores dentro de contenedores!


---

## El Sistema de Etiquetas

**Imagina que organizas tu biblioteca personal:**

- **Labels**: Etiquetas clave-valor que **tÃº asignas** a cualquier objeto.
  - Ej: `app=web`, `env=prod`, `tier=frontend`
- **Selectors**: Consultas que **usan esas etiquetas** para encontrar objetos.

### Labels (Etiquetas)
```yaml
# Un Pod con labels
metadata:
  labels:
    app: frontend-web
    environment: production
    team: blue-team
    version: 2.1.0
```
**Son como post-its** en tus recursos

## El Sistema de Etiquetas 2

### Selectors (Selectores)
```yaml
spec:
  selector:
    matchLabels:
      app: frontend-web
      environment: production
```
**Son como bÃºsquedas** para encontrar recursos

**Ejemplo prÃ¡ctico:** "Encuentra todos los pods del 'frontend-web' en 'producciÃ³n'"


> ğŸ§© **Labels y Selectors son como el sistema de clasificaciÃ³n de una biblioteca**:  
> â€œDame todos los libros (Pods) con la etiqueta `gÃ©nero=scifi`â€.

---

## Pods: La Unidad MÃ­nima de Despliegue

```{mermaid}
graph TD
    A[Pod] --> B[Contenedor Principal]
    A --> C[Contenedor Auxiliar]
    A --> D[Volumen Compartido]
    A --> E[IP Ãšnica]
    
    B --> F[App Web]
    C --> G[Sidecar Logger]
```

**Â¡Un pod no es un contenedor! Es la "cÃ¡psula" que contiene contenedores**

> ğŸ¤ **Regla de oro**: Un Pod = una **unidad lÃ³gica de aplicaciÃ³n**.  
> Normalmente, **1 contenedor por Pod** (a menos que necesiten cooperar estrechamente).

## Pods: La Unidad MÃ­nima de Despliegue 2

**CaracterÃ­sticas clave:**

- Unidad de escalado mÃ­nima: es el **objeto mÃ¡s pequeÃ±o** que puedes crear en K8s.
- Comparten:
  - Red (DirecciÃ³n IP)
  - VolÃºmenes de almacenamiento
  - Namespace de red
- EfÃ­meros: Nacen, viven, mueren

## Pods: La Unidad MÃ­nima de Despliegue 3

**Â¿CuÃ¡ndo mÃºltiples contenedores?**

- AplicaciÃ³n + sidecar helper
- Web server + file sync
- App + proxy de monitoreo
- **Regla:** Deben necesitar compartir recursos

---

## AnatomÃ­a de un Pod

```yaml
apiVersion: v1
kind: Pod                    # â† Tipo de objeto
metadata:                    # â† IdentificaciÃ³n
  name: mi-pod-maravilloso
  labels:
    app: web-server
    environment: test
spec:                        # â† EspecificaciÃ³n deseada
  containers:
  - name: nginx-container    # â† Contenedor 1
    image: nginx:1.19
    ports:
    - containerPort: 80
  - name: logger-sidecar     # â† Contenedor 2
    image: busybox
    command: ['sh', '-c', 'while true; do echo logging; sleep 10; done']
```

**Piensa en el Pod como la unidad atÃ³mica de tu aplicaciÃ³n**

---

## Deployments: El Planificador Inteligente {.smaller}

::: {.columns}
::: {.column width="60%"}
```{mermaid}
graph TB
    A[Deployment YAML] --> B[Controlador de Deployment]
    B <--> C[Estado Deseado: 3 RÃ©plicas]
    C --> D[ReplicaSet]
    D --> E[Pod 1]
    D --> F[Pod 2]
    D --> G[Pod 3]
    B -.-> H
    H[Pod 2 FallÃ³] --> |Detecta| D
    D -.-> |Crea| J[Pod 4]
    J ~~~ E
    J ~~~ F
    J ~~~ G
    style H stroke:#f00
    style J stroke:#f00
```
:::

::: {.column width="40%"}

**Â¿Por quÃ© no usar Pods directamente?**

- Permite **patrones avanzados** (sidecar, ambassador, adapter).
- Proporciona un **nivel de abstracciÃ³n** para la red y almacenamiento.
- Facilita la **gestiÃ³n de ciclos de vida**.

> âš ï¸ **Los Pods son efÃ­meros**: pueden morir y renacer en otro nodo. Â¡Nunca confÃ­es en su IP!

:::

:::

---

## La Magia de los Deployments

### Escalado AutomÃ¡tico
```yaml
spec:
  replicas: 3    # â† "Quiero 3 copias corriendo"
```
**Kubernetes:** "Vigilo que siempre haya 3 saludables"

### Â¿QuÃ© hace un Deployment?

1. **Crea y gestiona ReplicaSets** (que a su vez gestionan Pods).
2. **Permite actualizaciones controladas** (rolling updates).
3. **Permite retroceder** (rollbacks) si algo falla.

## Actualizaciones Controladas y Retroceder 

**Rolling Update:**

1. Crea Pod v2.1
2. Elimina Pod v2.0
3. Repite hasta todos actualizados
4. **Â¡Los usuarios ni se enteran!**

**Rollback AutomÃ¡tico:**

- "La nueva versiÃ³n falla"
- "Â¡Vuelve a la anterior versiÃ³n!"
- **Un comando:** `kubectl rollout undo`

## Ejemplo de Deployment Completo

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
  labels:
    app: frontend
spec:
  replicas: 3                    # â† Quiero 3 copias
  selector:
    matchLabels:
      app: frontend              # â† Esto controla el ReplicaSet
  template:                      # â† Plantilla para crear Pods
    metadata:
      labels:
        app: frontend            # â† Â¡Estas labels deben coincidir!
    spec:
      containers:
      - name: nginx
        image: nginx:1.20
        ports:
        - containerPort: 80
```

---

## Flujo de un Deployment

```{mermaid}
sequenceDiagram
    participant You as TÃº
    participant kubectl
    participant API as API Server
    participant Deploy as Deployment Controller
    participant RS as ReplicaSet
    participant Pods

    You->>kubectl: kubectl apply -f deployment.yaml
    kubectl->>API: Crea Deployment
    API->>Deploy: Notifica nuevo Deployment
    Deploy->>RS: Crea ReplicaSet
    RS->>Pods: Crea Pods (segÃºn rÃ©plicas)
    Pods-->>RS: Reportan estado
    RS-->>Deploy: Reporta estado
    Deploy-->>API: Actualiza estado del Deployment
```

> ğŸ¯ **El Deployment no toca los Pods directamente**: delega en el ReplicaSet.



## Tu trabajo como desarrollador/operador

1. Definir el **estado deseado** (YAML)
2. Decirle a Kubernetes: "Â¡Haz que esto sea realidad!"
3. Kubernetes se encarga del **cÃ³mo**

Est quiere decir que la configuraciÃ³n es **declarativa**.

---

## Patrones Mentales para Recordar

**Kubernetes es Declarativo**

### TÃº dices QUÃ‰ quieres, no CÃ“MO

Mal: "Crea un pod, espera, ahora otro..."
Bien: "Quiero 3 pods corriendo esta app"

**Todo se Conecta con Labels**

### Como un sistema de archivos con etiquetas

- Deployments encuentran Pods via labels
- Services encuentran Pods via labels

## Patrones Mentales para Recordar 2

**Los Pods son EfÃ­meros**

### No te encariÃ±es con ellos

- Nacen y mueren constantemente
- Tu aplicaciÃ³n debe ser stateless-ready
- El storage persistente va aparte

**Los Controllers Mantienen el Estado**

### Son loops infinitos verificando

- "Â¿Coincide la realidad con lo deseado?"
- "Si no, Â¡tomo acciÃ³n!"

---

## PrÃ³ximos Pasos

**Hoy aprendiste los fundamentos:**

- âœ… Arquitectura de Kubernetes
- âœ… Namespaces y organizaciÃ³n
- âœ… Pods (la unidad atÃ³mica)
- âœ… Deployments (gestiÃ³n inteligente)

## En el laboratorio prÃ¡ctico

- ğŸ¯ CrearÃ¡s tu primer cluster local
- ğŸ¯ DesplegarÃ¡s aplicaciones reales
- ğŸ¯ ExperimentarÃ¡s con escalado
- ğŸ¯ PracticarÃ¡s actualizaciones sin downtime

**Â¡PrepÃ¡rate para la acciÃ³n!** ğŸš€
---
title: Exponiendo aplicaciones con Kubernetes
subtitle: Redes en Kubernetes
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
---

# Exponiendo aplicaciones con Kubernetes y Redes en Kubernetes

## Introducción: ¿Por qué necesitamos exponer aplicaciones?

- En Kubernetes, los pods son efímeros: nacen, mueren y se reemplazan constantemente.
- Las IP de los pods **no son estables** → ¡No puedes depender de ellas!
- Necesitamos una forma **estable y confiable** de acceder a nuestras aplicaciones.
- Además, ¿cómo se comunican los pods entre sí? ¿Y con el mundo exterior?

> 💡 **¡Imagina que cada vez que tu casa se mudara, cambiaras de número telefónico!**  
> Necesitas un número fijo (como un Service) que siempre te encuentre.

---

## ¿Qué es la red en Kubernetes?

### El modelo de red de Kubernetes

Kubernetes asume un modelo de red simple pero poderoso:

1. **Todos los pods pueden comunicarse entre sí sin NAT**  
   → Cada pod tiene su propia IP y puede hablar con cualquier otro pod directamente.

2. **Todos los nodos pueden comunicarse con todos los pods**  
   → Sin traducción de direcciones.

3. **La IP que un pod ve para sí mismo es la misma que ven los demás**  
   → ¡No hay trucos de enmascaramiento!

> 🧠 **Esto significa que la red en Kubernetes es “plana”**: no hay jerarquías complejas de subredes por defecto.

---

## Comunicación interna: Cómo hablan los pods entre sí

### Escenario típico

```mermaid
graph LR
  A[Pod A<br/>IP: 10.244.1.5] -->|Conecta a| B[Pod B<br/>IP: 10.244.2.8]
  B -->|Responde a| A
```

- Pod A conoce la IP de Pod B → puede hacer una petición HTTP directa.
- Pero… ¿y si Pod B muere y se recrea con una IP diferente?

> ❗ **Problema**: Las IPs de los pods **no son permanentes**.

---

## La solución: Services

### ¿Qué es un Service?

Un **Service** es una abstracción que define un conjunto lógico de pods y una política para acceder a ellos.

- Proporciona una **IP estable** y un **nombre DNS**.
- Actúa como un **balanceador de carga** interno.
- Selecciona pods usando **etiquetas (labels)**.

```mermaid
graph LR
  Client --> Service
  Service --> Pod1
  Service --> Pod2
  Service --> Pod3
```

> 💡 **Piensa en un Service como un “repartidor de tráfico”** que siempre sabe dónde están tus pods, incluso si se mueven.

---

## Tipos de Services

### 1. ClusterIP (por defecto)

- Solo accesible **dentro del clúster**.
- Ideal para comunicación interna (microservicios).

### 2. NodePort

- Expone el Service en un **puerto estático** en cada nodo.
- Accesible desde fuera del clúster: `http://<IP-nodo>:<puerto>`

### 3. LoadBalancer

- Crea un balanceador de carga **externo** (en la nube).
- Ideal para aplicaciones públicas.

### 4. ExternalName

- Mapea el Service a un **nombre DNS externo** (no usa pods).

> 🧩 **¿Cuál usar?**  
> - Interno → `ClusterIP`  
> - Pruebas rápidas → `NodePort`  
> - Producción en la nube → `LoadBalancer`

---

## ¿Cómo funciona un Service por dentro?

### El selector y los endpoints

- Un Service usa un **selector** (etiquetas) para encontrar pods.
- Kubernetes mantiene automáticamente una lista de **endpoints** (IP + puerto de los pods seleccionados).

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mi-app
spec:
  selector:
    app: frontend  # ← ¡Esto es clave!
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
```

> 🔍 **El Service no conoce IPs directamente** → solo conoce etiquetas.  
> ¡Los pods pueden cambiar, pero el Service siempre los encontrará!

---

## DNS en Kubernetes

### ¡Cada Service tiene un nombre DNS!

Dentro del clúster, puedes acceder a un Service usando:

```
<nombre-del-service>.<namespace>.svc.cluster.local
```

Ejemplo:  
- Service: `web` en namespace `default`  
- Acceso: `http://web.default.svc.cluster.local`

> 🌐 **Esto es mucho más fácil que recordar IPs**.  
> Y si cambia la IP del Service… ¡el DNS sigue funcionando!

---

## Exponiendo al exterior: Ingress

### El problema con NodePort y LoadBalancer

- Cada Service necesita su propio puerto o balanceador → **costoso y difícil de gestionar**.
- No hay enrutamiento HTTP inteligente (por rutas, hosts, etc.).

### Solución: Ingress

- Un **controlador de Ingress** (como NGINX, Traefik) actúa como puerta de entrada HTTP/HTTPS.
- Define reglas para enrutar tráfico a diferentes Services.

```mermaid
graph LR
  Internet --> IngressController
  IngressController -->|/api| ServiceA
  IngressController -->|/web| ServiceB
  IngressController -->|host: tienda.com| ServiceC
```

> 🚪 **Ingress = el recepcionista del edificio**  
> Recibe a todos los visitantes y los dirige al departamento correcto.

---

## Objetos Ingress: Reglas de enrutamiento

### Ejemplo de regla por ruta

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mi-ingress
spec:
  rules:
  - http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
      - path: /web
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

> 🧭 **Ingress te permite hacer enrutamiento avanzado** sin tocar el código de tus apps.

---

## TLS y seguridad con Ingress

### ¿Y si queremos HTTPS?

- Puedes adjuntar un **certificado TLS** al Ingress.
- El tráfico se cifra desde el cliente hasta el Ingress Controller.

```yaml
spec:
  tls:
  - hosts:
    - miapp.com
    secretName: mi-certificado-tls
  rules:
  - host: miapp.com
    http:
      paths: [...]
```

> 🔒 **¡Tu app sigue hablando HTTP internamente!**  
> El Ingress se encarga del cifrado/descifrado (TLS termination).

---

## Resumen visual: Flujo completo

```mermaid
flowchart TB
  Usuario -->|HTTPS| IngressController
  IngressController -->|HTTP| Service[Service: web]
  Service --> Pod1[Pod: web-7d5b6c8f9-abc12]
  Service --> Pod2[Pod: web-7d5b6c8f9-def34]
  subgraph Cluster
    IngressController
    Service
    Pod1
    Pod2
  end
```

1. Usuario accede a `https://miapp.com`
2. Ingress Controller recibe la petición
3. Enruta a `Service: web` según las reglas
4. Service distribuye a uno de los pods

---

## ¿Qué pasa si un pod falla?

### Auto-reparación y descubrimiento

- Kubernetes **elimina automáticamente** los pods fallidos de los endpoints del Service.
- El Service **solo envía tráfico a pods saludables**.
- Si se crea un nuevo pod con las etiquetas correctas → ¡se agrega automáticamente!

> 🔄 **Es un sistema autónomo**: no necesitas reiniciar nada ni reconfigurar IPs.

---

## Namespaces y aislamiento de red

### ¿Pueden los Services cruzar namespaces?

- **Sí**, pero necesitas usar el nombre completo:  
  `servicio.namespace.svc.cluster.local`
- Por defecto, los Services **solo resuelven dentro de su namespace**.

> 🧱 **Los namespaces son como departamentos en una empresa**:  
> Puedes llamar a otro departamento, pero debes marcar el número completo.

---

## Limitaciones y consideraciones

### Cosas que debes saber

- **Services no son mágicos**: si todos los pods están caídos, el Service no responde.
- **Ingress requiere un controlador**: no viene activado por defecto en todos los clústeres.
- **ClusterIP no es accesible desde fuera**: no intentes usarlo para exponer apps públicas.
- **NodePort usa puertos altos (30000-32767)**: asegúrate de que tu firewall lo permita.

> ⚠️ **¡No confundas Service con Deployment!**  
> El Deployment gestiona los pods. El Service gestiona el acceso a esos pods.

---

## Comparación rápida: Service vs Ingress

| Característica        | Service (NodePort/LB) | Ingress               |
|----------------------|------------------------|------------------------|
| Protocolo            | Cualquiera (TCP/UDP)   | Solo HTTP/HTTPS        |
| Enrutamiento         | No (1:1)               | Sí (por host/ruta)     |
| TLS                  | Manual                 | Integrado              |
| Costo (en la nube)   | Alto (1 LB por Service)| Bajo (1 LB para todos) |
| Ideal para           | APIs gRPC, bases de datos | Aplicaciones web    |

> 📊 **Usa Ingress para HTTP, Service para todo lo demás.**

---

## Conclusión: La red en Kubernetes, paso a paso

1. **Tus apps corren en pods efímeros** → IPs cambiantes.
2. **Crea un Service** para darles una identidad estable.
3. **Usa ClusterIP** para comunicación interna.
4. **Para exponer al exterior**:  
   - Pruebas → `NodePort`  
   - Producción → `LoadBalancer` + `Ingress`
5. **Ingress te da enrutamiento inteligente y TLS** sin tocar tus apps.

> 🎯 **Recuerda**: Kubernetes se encarga de la complejidad.  
> Tú solo defines *qué* quieres, no *cómo* hacerlo.

---

## ¿Preguntas?

### ¡Ahora es tu turno!

- ¿Qué tipo de Service usarías para una base de datos interna?
- ¿Por qué no usarías Ingress para una app de videojuegos en UDP?
- ¿Cómo accederías desde el namespace `dev` al Service `cache` en `prod`?

> 💬 **Piensa en la red de Kubernetes como una ciudad inteligente**:  
> Calles (pods), semáforos (Services) y centros de control de tráfico (Ingress).  
> ¡Todo fluye sin que tú conduzcas!
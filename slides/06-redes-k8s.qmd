---
title: Exponiendo aplicaciones con Kubernetes
subtitle: Redes en Kubernetes
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
---

# Exponiendo aplicaciones con Kubernetes y Redes en Kubernetes

---

## De Docker a Kubernetes: El siguiente nivel

::: {.columns}
::: {.column width="50%"}
**¬øRecuerdas Docker Compose?**
- Perfecto para single-host
- Desarrollo y testing
- Limitado para producci√≥n

**Problemas en escala:**
- ¬øY si un host falla?
- ¬øC√≥mo escalo autom√°ticamente?
- ¬øC√≥mo gestiono updates sin downtime?
- ¬øY el load balancing?
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[Host √önico] --> B[Single Point of Failure]
    C[Escala Manual] --> D[Ineficiente]
    E[Updates] --> F[Downtime]
    
    style B fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
```
:::
:::

**Kubernetes: La orquestaci√≥n de contenedores a escala enterprise**

> En esta sesi√≥n aprenderemos a **exponer aplicaciones** del cl√∫ster y **gestionar su configuraci√≥n** de forma segura y desacoplada.

Imagina esto:

- Tu app est√° corriendo feliz en Kubernetes‚Ä¶  
- Pero **nadie puede acceder a ella** desde fuera.  
- Y adem√°s, **sus credenciales est√°n quemadas en el c√≥digo** üî•.

> üò± ¬°Dos grandes no-nos en producci√≥n!

Hoy resolveremos ambos problemas:  
‚úÖ **Exposici√≥n controlada**  
‚úÖ **Configuraci√≥n limpia y segura**

---

## ¬øQu√© es Kubernetes realmente?

::: {.columns}
::: {.column width="60%"}
**Definici√≥n formal:**
- Sistema open-source para automatizar el despliegue, escalado y gesti√≥n de aplicaciones en contenedores

**En t√©rminos simples:**
- Como un "sistema operativo para clusters"
- Gestiona d√≥nde se ejecutan tus contenedores
- Se asegura de que siempre est√©n corriendo
- Escala autom√°ticamente seg√∫n la demanda

**Analog√≠a:**
- Kubernetes es el director de orquesta
- Los nodos son los m√∫sicos
- Los pods son las partituras individuales
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Kubernetes Master] --> B[Node 1]
    A --> C[Node 2]
    A --> D[Node 3]
    
    B --> E[Pods]
    C --> F[Pods]
    D --> G[Pods]
    
    style A fill:#ffccbc
```
:::
:::

---

## Arquitectura de Kubernetes: Visi√≥n general

```mermaid
graph TB
    A[Control Plane] --> B[API Server]
    A --> C[etcd]
    A --> D[Scheduler]
    A --> E[Controller Manager]
    
    F[Worker Nodes] --> G[Kubelet]
    F --> H[Kube Proxy]
    F --> I[Container Runtime]
    
    B --> G
    D --> J[Pods en Nodes]
    
    style A fill:#e3f2fd
    style F fill:#e8f5e8
```

---

## Conceptos fundamentales de Kubernetes

```mermaid
graph TB
    A[Kubernetes Concepts] --> B[Pods]
    A --> C[Services]
    A --> D[Deployments]
    A --> E[Ingress]
    A --> F[Namespaces]
    
    B --> G[Unidad m√≠nima deployable]
    C --> H[Punto de acceso estable]
    D --> I[Gesti√≥n de aplicaciones]
    E --> J[Acceso desde exterior]
    F --> K[Aislamiento l√≥gico]
```

---

## Pods: La unidad at√≥mica de Kubernetes

::: {.columns}
::: {.column width="50%}
**¬øQu√© es un Pod?**
- La unidad m√°s peque√±a que puedes desplegar
- Grupo de uno o m√°s contenedores
- Comparten recursos de red y almacenamiento
- Mismo contexto de ejecuci√≥n

**Caracter√≠sticas clave:**
- Direcci√≥n IP √∫nica compartida
- Namespace de red compartido
- Vol√∫menes compartidos
- Ciclo de vida conjunto
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[Pod IP: 10.0.0.5] --> B[Contenedor App]
    A --> C[Contenedor Sidecar]
    A --> D[Volumen compartido]
    
    B --> E[Puerto 8080]
    C --> F[Puerto 9090]
    
    style A fill:#e1f5fe
```
:::
:::

**üí° Importante: Normalmente 1 contenedor por Pod, pero pueden ser m√°s para casos especiales**

---

### ¬øC√≥mo hablan las apps con el mundo?

En Kubernetes, los **pods son ef√≠meros**: nacen, mueren, se reemplazan.  
Sus IPs **cambian constantemente** ‚Üí ¬°No puedes depender de ellas!

> üß† **Necesitas una identidad estable** para tu aplicaci√≥n.  
> Eso es exactamente lo que ofrece un **Service**.

---

## Services: La red estable en Kubernetes

::: {.columns}
::: {.column width="60%}
**Problema:**
- Los Pods son ef√≠meros (nacen y mueren)
- Las IPs de los Pods cambian constantemente
- ¬øC√≥mo encuentran los clientes a los Pods?

**Soluci√≥n: Services**
- Punto de acceso estable y permanente
- IP virtual que no cambia
- Balancea carga entre Pods backend
- Descubre autom√°ticamente los Pods
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[Cliente] --> B[Service IP: 10.3.241.150]
    B --> C[Pod A: 10.0.0.5]
    B --> D[Pod B: 10.0.0.6]
    B --> E[Pod C: 10.0.0.7]
    
    style B fill:#c8e6c9
```
:::
:::

---

Un **Service** es una abstracci√≥n que define un **punto de acceso estable** a un conjunto de pods.

- Usa **etiquetas (labels)** para seleccionar pods.
- Proporciona una **IP virtual** y un **nombre DNS** fijos.
- Act√∫a como **balanceador de carga interno**.

> üí° **El Service no se preocupa por IPs reales** ‚Üí solo por etiquetas.  
> ¬°Los pods pueden morir y renacer, y el Service siempre los encontrar√°!

---

## Tipos de Services

```mermaid
graph TB
    A[Service Types] --> B[ClusterIP]
    A --> C[NodePort]
    A --> D[LoadBalancer]
    A --> E[ExternalName]
    
    B --> F[Interno al cluster]
    C --> G[Acceso mediante puertos del nodo]
    D --> H[Cloud Load Balancer externo]
    E --> I[Alias para servicio externo]
    
    style B fill:#e1f5fe
    style C fill:#fff3e0
    style D fill:#f3e5f5
```

---

## ClusterIP: Comunicaci√≥n interna (por defecto)

::: {.columns}
::: {.column width="60%}
**Caracter√≠sticas:**
- IP accesible solo dentro del cluster
- Default type para servicios
- Perfecto para comunicaci√≥n entre microservicios

**Ejemplo t√≠pico:**
- Frontend ‚Üí Backend API
- API ‚Üí Database
- Servicios internos que no exponen al exterior
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[Frontend Pod] --> B[API Service<br/>clusterip: 10.96.1.5]
    B --> C[API Pod 1]
    B --> D[API Pod 2]
    
    style B fill:#e1f5fe
```
:::
:::

---

## NodePort: Acceso externo b√°sico

::: {.columns}
::: {.column width="60%}
**Caracter√≠sticas:**
- Expone el servicio en un puerto est√°tico en cada nodo
- Accesible desde fuera del cluster
- Puerto en rango 30000-32767

**Flujo de tr√°fico:**
1. Cliente ‚Üí NodeIP:NodePort
2. Nodo ‚Üí Service
3. Service ‚Üí Pod destino
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Cliente] --> B[NodeIP:30080]
    B --> C[Service]
    C --> D[Pod Backend]
    
    style B fill:#fff3e0
```
:::
:::

**‚ö†Ô∏è No ideal para producci√≥n - usa Ingress**

---

## LoadBalancer: Integraci√≥n con cloud

::: {.columns}
::: {.column width="60%}
**Caracter√≠sticas:**
- Crea un load balancer externo en cloud providers
- Asigna IP externa autom√°ticamente
- Integraci√≥n nativa con AWS, GCP, Azure

**Ideal para:**
- Servicios que necesitan IP p√∫blica estable
- Aplicaciones cr√≠ticas en cloud
- Cuando necesitas balanceo de carga gestionado
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Internet] --> B[Cloud LB: 35.200.10.5]
    B --> C[Node 1]
    B --> D[Node 2]
    B --> E[Node 3]
    
    C --> F[Service]
    D --> F
    E --> F
    
    style B fill:#f3e5f5
```
:::
:::

---

> üß© **Regla mental**:  
> - Interno ‚Üí `ClusterIP`  
> - Pruebas ‚Üí `NodePort`  
> - Producci√≥n ‚Üí `LoadBalancer`

---

## ¬øC√≥mo se define un Service?

```yaml
apiVersion: v1
kind: Service
meta
  name: mi-app
spec:
  type: LoadBalancer        # ‚Üê ¬°elige el tipo!
  selector:
    app: fastapi            # ‚Üê debe coincidir con los labels de tus pods
  ports:
    - protocol: TCP
      port: 80              # puerto del Service
      targetPort: 8000      # puerto del contenedor
```

> üîç **El secreto est√° en el `selector`**:  
> Si tus pods tienen `app: fastapi`, ¬°el Service los encontrar√°!

---

## Ingress: El router inteligente

::: {.columns}
::: {.column width="60%}
**Problema con LoadBalancer:**
- Un LoadBalancer por servicio ‚Üí costoso
- No puede hacer routing basado en paths/hosts

**Soluci√≥n: Ingress**
- Un punto de entrada para m√∫ltiples servicios
- Routing basado en reglas (host, path, headers)
- Terminaci√≥n SSL/TLS
- Rewrite rules y autenticaci√≥n
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Internet] --> B[Ingress Controller]
    B --> C[/api ‚Üí API Service]
    B --> D[/app ‚Üí Web Service]
    B --> E[/docs ‚Üí Docs Service]
    
    style B fill:#c8e6c9
```
:::
:::

---

## Ingress vs LoadBalancer

```mermaid
graph TB
    A[Tr√°fico Entrante] --> B{¬øNecesitas routing avanzado?}
    
    B -->|S√≠| C[Ingress Controller]
    B -->|No| D[LoadBalancer Service]
    
    C --> E[Routing por host/path]
    C --> F[SSL Termination]
    C --> G[Un LB para m√∫ltiples apps]
    
    D --> H[IP p√∫blica directa]
    D --> I[Simple y directo]
    
    style C fill:#c8e6c9
    style D fill:#f3e5f5
```

---

## Deployments: Gestionando el ciclo de vida

::: {.columns}
::: {.column width="60%}
**¬øQu√© resuelve?**
- ¬øC√≥mo actualizo mi app sin downtime?
- ¬øC√≥mo escalo autom√°ticamente?
- ¬øC√≥mo vuelvo a una versi√≥n anterior?

**Deployment proporciona:**
- Updates rolling (sin downtime)
- Rollbacks autom√°ticos
- Escalado autom√°tico (HPA)
- Replica management
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Deployment] --> B[ReplicaSet v1]
    A --> C[ReplicaSet v2]
    
    B --> D[Pods v1.0]
    C --> E[Pods v1.1]
    
    style A fill:#ffccbc
```
:::
:::

---

## Modelo de red de Kubernetes

::: {.columns}
::: {.column width="60%}
**Principios fundamentales:**
1. Todo Pod puede comunicarse con todo Pod sin NAT
2. Todo Node puede comunicarse con todo Pod sin NAT
3. La IP que un Pod ve en s√≠ mismo es la misma que otros Pods ven

**Implementaci√≥n:**
- CNI (Container Network Interface) plugins
- Cada Pod tiene IP real de red
- No overlays complicados (en la mayor√≠a de casos)
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[Pod A] --> B[Pod B]
    C[Pod C] --> B
    A --> C
    
    style A fill:#e1f5fe
    style B fill:#e1f5fe
    style C fill:#e1f5fe
```
:::
:::

---

## DNS en Kubernetes

::: {.columns}
::: {.column width="60%}
**Descubrimiento autom√°tico de servicios:**
- Cada Service obtiene un DNS name
- Formato: `<service-name>.<namespace>.svc.cluster.local`
- Resoluci√≥n dentro del cluster autom√°tica

**Ejemplos:**
- `frontend.default.svc.cluster.local`
- `database.production.svc.cluster.local`
- `redis.cache.svc.cluster.local`

**Simplificado:**
- `frontend` (mismo namespace)
- `database.production` (namespace diferente)
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[App Pod] --> B[CoreDNS]
    B --> C[Resuelve: api-service]
    C --> D[10.96.1.5]
    
    style B fill:#fff9c4
```
:::
:::

---

## Namespaces: Aislamiento l√≥gico

::: {.columns}
::: {.column width="60%}
**¬øPara qu√© sirven?**
- Aislar recursos (dev, staging, prod)
- L√≠mites de recursos por equipo
- Control de acceso (RBAC)

**Namespaces comunes:**
- `default` (por defecto)
- `kube-system` (sistema de Kubernetes)
- `kube-public` (recursos p√∫blicos)
- `custom` (tus aplicaciones)
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Cluster] --> B[Namespace: dev]
    A --> C[Namespace: staging]
    A --> D[Namespace: prod]
    
    B --> E[Pods/Services dev]
    C --> F[Pods/Services staging]
    D --> G[Pods/Services prod]
    
    style B fill:#e1f5fe
    style C fill:#fff3e0
    style D fill:#c8e6c9
```
:::
:::

---

## Flujo completo: De imagen a servicio expuesto

```mermaid
graph TB
    A[Imagen Docker] --> B[Deployment]
    B --> C[Pods]
    C --> D[Service]
    D --> E[Ingress]
    E --> F[Internet]
    
    G[ConfigMap] --> C
    H[Secret] --> C
    I[PersistentVolume] --> C
    
    style D fill:#e1f5fe
    style E fill:#c8e6c9
```

---

## ConfigMaps y Secrets: Configuraci√≥n

::: {.columns}
::: {.column width="60%}
**ConfigMaps:**
- Configuraci√≥n no sensible
- Variables de entorno, archivos de config
- Puede montarse como volumen

**Secrets:**
- Informaci√≥n sensible
- Passwords, tokens, keys
- Encriptados en etcd

**Uso en Pods:**
- Variables de entorno
- Vol√∫menes montados
- Image pull secrets
:::

Un **ConfigMap** es un objeto de Kubernetes que almacena **datos de configuraci√≥n no sensibles** como:
- URLs de servicios
- Nombres de bases de datos
- Flags de feature
- Archivos de configuraci√≥n (`.env`, `.yaml`, etc.)

> üì¶ Piensa en un ConfigMap como un **diccionario clave-valor** que vive en el cl√∫ster.

::: {.column width="40%"}
```mermaid
graph TB
    A[ConfigMap] --> B[Pod]
    C[Secret] --> B
    
    style C fill:#ffebee
```

```mermaid
graph LR
  ConfigMap["ConfigMap: db-config"] -->|injected as| Pod["Pod: fastapi"]
  Pod --> App["App lee: DB_URL"]
```

:::
:::

---

## Secrets: Tu b√≥veda de seguridad

### ¬øQu√© es un Secret?

Un **Secret** es como un ConfigMap, pero para **datos sensibles**:
- Contrase√±as
- Tokens de API
- Claves SSH
- Certificados TLS

> üîí Los Secrets se almacenan **codificados en base64** (¬°pero no cifrados por defecto!).  
> En producci√≥n, usa **encriptaci√≥n en reposo** o integraci√≥n con **Vault/Cloud KMS**.

> üí° **Regla de oro**:  
> Si no quieres que aparezca en un screenshot‚Ä¶ ¬°es un Secret!

---

## ¬øC√≥mo inyectar ConfigMaps y Secrets en tus Pods?

Tienes **dos formas principales**:

### 1. Como **variables de entorno**

```yaml
env:
  - name: DB_URL
    valueFrom:
      configMapKeyRef:
        name: db-config
        key: url
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: db-credentials
        key: password
```

### 2. Como **archivos en un volumen**

```yaml
volumeMounts:
  - name: config-volume
    mountPath: /etc/config
volumes:
  - name: config-volume
    configMap:
      name: app-config
```

> üß† **¬øCu√°ndo usar cada uno?**  
> - Variables de entorno ‚Üí para pocos valores, simples.  
> - Archivos ‚Üí para configuraciones complejas (ej: `nginx.conf`, `appsettings.json`).

---


## Almacenamiento persistente en Kubernetes

::: {.columns}
::: {.column width="60%}
**Problema:**
- Los Pods son ef√≠meros
- El almacenamiento del Pod se pierde al reiniciar
- ¬øD√≥nde guardo bases de datos, archivos?

**Soluci√≥n: Persistent Volumes**
- Almacenamiento persistente independiente del Pod
- Diferentes backends (local, cloud, NFS, etc.)
- Claim mechanism (PVC) para solicitar almacenamiento
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Pod] --> B[PersistentVolumeClaim]
    B --> C[PersistentVolume]
    C --> D[Almacenamiento f√≠sico]
    
    style C fill:#fff3e0
```
:::
:::

---

## Patr√≥n t√≠pico: Aplicaci√≥n web completa

```mermaid
graph TB
    A[Usuario] --> B[Ingress]
    B --> C[Frontend Service]
    B --> D[API Service]
    
    C --> E[Frontend Pods]
    D --> F[API Pods]
    F --> G[Database Service]
    G --> H[Database Pod]
    
    I[ConfigMap] --> E
    I --> F
    J[Secret] --> F
    J --> H
    K[Persistent Volume] --> H
    
    style B fill:#c8e6c9
    style C fill:#e1f5fe
    style D fill:#e1f5fe
    style G fill:#e1f5fe
```

---

## Buenas pr√°cticas de seguridad

### Con Secrets:

1. **Nunca commits secrets al repositorio**  
   ‚Üí Usa `.gitignore` y herramientas como `sealed-secrets` o `SOPS`.

2. **Limita el acceso con RBAC**  
   ‚Üí Solo los pods que lo necesitan deben poder leer el Secret.

3. **Rota las credenciales regularmente**  
   ‚Üí Kubernetes actualiza los Secrets en los pods **autom√°ticamente** (¬°pero la app debe recargarlos!).

> ‚ö†Ô∏è **¬°Ojo!** Los Secrets montados como archivos **se actualizan en vivo**,  
> pero las variables de entorno **NO** (requieren reinicio del pod).

---

## Resumen visual: Arquitectura ideal

```mermaid
graph LR
  Internet -->|HTTP| Service[Service: LoadBalancer]
  Service --> Deployment[Deployment: fastapi]
  Deployment --> Pod1[Pod]
  Deployment --> Pod2[Pod]
  Pod1 -->|lee| ConfigMap[ConfigMap: db-url]
  Pod1 -->|lee| Secret[Secret: db-pass]
  Pod2 -->|lee| ConfigMap
  Pod2 -->|lee| Secret
```

- **Exposici√≥n**: `LoadBalancer` ‚Üí tr√°fico externo  
- **Configuraci√≥n**: `ConfigMap` + `Secret` ‚Üí inyectados en pods  
- **Aplicaci√≥n**: c√≥digo limpio, sin secretos, sin URLs hardcodeadas

---

## ¬øQu√© NO hacer?

| ‚ùå Mal | ‚úÖ Bien |
|--------|--------|
| `password = "m1s3cr3t"` en el c√≥digo | Usar un Secret |
| Exponer con `NodePort` en producci√≥n | Usar `LoadBalancer` + Ingress |
| Hardcodear `localhost:5432` | Usar ConfigMap con `db.prod.svc.cluster.local` |
| Reiniciar pods manualmente al cambiar config | Dise√±ar apps que recarguen config en caliente |

> üö´ **La configuraci√≥n quemada = deuda t√©cnica con intereses**.

---


## Escalado autom√°tico: HPA

::: {.columns}
::: {.column width="60%}
**Horizontal Pod Autoscaler:**
- Escala autom√°ticamente el n√∫mero de Pods
- Basado en m√©tricas de CPU, memoria o custom
- Define m√≠nimos y m√°ximos

**Ejemplo:**
- CPU > 70% ‚Üí a√±adir Pods
- CPU < 30% ‚Üí quitar Pods
- M√≠nimo: 2 Pods, M√°ximo: 10 Pods
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[M√©tricas] --> B[HPA]
    B --> C[Deployment]
    C --> D[+ Pods]
    C --> E[- Pods]
    
    style B fill:#f3e5f5
```
:::
:::

---

## Service Mesh: La evoluci√≥n de las redes

::: {.columns}
::: {.column width="60%}
**¬øQu√© resuelve?**
- Observabilidad (metrics, traces, logs)
- Comunicaci√≥n segura (mTLS)
- Control de tr√°fico avanzado
- Resiliencia (retries, timeouts, circuit breakers)

**Implementaciones populares:**
- Istio
- Linkerd
- Consul Connect
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Service Mesh] --> B[Sidecar Proxy]
    A --> C[Control Plane]
    
    B --> D[Comunicaci√≥n segura]
    B --> E[M√©tricas]
    B --> F[Control tr√°fico]
    
    style A fill:#e8f5e8
```
:::
:::

---

## Resumen: Exponiendo aplicaciones

| Recurso | Prop√≥sito | Cu√°ndo usar |
|---------|-----------|-------------|
| **Pod** | Unidad de ejecuci√≥n | Contenedores de tu app |
| **Service** | Punto de acceso estable | Comunicaci√≥n interna/estable |
| **Ingress** | Routing HTTP/S | Acceso externo con reglas |
| **LoadBalancer** | IP p√∫blica directa | Servicios que necesitan IP √∫nica |

---

## Resumen: Redes en Kubernetes

| Concepto | Funci√≥n | Importancia |
|----------|---------|-------------|
| **CNI** | Networking de pods | Comunicaci√≥n pod-to-pod |
| **DNS** | Descubrimiento de servicios | Resoluci√≥n autom√°tica de nombres |
| **Network Policies** | Seguridad de red | Aislamiento y control de tr√°fico |
| **Service Mesh** | Redes avanzadas | Observabilidad y control fino |

---

## Buenas pr√°cticas de networking

**Seguridad:**
- Usa Network Policies para aislar tr√°fico
- Limita exposici√≥n de servicios
- Usa mTLS para comunicaci√≥n interna sensible

**Rendimiento:**
- Elegir CNI plugin apropiado para tu caso
- Monitorizar m√©tricas de red
- Optimizar tama√±o de pods y recursos

**Mantenibilidad:**
- Nomenclatura consistente para servicios
- Documentar dependencias entre servicios
- Usar labels y annotations efectivamente

---

## Evoluci√≥n del networking en Kubernetes

```mermaid
graph LR
    A[Pods b√°sicos] --> B[Services]
    B --> C[Ingress]
    C --> D[Network Policies]
    D --> E[Service Mesh]
    
    style B fill:#e1f5fe
    style C fill:#c8e6c9
    style E fill:#e8f5e8
```

**Desde lo simple hasta enterprise-grade**

---

## ¬°Preparados para el mundo real!

**Lo que hemos cubierto:**
- Fundamentos de Kubernetes y su arquitectura
- Pods, Services y Deployments
- Estrategias para exponer aplicaciones
- Modelo de red y DNS de Kubernetes
- Conceptos avanzados como Service Mesh

**Siguiente paso:** Laboratorio pr√°ctico donde desplegaremos aplicaciones reales en Kubernetes y configuraremos redes complejas.
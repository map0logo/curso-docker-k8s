---
title: Exponiendo aplicaciones con Kubernetes
subtitle: Redes en Kubernetes
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
---

# Exponiendo aplicaciones con Kubernetes y Redes en Kubernetes

## IntroducciÃ³n: Â¿Por quÃ© necesitamos exponer aplicaciones?

- En Kubernetes, los pods son efÃ­meros: nacen, mueren y se reemplazan constantemente.
- Las IP de los pods **no son estables** â†’ Â¡No puedes depender de ellas!
- Necesitamos una forma **estable y confiable** de acceder a nuestras aplicaciones.
- AdemÃ¡s, Â¿cÃ³mo se comunican los pods entre sÃ­? Â¿Y con el mundo exterior?

> ğŸ’¡ **Â¡Imagina que cada vez que tu casa se mudara, cambiaras de nÃºmero telefÃ³nico!**  
> Necesitas un nÃºmero fijo (como un Service) que siempre te encuentre.

---

## Â¿QuÃ© es la red en Kubernetes?

### El modelo de red de Kubernetes

Kubernetes asume un modelo de red simple pero poderoso:

1. **Todos los pods pueden comunicarse entre sÃ­ sin NAT**  
   â†’ Cada pod tiene su propia IP y puede hablar con cualquier otro pod directamente.

2. **Todos los nodos pueden comunicarse con todos los pods**  
   â†’ Sin traducciÃ³n de direcciones.

3. **La IP que un pod ve para sÃ­ mismo es la misma que ven los demÃ¡s**  
   â†’ Â¡No hay trucos de enmascaramiento!

> ğŸ§  **Esto significa que la red en Kubernetes es â€œplanaâ€**: no hay jerarquÃ­as complejas de subredes por defecto.

---

## ComunicaciÃ³n interna: CÃ³mo hablan los pods entre sÃ­

### Escenario tÃ­pico

```mermaid
graph LR
  A[Pod A<br/>IP: 10.244.1.5] -->|Conecta a| B[Pod B<br/>IP: 10.244.2.8]
  B -->|Responde a| A
```

- Pod A conoce la IP de Pod B â†’ puede hacer una peticiÃ³n HTTP directa.
- Peroâ€¦ Â¿y si Pod B muere y se recrea con una IP diferente?

> â— **Problema**: Las IPs de los pods **no son permanentes**.

---

## La soluciÃ³n: Services

### Â¿QuÃ© es un Service?

Un **Service** es una abstracciÃ³n que define un conjunto lÃ³gico de pods y una polÃ­tica para acceder a ellos.

- Proporciona una **IP estable** y un **nombre DNS**.
- ActÃºa como un **balanceador de carga** interno.
- Selecciona pods usando **etiquetas (labels)**.

```mermaid
graph LR
  Client --> Service
  Service --> Pod1
  Service --> Pod2
  Service --> Pod3
```

> ğŸ’¡ **Piensa en un Service como un â€œrepartidor de trÃ¡ficoâ€** que siempre sabe dÃ³nde estÃ¡n tus pods, incluso si se mueven.

---

## Tipos de Services

### 1. ClusterIP (por defecto)

- Solo accesible **dentro del clÃºster**.
- Ideal para comunicaciÃ³n interna (microservicios).

### 2. NodePort

- Expone el Service en un **puerto estÃ¡tico** en cada nodo.
- Accesible desde fuera del clÃºster: `http://<IP-nodo>:<puerto>`

### 3. LoadBalancer

- Crea un balanceador de carga **externo** (en la nube).
- Ideal para aplicaciones pÃºblicas.

### 4. ExternalName

- Mapea el Service a un **nombre DNS externo** (no usa pods).

> ğŸ§© **Â¿CuÃ¡l usar?**  
> - Interno â†’ `ClusterIP`  
> - Pruebas rÃ¡pidas â†’ `NodePort`  
> - ProducciÃ³n en la nube â†’ `LoadBalancer`

---

## Â¿CÃ³mo funciona un Service por dentro?

### El selector y los endpoints

- Un Service usa un **selector** (etiquetas) para encontrar pods.
- Kubernetes mantiene automÃ¡ticamente una lista de **endpoints** (IP + puerto de los pods seleccionados).

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mi-app
spec:
  selector:
    app: frontend  # â† Â¡Esto es clave!
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
```

> ğŸ” **El Service no conoce IPs directamente** â†’ solo conoce etiquetas.  
> Â¡Los pods pueden cambiar, pero el Service siempre los encontrarÃ¡!

---

## DNS en Kubernetes

### Â¡Cada Service tiene un nombre DNS!

Dentro del clÃºster, puedes acceder a un Service usando:

```
<nombre-del-service>.<namespace>.svc.cluster.local
```

Ejemplo:  
- Service: `web` en namespace `default`  
- Acceso: `http://web.default.svc.cluster.local`

> ğŸŒ **Esto es mucho mÃ¡s fÃ¡cil que recordar IPs**.  
> Y si cambia la IP del Serviceâ€¦ Â¡el DNS sigue funcionando!

---

## Exponiendo al exterior: Ingress

### El problema con NodePort y LoadBalancer

- Cada Service necesita su propio puerto o balanceador â†’ **costoso y difÃ­cil de gestionar**.
- No hay enrutamiento HTTP inteligente (por rutas, hosts, etc.).

### SoluciÃ³n: Ingress

- Un **controlador de Ingress** (como NGINX, Traefik) actÃºa como puerta de entrada HTTP/HTTPS.
- Define reglas para enrutar trÃ¡fico a diferentes Services.

```mermaid
graph LR
  Internet --> IngressController
  IngressController -->|/api| ServiceA
  IngressController -->|/web| ServiceB
  IngressController -->|host: tienda.com| ServiceC
```

> ğŸšª **Ingress = el recepcionista del edificio**  
> Recibe a todos los visitantes y los dirige al departamento correcto.

---

## Objetos Ingress: Reglas de enrutamiento

### Ejemplo de regla por ruta

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mi-ingress
spec:
  rules:
  - http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
      - path: /web
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

> ğŸ§­ **Ingress te permite hacer enrutamiento avanzado** sin tocar el cÃ³digo de tus apps.

---

## TLS y seguridad con Ingress

### Â¿Y si queremos HTTPS?

- Puedes adjuntar un **certificado TLS** al Ingress.
- El trÃ¡fico se cifra desde el cliente hasta el Ingress Controller.

```yaml
spec:
  tls:
  - hosts:
    - miapp.com
    secretName: mi-certificado-tls
  rules:
  - host: miapp.com
    http:
      paths: [...]
```

> ğŸ”’ **Â¡Tu app sigue hablando HTTP internamente!**  
> El Ingress se encarga del cifrado/descifrado (TLS termination).

---

## Resumen visual: Flujo completo

```mermaid
flowchart TB
  Usuario -->|HTTPS| IngressController
  IngressController -->|HTTP| Service[Service: web]
  Service --> Pod1[Pod: web-7d5b6c8f9-abc12]
  Service --> Pod2[Pod: web-7d5b6c8f9-def34]
  subgraph Cluster
    IngressController
    Service
    Pod1
    Pod2
  end
```

1. Usuario accede a `https://miapp.com`
2. Ingress Controller recibe la peticiÃ³n
3. Enruta a `Service: web` segÃºn las reglas
4. Service distribuye a uno de los pods

---

## Â¿QuÃ© pasa si un pod falla?

### Auto-reparaciÃ³n y descubrimiento

- Kubernetes **elimina automÃ¡ticamente** los pods fallidos de los endpoints del Service.
- El Service **solo envÃ­a trÃ¡fico a pods saludables**.
- Si se crea un nuevo pod con las etiquetas correctas â†’ Â¡se agrega automÃ¡ticamente!

> ğŸ”„ **Es un sistema autÃ³nomo**: no necesitas reiniciar nada ni reconfigurar IPs.

---

## Namespaces y aislamiento de red

### Â¿Pueden los Services cruzar namespaces?

- **SÃ­**, pero necesitas usar el nombre completo:  
  `servicio.namespace.svc.cluster.local`
- Por defecto, los Services **solo resuelven dentro de su namespace**.

> ğŸ§± **Los namespaces son como departamentos en una empresa**:  
> Puedes llamar a otro departamento, pero debes marcar el nÃºmero completo.

---

## Limitaciones y consideraciones

### Cosas que debes saber

- **Services no son mÃ¡gicos**: si todos los pods estÃ¡n caÃ­dos, el Service no responde.
- **Ingress requiere un controlador**: no viene activado por defecto en todos los clÃºsteres.
- **ClusterIP no es accesible desde fuera**: no intentes usarlo para exponer apps pÃºblicas.
- **NodePort usa puertos altos (30000-32767)**: asegÃºrate de que tu firewall lo permita.

> âš ï¸ **Â¡No confundas Service con Deployment!**  
> El Deployment gestiona los pods. El Service gestiona el acceso a esos pods.

---

## ComparaciÃ³n rÃ¡pida: Service vs Ingress

| CaracterÃ­stica        | Service (NodePort/LB) | Ingress               |
|----------------------|------------------------|------------------------|
| Protocolo            | Cualquiera (TCP/UDP)   | Solo HTTP/HTTPS        |
| Enrutamiento         | No (1:1)               | SÃ­ (por host/ruta)     |
| TLS                  | Manual                 | Integrado              |
| Costo (en la nube)   | Alto (1 LB por Service)| Bajo (1 LB para todos) |
| Ideal para           | APIs gRPC, bases de datos | Aplicaciones web    |

> ğŸ“Š **Usa Ingress para HTTP, Service para todo lo demÃ¡s.**

---

## ConclusiÃ³n: La red en Kubernetes, paso a paso

1. **Tus apps corren en pods efÃ­meros** â†’ IPs cambiantes.
2. **Crea un Service** para darles una identidad estable.
3. **Usa ClusterIP** para comunicaciÃ³n interna.
4. **Para exponer al exterior**:  
   - Pruebas â†’ `NodePort`  
   - ProducciÃ³n â†’ `LoadBalancer` + `Ingress`
5. **Ingress te da enrutamiento inteligente y TLS** sin tocar tus apps.

> ğŸ¯ **Recuerda**: Kubernetes se encarga de la complejidad.  
> TÃº solo defines *quÃ©* quieres, no *cÃ³mo* hacerlo.

---

## Â¿Preguntas?

### Â¡Ahora es tu turno!

- Â¿QuÃ© tipo de Service usarÃ­as para una base de datos interna?
- Â¿Por quÃ© no usarÃ­as Ingress para una app de videojuegos en UDP?
- Â¿CÃ³mo accederÃ­as desde el namespace `dev` al Service `cache` en `prod`?

> ğŸ’¬ **Piensa en la red de Kubernetes como una ciudad inteligente**:  
> Calles (pods), semÃ¡foros (Services) y centros de control de trÃ¡fico (Ingress).  
> Â¡Todo fluye sin que tÃº conduzcas!
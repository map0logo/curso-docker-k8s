---
title: Exponiendo aplicaciones con Kubernetes
subtitle: Redes en Kubernetes
date: last-modified
author:
  - name: Francisco Palm
    orcid: 0000-0002-1293-0868
    email: fpalm@qu4nt.com
    affiliations: qu4nt, activistasxsl
format:
  clean-revealjs
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
lang: es
logo: images/qu4nt-logo.png
---

# Exponiendo aplicaciones con Kubernetes y Redes en Kubernetes

---

## De Docker a Kubernetes: El siguiente nivel

::: {.columns}
::: {.column width="50%"}
**Â¿Recuerdas Docker Compose?**
- Perfecto para single-host
- Desarrollo y testing
- Limitado para producciÃ³n

**Problemas en escala:**
- Â¿Y si un host falla?
- Â¿CÃ³mo escalo automÃ¡ticamente?
- Â¿CÃ³mo gestiono updates sin downtime?
- Â¿Y el load balancing?
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[Host Ãšnico] --> B[Single Point of Failure]
    C[Escala Manual] --> D[Ineficiente]
    E[Updates] --> F[Downtime]
    
    style B fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
```
:::
:::

**Kubernetes: La orquestaciÃ³n de contenedores a escala enterprise**

> En esta sesiÃ³n aprenderemos a **exponer aplicaciones** del clÃºster y **gestionar su configuraciÃ³n** de forma segura y desacoplada.

Imagina esto:

- Tu app estÃ¡ corriendo feliz en Kubernetesâ€¦  
- Pero **nadie puede acceder a ella** desde fuera.  
- Y ademÃ¡s, **sus credenciales estÃ¡n quemadas en el cÃ³digo** ðŸ”¥.

> ðŸ˜± Â¡Dos grandes no-nos en producciÃ³n!

Hoy resolveremos ambos problemas:  
âœ… **ExposiciÃ³n controlada**  
âœ… **ConfiguraciÃ³n limpia y segura**

---

## Â¿QuÃ© es Kubernetes realmente?

::: {.columns}
::: {.column width="60%"}
**DefiniciÃ³n formal:**
- Sistema open-source para automatizar el despliegue, escalado y gestiÃ³n de aplicaciones en contenedores

**En tÃ©rminos simples:**
- Como un "sistema operativo para clusters"
- Gestiona dÃ³nde se ejecutan tus contenedores
- Se asegura de que siempre estÃ©n corriendo
- Escala automÃ¡ticamente segÃºn la demanda

**AnalogÃ­a:**
- Kubernetes es el director de orquesta
- Los nodos son los mÃºsicos
- Los pods son las partituras individuales
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Kubernetes Master] --> B[Node 1]
    A --> C[Node 2]
    A --> D[Node 3]
    
    B --> E[Pods]
    C --> F[Pods]
    D --> G[Pods]
    
    style A fill:#ffccbc
```
:::
:::

---

## Arquitectura de Kubernetes: VisiÃ³n general

```mermaid
graph TB
    A[Control Plane] --> B[API Server]
    A --> C[etcd]
    A --> D[Scheduler]
    A --> E[Controller Manager]
    
    F[Worker Nodes] --> G[Kubelet]
    F --> H[Kube Proxy]
    F --> I[Container Runtime]
    
    B --> G
    D --> J[Pods en Nodes]
    
    style A fill:#e3f2fd
    style F fill:#e8f5e8
```

---

## Conceptos fundamentales de Kubernetes

```mermaid
graph TB
    A[Kubernetes Concepts] --> B[Pods]
    A --> C[Services]
    A --> D[Deployments]
    A --> E[Ingress]
    A --> F[Namespaces]
    
    B --> G[Unidad mÃ­nima deployable]
    C --> H[Punto de acceso estable]
    D --> I[GestiÃ³n de aplicaciones]
    E --> J[Acceso desde exterior]
    F --> K[Aislamiento lÃ³gico]
```

---

## Pods: La unidad atÃ³mica de Kubernetes

::: {.columns}
::: {.column width="50%}
**Â¿QuÃ© es un Pod?**
- La unidad mÃ¡s pequeÃ±a que puedes desplegar
- Grupo de uno o mÃ¡s contenedores
- Comparten recursos de red y almacenamiento
- Mismo contexto de ejecuciÃ³n

**CaracterÃ­sticas clave:**
- DirecciÃ³n IP Ãºnica compartida
- Namespace de red compartido
- VolÃºmenes compartidos
- Ciclo de vida conjunto
:::

::: {.column width="50%"}
```mermaid
graph TB
    A[Pod IP: 10.0.0.5] --> B[Contenedor App]
    A --> C[Contenedor Sidecar]
    A --> D[Volumen compartido]
    
    B --> E[Puerto 8080]
    C --> F[Puerto 9090]
    
    style A fill:#e1f5fe
```
:::
:::

**ðŸ’¡ Importante: Normalmente 1 contenedor por Pod, pero pueden ser mÃ¡s para casos especiales**

---

### Â¿CÃ³mo hablan las apps con el mundo?

En Kubernetes, los **pods son efÃ­meros**: nacen, mueren, se reemplazan.  
Sus IPs **cambian constantemente** â†’ Â¡No puedes depender de ellas!

> ðŸ§  **Necesitas una identidad estable** para tu aplicaciÃ³n.  
> Eso es exactamente lo que ofrece un **Service**.

---

## Services: La red estable en Kubernetes

::: {.columns}
::: {.column width="60%}
**Problema:**
- Los Pods son efÃ­meros (nacen y mueren)
- Las IPs de los Pods cambian constantemente
- Â¿CÃ³mo encuentran los clientes a los Pods?

**SoluciÃ³n: Services**
- Punto de acceso estable y permanente
- IP virtual que no cambia
- Balancea carga entre Pods backend
- Descubre automÃ¡ticamente los Pods
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[Cliente] --> B[Service IP: 10.3.241.150]
    B --> C[Pod A: 10.0.0.5]
    B --> D[Pod B: 10.0.0.6]
    B --> E[Pod C: 10.0.0.7]
    
    style B fill:#c8e6c9
```
:::
:::

---

Un **Service** es una abstracciÃ³n que define un **punto de acceso estable** a un conjunto de pods.

- Usa **etiquetas (labels)** para seleccionar pods.
- Proporciona una **IP virtual** y un **nombre DNS** fijos.
- ActÃºa como **balanceador de carga interno**.

> ðŸ’¡ **El Service no se preocupa por IPs reales** â†’ solo por etiquetas.  
> Â¡Los pods pueden morir y renacer, y el Service siempre los encontrarÃ¡!

---

## Tipos de Services

```mermaid
graph TB
    A[Service Types] --> B[ClusterIP]
    A --> C[NodePort]
    A --> D[LoadBalancer]
    A --> E[ExternalName]
    
    B --> F[Interno al cluster]
    C --> G[Acceso mediante puertos del nodo]
    D --> H[Cloud Load Balancer externo]
    E --> I[Alias para servicio externo]
    
    style B fill:#e1f5fe
    style C fill:#fff3e0
    style D fill:#f3e5f5
```

---

## ClusterIP: ComunicaciÃ³n interna (por defecto)

::: {.columns}
::: {.column width="60%}
**CaracterÃ­sticas:**
- IP accesible solo dentro del cluster
- Default type para servicios
- Perfecto para comunicaciÃ³n entre microservicios

**Ejemplo tÃ­pico:**
- Frontend â†’ Backend API
- API â†’ Database
- Servicios internos que no exponen al exterior
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[Frontend Pod] --> B[API Service<br/>clusterip: 10.96.1.5]
    B --> C[API Pod 1]
    B --> D[API Pod 2]
    
    style B fill:#e1f5fe
```
:::
:::

---

## NodePort: Acceso externo bÃ¡sico

::: {.columns}
::: {.column width="60%}
**CaracterÃ­sticas:**
- Expone el servicio en un puerto estÃ¡tico en cada nodo
- Accesible desde fuera del cluster
- Puerto en rango 30000-32767

**Flujo de trÃ¡fico:**
1. Cliente â†’ NodeIP:NodePort
2. Nodo â†’ Service
3. Service â†’ Pod destino
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Cliente] --> B[NodeIP:30080]
    B --> C[Service]
    C --> D[Pod Backend]
    
    style B fill:#fff3e0
```
:::
:::

**âš ï¸ No ideal para producciÃ³n - usa Ingress**

---

## LoadBalancer: IntegraciÃ³n con cloud

::: {.columns}
::: {.column width="60%}
**CaracterÃ­sticas:**
- Crea un load balancer externo en cloud providers
- Asigna IP externa automÃ¡ticamente
- IntegraciÃ³n nativa con AWS, GCP, Azure

**Ideal para:**
- Servicios que necesitan IP pÃºblica estable
- Aplicaciones crÃ­ticas en cloud
- Cuando necesitas balanceo de carga gestionado
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Internet] --> B[Cloud LB: 35.200.10.5]
    B --> C[Node 1]
    B --> D[Node 2]
    B --> E[Node 3]
    
    C --> F[Service]
    D --> F
    E --> F
    
    style B fill:#f3e5f5
```
:::
:::

---

> ðŸ§© **Regla mental**:  
> - Interno â†’ `ClusterIP`  
> - Pruebas â†’ `NodePort`  
> - ProducciÃ³n â†’ `LoadBalancer`

---

## Â¿CÃ³mo se define un Service?

```yaml
apiVersion: v1
kind: Service
meta
  name: mi-app
spec:
  type: LoadBalancer        # â† Â¡elige el tipo!
  selector:
    app: fastapi            # â† debe coincidir con los labels de tus pods
  ports:
    - protocol: TCP
      port: 80              # puerto del Service
      targetPort: 8000      # puerto del contenedor
```

> ðŸ” **El secreto estÃ¡ en el `selector`**:  
> Si tus pods tienen `app: fastapi`, Â¡el Service los encontrarÃ¡!

---

## Ingress: El router inteligente

::: {.columns}
::: {.column width="60%}
**Problema con LoadBalancer:**
- Un LoadBalancer por servicio â†’ costoso
- No puede hacer routing basado en paths/hosts

**SoluciÃ³n: Ingress**
- Un punto de entrada para mÃºltiples servicios
- Routing basado en reglas (host, path, headers)
- TerminaciÃ³n SSL/TLS
- Rewrite rules y autenticaciÃ³n
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Internet] --> B[Ingress Controller]
    B --> C[/api â†’ API Service]
    B --> D[/app â†’ Web Service]
    B --> E[/docs â†’ Docs Service]
    
    style B fill:#c8e6c9
```
:::
:::

---

## Ingress vs LoadBalancer

```mermaid
graph TB
    A[TrÃ¡fico Entrante] --> B{Â¿Necesitas routing avanzado?}
    
    B -->|SÃ­| C[Ingress Controller]
    B -->|No| D[LoadBalancer Service]
    
    C --> E[Routing por host/path]
    C --> F[SSL Termination]
    C --> G[Un LB para mÃºltiples apps]
    
    D --> H[IP pÃºblica directa]
    D --> I[Simple y directo]
    
    style C fill:#c8e6c9
    style D fill:#f3e5f5
```

---

## Deployments: Gestionando el ciclo de vida

::: {.columns}
::: {.column width="60%}
**Â¿QuÃ© resuelve?**
- Â¿CÃ³mo actualizo mi app sin downtime?
- Â¿CÃ³mo escalo automÃ¡ticamente?
- Â¿CÃ³mo vuelvo a una versiÃ³n anterior?

**Deployment proporciona:**
- Updates rolling (sin downtime)
- Rollbacks automÃ¡ticos
- Escalado automÃ¡tico (HPA)
- Replica management
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Deployment] --> B[ReplicaSet v1]
    A --> C[ReplicaSet v2]
    
    B --> D[Pods v1.0]
    C --> E[Pods v1.1]
    
    style A fill:#ffccbc
```
:::
:::

---

## Modelo de red de Kubernetes

::: {.columns}
::: {.column width="60%}
**Principios fundamentales:**
1. Todo Pod puede comunicarse con todo Pod sin NAT
2. Todo Node puede comunicarse con todo Pod sin NAT
3. La IP que un Pod ve en sÃ­ mismo es la misma que otros Pods ven

**ImplementaciÃ³n:**
- CNI (Container Network Interface) plugins
- Cada Pod tiene IP real de red
- No overlays complicados (en la mayorÃ­a de casos)
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[Pod A] --> B[Pod B]
    C[Pod C] --> B
    A --> C
    
    style A fill:#e1f5fe
    style B fill:#e1f5fe
    style C fill:#e1f5fe
```
:::
:::

---

## DNS en Kubernetes

::: {.columns}
::: {.column width="60%}
**Descubrimiento automÃ¡tico de servicios:**
- Cada Service obtiene un DNS name
- Formato: `<service-name>.<namespace>.svc.cluster.local`
- ResoluciÃ³n dentro del cluster automÃ¡tica

**Ejemplos:**
- `frontend.default.svc.cluster.local`
- `database.production.svc.cluster.local`
- `redis.cache.svc.cluster.local`

**Simplificado:**
- `frontend` (mismo namespace)
- `database.production` (namespace diferente)
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[App Pod] --> B[CoreDNS]
    B --> C[Resuelve: api-service]
    C --> D[10.96.1.5]
    
    style B fill:#fff9c4
```
:::
:::

---

## Namespaces: Aislamiento lÃ³gico

::: {.columns}
::: {.column width="60%}
**Â¿Para quÃ© sirven?**
- Aislar recursos (dev, staging, prod)
- LÃ­mites de recursos por equipo
- Control de acceso (RBAC)

**Namespaces comunes:**
- `default` (por defecto)
- `kube-system` (sistema de Kubernetes)
- `kube-public` (recursos pÃºblicos)
- `custom` (tus aplicaciones)
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Cluster] --> B[Namespace: dev]
    A --> C[Namespace: staging]
    A --> D[Namespace: prod]
    
    B --> E[Pods/Services dev]
    C --> F[Pods/Services staging]
    D --> G[Pods/Services prod]
    
    style B fill:#e1f5fe
    style C fill:#fff3e0
    style D fill:#c8e6c9
```
:::
:::

---

## Flujo completo: De imagen a servicio expuesto

```mermaid
graph TB
    A[Imagen Docker] --> B[Deployment]
    B --> C[Pods]
    C --> D[Service]
    D --> E[Ingress]
    E --> F[Internet]
    
    G[ConfigMap] --> C
    H[Secret] --> C
    I[PersistentVolume] --> C
    
    style D fill:#e1f5fe
    style E fill:#c8e6c9
```

---

## ConfigMaps y Secrets: ConfiguraciÃ³n

::: {.columns}
::: {.column width="60%}
**ConfigMaps:**
- ConfiguraciÃ³n no sensible
- Variables de entorno, archivos de config
- Puede montarse como volumen

**Secrets:**
- InformaciÃ³n sensible
- Passwords, tokens, keys
- Encriptados en etcd

**Uso en Pods:**
- Variables de entorno
- VolÃºmenes montados
- Image pull secrets
:::

Un **ConfigMap** es un objeto de Kubernetes que almacena **datos de configuraciÃ³n no sensibles** como:
- URLs de servicios
- Nombres de bases de datos
- Flags de feature
- Archivos de configuraciÃ³n (`.env`, `.yaml`, etc.)

> ðŸ“¦ Piensa en un ConfigMap como un **diccionario clave-valor** que vive en el clÃºster.

::: {.column width="40%"}
```mermaid
graph TB
    A[ConfigMap] --> B[Pod]
    C[Secret] --> B
    
    style C fill:#ffebee
```

```mermaid
graph LR
  ConfigMap["ConfigMap: db-config"] -->|injected as| Pod["Pod: fastapi"]
  Pod --> App["App lee: DB_URL"]
```

:::
:::

---

## Secrets: Tu bÃ³veda de seguridad

### Â¿QuÃ© es un Secret?

Un **Secret** es como un ConfigMap, pero para **datos sensibles**:
- ContraseÃ±as
- Tokens de API
- Claves SSH
- Certificados TLS

> ðŸ”’ Los Secrets se almacenan **codificados en base64** (Â¡pero no cifrados por defecto!).  
> En producciÃ³n, usa **encriptaciÃ³n en reposo** o integraciÃ³n con **Vault/Cloud KMS**.

> ðŸ’¡ **Regla de oro**:  
> Si no quieres que aparezca en un screenshotâ€¦ Â¡es un Secret!

---

## Â¿CÃ³mo inyectar ConfigMaps y Secrets en tus Pods?

Tienes **dos formas principales**:

### 1. Como **variables de entorno**

```yaml
env:
  - name: DB_URL
    valueFrom:
      configMapKeyRef:
        name: db-config
        key: url
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: db-credentials
        key: password
```

### 2. Como **archivos en un volumen**

```yaml
volumeMounts:
  - name: config-volume
    mountPath: /etc/config
volumes:
  - name: config-volume
    configMap:
      name: app-config
```

> ðŸ§  **Â¿CuÃ¡ndo usar cada uno?**  
> - Variables de entorno â†’ para pocos valores, simples.  
> - Archivos â†’ para configuraciones complejas (ej: `nginx.conf`, `appsettings.json`).

---


## Almacenamiento persistente en Kubernetes

::: {.columns}
::: {.column width="60%}
**Problema:**
- Los Pods son efÃ­meros
- El almacenamiento del Pod se pierde al reiniciar
- Â¿DÃ³nde guardo bases de datos, archivos?

**SoluciÃ³n: Persistent Volumes**
- Almacenamiento persistente independiente del Pod
- Diferentes backends (local, cloud, NFS, etc.)
- Claim mechanism (PVC) para solicitar almacenamiento
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Pod] --> B[PersistentVolumeClaim]
    B --> C[PersistentVolume]
    C --> D[Almacenamiento fÃ­sico]
    
    style C fill:#fff3e0
```
:::
:::

---

## PatrÃ³n tÃ­pico: AplicaciÃ³n web completa

```mermaid
graph TB
    A[Usuario] --> B[Ingress]
    B --> C[Frontend Service]
    B --> D[API Service]
    
    C --> E[Frontend Pods]
    D --> F[API Pods]
    F --> G[Database Service]
    G --> H[Database Pod]
    
    I[ConfigMap] --> E
    I --> F
    J[Secret] --> F
    J --> H
    K[Persistent Volume] --> H
    
    style B fill:#c8e6c9
    style C fill:#e1f5fe
    style D fill:#e1f5fe
    style G fill:#e1f5fe
```

---

## Buenas prÃ¡cticas de seguridad

### Con Secrets:

1. **Nunca commits secrets al repositorio**  
   â†’ Usa `.gitignore` y herramientas como `sealed-secrets` o `SOPS`.

2. **Limita el acceso con RBAC**  
   â†’ Solo los pods que lo necesitan deben poder leer el Secret.

3. **Rota las credenciales regularmente**  
   â†’ Kubernetes actualiza los Secrets en los pods **automÃ¡ticamente** (Â¡pero la app debe recargarlos!).

> âš ï¸ **Â¡Ojo!** Los Secrets montados como archivos **se actualizan en vivo**,  
> pero las variables de entorno **NO** (requieren reinicio del pod).

---

## Resumen visual: Arquitectura ideal

```mermaid
graph LR
  Internet -->|HTTP| Service[Service: LoadBalancer]
  Service --> Deployment[Deployment: fastapi]
  Deployment --> Pod1[Pod]
  Deployment --> Pod2[Pod]
  Pod1 -->|lee| ConfigMap[ConfigMap: db-url]
  Pod1 -->|lee| Secret[Secret: db-pass]
  Pod2 -->|lee| ConfigMap
  Pod2 -->|lee| Secret
```

- **ExposiciÃ³n**: `LoadBalancer` â†’ trÃ¡fico externo  
- **ConfiguraciÃ³n**: `ConfigMap` + `Secret` â†’ inyectados en pods  
- **AplicaciÃ³n**: cÃ³digo limpio, sin secretos, sin URLs hardcodeadas

---

## Â¿QuÃ© NO hacer?

| âŒ Mal | âœ… Bien |
|--------|--------|
| `password = "m1s3cr3t"` en el cÃ³digo | Usar un Secret |
| Exponer con `NodePort` en producciÃ³n | Usar `LoadBalancer` + Ingress |
| Hardcodear `localhost:5432` | Usar ConfigMap con `db.prod.svc.cluster.local` |
| Reiniciar pods manualmente al cambiar config | DiseÃ±ar apps que recarguen config en caliente |

> ðŸš« **La configuraciÃ³n quemada = deuda tÃ©cnica con intereses**.

---


## Escalado automÃ¡tico: HPA

::: {.columns}
::: {.column width="60%}
**Horizontal Pod Autoscaler:**
- Escala automÃ¡ticamente el nÃºmero de Pods
- Basado en mÃ©tricas de CPU, memoria o custom
- Define mÃ­nimos y mÃ¡ximos

**Ejemplo:**
- CPU > 70% â†’ aÃ±adir Pods
- CPU < 30% â†’ quitar Pods
- MÃ­nimo: 2 Pods, MÃ¡ximo: 10 Pods
:::

::: {.column width="40%"}
```mermaid
graph LR
    A[MÃ©tricas] --> B[HPA]
    B --> C[Deployment]
    C --> D[+ Pods]
    C --> E[- Pods]
    
    style B fill:#f3e5f5
```
:::
:::

---

## Service Mesh: La evoluciÃ³n de las redes

::: {.columns}
::: {.column width="60%}
**Â¿QuÃ© resuelve?**
- Observabilidad (metrics, traces, logs)
- ComunicaciÃ³n segura (mTLS)
- Control de trÃ¡fico avanzado
- Resiliencia (retries, timeouts, circuit breakers)

**Implementaciones populares:**
- Istio
- Linkerd
- Consul Connect
:::

::: {.column width="40%"}
```mermaid
graph TB
    A[Service Mesh] --> B[Sidecar Proxy]
    A --> C[Control Plane]
    
    B --> D[ComunicaciÃ³n segura]
    B --> E[MÃ©tricas]
    B --> F[Control trÃ¡fico]
    
    style A fill:#e8f5e8
```
:::
:::

---

## Resumen: Exponiendo aplicaciones

| Recurso | PropÃ³sito | CuÃ¡ndo usar |
|---------|-----------|-------------|
| **Pod** | Unidad de ejecuciÃ³n | Contenedores de tu app |
| **Service** | Punto de acceso estable | ComunicaciÃ³n interna/estable |
| **Ingress** | Routing HTTP/S | Acceso externo con reglas |
| **LoadBalancer** | IP pÃºblica directa | Servicios que necesitan IP Ãºnica |

---

## Resumen: Redes en Kubernetes

| Concepto | FunciÃ³n | Importancia |
|----------|---------|-------------|
| **CNI** | Networking de pods | ComunicaciÃ³n pod-to-pod |
| **DNS** | Descubrimiento de servicios | ResoluciÃ³n automÃ¡tica de nombres |
| **Network Policies** | Seguridad de red | Aislamiento y control de trÃ¡fico |
| **Service Mesh** | Redes avanzadas | Observabilidad y control fino |

---

## Buenas prÃ¡cticas de networking

**Seguridad:**
- Usa Network Policies para aislar trÃ¡fico
- Limita exposiciÃ³n de servicios
- Usa mTLS para comunicaciÃ³n interna sensible

**Rendimiento:**
- Elegir CNI plugin apropiado para tu caso
- Monitorizar mÃ©tricas de red
- Optimizar tamaÃ±o de pods y recursos

**Mantenibilidad:**
- Nomenclatura consistente para servicios
- Documentar dependencias entre servicios
- Usar labels y annotations efectivamente

---

## EvoluciÃ³n del networking en Kubernetes

```mermaid
graph LR
    A[Pods bÃ¡sicos] --> B[Services]
    B --> C[Ingress]
    C --> D[Network Policies]
    D --> E[Service Mesh]
    
    style B fill:#e1f5fe
    style C fill:#c8e6c9
    style E fill:#e8f5e8
```

**Desde lo simple hasta enterprise-grade**

---

## Â¡Preparados para el mundo real!

**Lo que hemos cubierto:**
- Fundamentos de Kubernetes y su arquitectura
- Pods, Services y Deployments
- Estrategias para exponer aplicaciones
- Modelo de red y DNS de Kubernetes
- Conceptos avanzados como Service Mesh

**Siguiente paso:** Laboratorio prÃ¡ctico donde desplegaremos aplicaciones reales en Kubernetes y configuraremos redes complejas.